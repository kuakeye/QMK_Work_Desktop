   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "./tmk_core/common/action.c"
   1:./tmk_core/common/action.c **** /*
   2:./tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action.c **** 
   4:./tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action.c **** (at your option) any later version.
   8:./tmk_core/common/action.c **** 
   9:./tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action.c **** GNU General Public License for more details.
  13:./tmk_core/common/action.c **** 
  14:./tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action.c **** */
  17:./tmk_core/common/action.c **** #include "host.h"
  18:./tmk_core/common/action.c **** #include "keycode.h"
  19:./tmk_core/common/action.c **** #include "keyboard.h"
  20:./tmk_core/common/action.c **** #include "mousekey.h"
  21:./tmk_core/common/action.c **** #include "command.h"
  22:./tmk_core/common/action.c **** #include "led.h"
  23:./tmk_core/common/action.c **** #include "backlight.h"
  24:./tmk_core/common/action.c **** #include "action_layer.h"
  25:./tmk_core/common/action.c **** #include "action_tapping.h"
  26:./tmk_core/common/action.c **** #include "action_macro.h"
  27:./tmk_core/common/action.c **** #include "action_util.h"
  28:./tmk_core/common/action.c **** #include "action.h"
  29:./tmk_core/common/action.c **** #include "wait.h"
  30:./tmk_core/common/action.c **** 
  31:./tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:./tmk_core/common/action.c **** #include "debug.h"
  33:./tmk_core/common/action.c **** #else
  34:./tmk_core/common/action.c **** #include "nodebug.h"
  35:./tmk_core/common/action.c **** #endif
  36:./tmk_core/common/action.c **** 
  37:./tmk_core/common/action.c **** int tp_buttons;
  38:./tmk_core/common/action.c **** 
  39:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:./tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:./tmk_core/common/action.c **** #endif
  42:./tmk_core/common/action.c **** 
  43:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:./tmk_core/common/action.c **** #include <fauxclicky.h>
  45:./tmk_core/common/action.c **** #endif
  46:./tmk_core/common/action.c **** 
  47:./tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:./tmk_core/common/action.c ****  *
  49:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:./tmk_core/common/action.c ****  */
  51:./tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:./tmk_core/common/action.c **** {
  16               		.loc 1 52 1 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  53:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 53 5 view .LVU1
  54:./tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:./tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  49               		.loc 1 55 58 view .LVU2
  56:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:./tmk_core/common/action.c ****         retro_tapping_counter++;
  58:./tmk_core/common/action.c **** #endif
  59:./tmk_core/common/action.c ****     }
  60:./tmk_core/common/action.c **** 
  61:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:./tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:./tmk_core/common/action.c ****     }
  65:./tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:./tmk_core/common/action.c ****     }
  68:./tmk_core/common/action.c ****     fauxclicky_check();
  69:./tmk_core/common/action.c **** #endif
  70:./tmk_core/common/action.c **** 
  71:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:./tmk_core/common/action.c ****         process_hand_swap(&event);
  74:./tmk_core/common/action.c ****     }
  75:./tmk_core/common/action.c **** #endif
  76:./tmk_core/common/action.c **** 
  77:./tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  50               		.loc 1 77 5 view .LVU3
  51               		.loc 1 77 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 1D82      		std Y+5,__zero_reg__
  54 0022 85E0      		ldi r24,lo8(5)
  55 0024 FE01      		movw r30,r28
  56 0026 3796      		adiw r30,7
  57 0028 DE01      		movw r26,r28
  58 002a 1196      		adiw r26,1
  59               		0:
  60 002c 0190      		ld r0,Z+
  61 002e 0D92      		st X+,r0
  62 0030 8A95      		dec r24
  63 0032 01F4      		brne 0b
  78:./tmk_core/common/action.c **** 
  79:./tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:./tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:./tmk_core/common/action.c ****     }
  83:./tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:./tmk_core/common/action.c ****         clear_oneshot_mods();
  85:./tmk_core/common/action.c ****     }
  86:./tmk_core/common/action.c **** #endif
  87:./tmk_core/common/action.c **** 
  88:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:./tmk_core/common/action.c ****     action_tapping_process(record);
  64               		.loc 1 89 5 is_stmt 1 view .LVU5
  65 0034 4981      		ldd r20,Y+1
  66               	.LVL1:
  67               		.loc 1 89 5 is_stmt 0 view .LVU6
  68 0036 5A81      		ldd r21,Y+2
  69               	.LVL2:
  70               		.loc 1 89 5 view .LVU7
  71 0038 6B81      		ldd r22,Y+3
  72 003a 7C81      		ldd r23,Y+4
  73 003c 8D81      		ldd r24,Y+5
  74 003e 9E81      		ldd r25,Y+6
  75               	/* epilogue start */
  90:./tmk_core/common/action.c **** #else
  91:./tmk_core/common/action.c ****     process_record(&record);
  92:./tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:./tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:./tmk_core/common/action.c ****     }
  95:./tmk_core/common/action.c **** #endif
  96:./tmk_core/common/action.c **** }
  76               		.loc 1 96 1 view .LVU8
  77 0040 2B96      		adiw r28,11
  78 0042 0FB6      		in __tmp_reg__,__SREG__
  79 0044 F894      		cli
  80 0046 DEBF      		out __SP_H__,r29
  81 0048 0FBE      		out __SREG__,__tmp_reg__
  82 004a CDBF      		out __SP_L__,r28
  83 004c DF91      		pop r29
  84 004e CF91      		pop r28
  89:./tmk_core/common/action.c **** #else
  85               		.loc 1 89 5 view .LVU9
  86 0050 0C94 0000 		jmp action_tapping_process
  87               	.LVL3:
  88               		.cfi_endproc
  89               	.LFE13:
  91               		.section	.text.process_record_quantum,"ax",@progbits
  92               		.weak	process_record_quantum
  94               	process_record_quantum:
  95               	.LVL4:
  96               	.LFB15:
  97:./tmk_core/common/action.c **** 
  98:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:./tmk_core/common/action.c **** bool swap_hands = false;
 100:./tmk_core/common/action.c **** bool swap_held = false;
 101:./tmk_core/common/action.c **** 
 102:./tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:./tmk_core/common/action.c ****  *
 104:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:./tmk_core/common/action.c ****  */
 106:./tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 107:./tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 108:./tmk_core/common/action.c **** 
 109:./tmk_core/common/action.c ****     keypos_t pos = event->key;
 110:./tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 111:./tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 112:./tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:./tmk_core/common/action.c **** 
 114:./tmk_core/common/action.c ****     if (do_swap) {
 115:./tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 116:./tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 117:./tmk_core/common/action.c ****     } else {
 118:./tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 119:./tmk_core/common/action.c ****     }
 120:./tmk_core/common/action.c **** }
 121:./tmk_core/common/action.c **** #endif
 122:./tmk_core/common/action.c **** 
 123:./tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 124:./tmk_core/common/action.c **** bool disable_action_cache = false;
 125:./tmk_core/common/action.c **** 
 126:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:./tmk_core/common/action.c **** {
 128:./tmk_core/common/action.c ****     disable_action_cache = true;
 129:./tmk_core/common/action.c ****     process_record(record);
 130:./tmk_core/common/action.c ****     disable_action_cache = false;
 131:./tmk_core/common/action.c **** }
 132:./tmk_core/common/action.c **** #else
 133:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:./tmk_core/common/action.c **** {
 135:./tmk_core/common/action.c ****     process_record(record);
 136:./tmk_core/common/action.c **** }
 137:./tmk_core/common/action.c **** #endif
 138:./tmk_core/common/action.c **** 
 139:./tmk_core/common/action.c **** __attribute__ ((weak))
 140:./tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  97               		.loc 1 140 50 is_stmt 1 view -0
  98               		.cfi_startproc
  99               	/* prologue: function */
 100               	/* frame size = 0 */
 101               	/* stack size = 0 */
 102               	.L__stack_usage = 0
 141:./tmk_core/common/action.c ****     return true;
 103               		.loc 1 141 5 view .LVU11
 142:./tmk_core/common/action.c **** }
 104               		.loc 1 142 1 is_stmt 0 view .LVU12
 105 0000 81E0      		ldi r24,lo8(1)
 106               	.LVL5:
 107               	/* epilogue start */
 108               		.loc 1 142 1 view .LVU13
 109 0002 0895      		ret
 110               		.cfi_endproc
 111               	.LFE15:
 113               		.section	.text.process_record_tap_hint,"ax",@progbits
 114               	.global	process_record_tap_hint
 116               	process_record_tap_hint:
 117               	.LVL6:
 118               	.LFB16:
 143:./tmk_core/common/action.c **** 
 144:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:./tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:./tmk_core/common/action.c ****  *
 147:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:./tmk_core/common/action.c ****  */
 149:./tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:./tmk_core/common/action.c **** {
 119               		.loc 1 150 1 is_stmt 1 view -0
 120               		.cfi_startproc
 121               	/* prologue: function */
 122               	/* frame size = 0 */
 123               	/* stack size = 0 */
 124               	.L__stack_usage = 0
 151:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 125               		.loc 1 151 5 view .LVU15
 126               		.loc 1 151 23 is_stmt 0 view .LVU16
 127 0000 FC01      		movw r30,r24
 128 0002 8081      		ld r24,Z
 129 0004 9181      		ldd r25,Z+1
 130               	.LVL7:
 131               		.loc 1 151 23 view .LVU17
 132 0006 0C94 0000 		jmp layer_switch_get_action
 133               	.LVL8:
 134               		.loc 1 151 23 view .LVU18
 135               		.cfi_endproc
 136               	.LFE16:
 138               		.section	.text.register_code,"ax",@progbits
 139               	.global	register_code
 141               	register_code:
 142               	.LVL9:
 143               	.LFB19:
 152:./tmk_core/common/action.c **** 
 153:./tmk_core/common/action.c ****     switch (action.kind.id) {
 154:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:./tmk_core/common/action.c ****             switch (action.swap.code) {
 157:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:./tmk_core/common/action.c ****                 default:
 159:./tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:./tmk_core/common/action.c ****                     swap_held = true;
 161:./tmk_core/common/action.c ****             }
 162:./tmk_core/common/action.c ****             break;
 163:./tmk_core/common/action.c **** #endif
 164:./tmk_core/common/action.c ****     }
 165:./tmk_core/common/action.c **** }
 166:./tmk_core/common/action.c **** #endif
 167:./tmk_core/common/action.c **** 
 168:./tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:./tmk_core/common/action.c ****  *
 170:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:./tmk_core/common/action.c ****  */
 172:./tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:./tmk_core/common/action.c **** {
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:./tmk_core/common/action.c **** 
 176:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:./tmk_core/common/action.c ****         return;
 178:./tmk_core/common/action.c **** 
 179:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:./tmk_core/common/action.c **** #endif
 185:./tmk_core/common/action.c ****     dprintln();
 186:./tmk_core/common/action.c **** 
 187:./tmk_core/common/action.c ****     process_action(record, action);
 188:./tmk_core/common/action.c **** }
 189:./tmk_core/common/action.c **** 
 190:./tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:./tmk_core/common/action.c ****  *
 192:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:./tmk_core/common/action.c ****  */
 194:./tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:./tmk_core/common/action.c **** {
 196:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:./tmk_core/common/action.c **** #endif
 200:./tmk_core/common/action.c **** 
 201:./tmk_core/common/action.c ****     if (event.pressed) {
 202:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:./tmk_core/common/action.c ****         clear_weak_mods();
 204:./tmk_core/common/action.c ****     }
 205:./tmk_core/common/action.c **** 
 206:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:./tmk_core/common/action.c ****     }
 213:./tmk_core/common/action.c **** #endif
 214:./tmk_core/common/action.c **** 
 215:./tmk_core/common/action.c ****     switch (action.kind.id) {
 216:./tmk_core/common/action.c ****         /* Key and Mods */
 217:./tmk_core/common/action.c ****         case ACT_LMODS:
 218:./tmk_core/common/action.c ****         case ACT_RMODS:
 219:./tmk_core/common/action.c ****             {
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:./tmk_core/common/action.c ****                 if (event.pressed) {
 223:./tmk_core/common/action.c ****                     if (mods) {
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:./tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:./tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:./tmk_core/common/action.c ****                             add_mods(mods);
 229:./tmk_core/common/action.c ****                         } else {
 230:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:./tmk_core/common/action.c ****                         }
 232:./tmk_core/common/action.c ****                         send_keyboard_report();
 233:./tmk_core/common/action.c ****                     }
 234:./tmk_core/common/action.c ****                     register_code(action.key.code);
 235:./tmk_core/common/action.c ****                 } else {
 236:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:./tmk_core/common/action.c ****                     if (mods) {
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:./tmk_core/common/action.c ****                             del_mods(mods);
 240:./tmk_core/common/action.c ****                         } else {
 241:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:./tmk_core/common/action.c ****                         }
 243:./tmk_core/common/action.c ****                         send_keyboard_report();
 244:./tmk_core/common/action.c ****                     }
 245:./tmk_core/common/action.c ****                 }
 246:./tmk_core/common/action.c ****             }
 247:./tmk_core/common/action.c ****             break;
 248:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:./tmk_core/common/action.c ****             {
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:./tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:./tmk_core/common/action.c ****                         // Oneshot modifier
 258:./tmk_core/common/action.c ****                         if (event.pressed) {
 259:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 262:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 265:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:./tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:./tmk_core/common/action.c ****                                 register_mods(mods);
 271:./tmk_core/common/action.c ****                     #endif
 272:./tmk_core/common/action.c ****                             } else {
 273:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 274:./tmk_core/common/action.c ****                             }
 275:./tmk_core/common/action.c ****                         } else {
 276:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:./tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:./tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:./tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:./tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:./tmk_core/common/action.c ****                                 }
 287:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:./tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:./tmk_core/common/action.c ****                     #endif
 290:./tmk_core/common/action.c ****                             } else {
 291:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:./tmk_core/common/action.c ****                             }
 294:./tmk_core/common/action.c ****                         }
 295:./tmk_core/common/action.c ****                         break;
 296:./tmk_core/common/action.c ****     #endif
 297:./tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:./tmk_core/common/action.c ****                         if (event.pressed) {
 299:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:./tmk_core/common/action.c ****                                 register_mods(mods);
 301:./tmk_core/common/action.c ****                             }
 302:./tmk_core/common/action.c ****                         } else {
 303:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:./tmk_core/common/action.c ****                             }
 306:./tmk_core/common/action.c ****                         }
 307:./tmk_core/common/action.c ****                         break;
 308:./tmk_core/common/action.c ****                     default:
 309:./tmk_core/common/action.c ****                         if (event.pressed) {
 310:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:./tmk_core/common/action.c ****                                     register_mods(mods);
 317:./tmk_core/common/action.c ****                                 } else
 318:./tmk_core/common/action.c **** #endif
 319:./tmk_core/common/action.c ****                                 {
 320:./tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:./tmk_core/common/action.c ****                                 }
 323:./tmk_core/common/action.c ****                             } else {
 324:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:./tmk_core/common/action.c ****                                 register_mods(mods);
 326:./tmk_core/common/action.c ****                             }
 327:./tmk_core/common/action.c ****                         } else {
 328:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:./tmk_core/common/action.c ****                             } else {
 332:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:./tmk_core/common/action.c ****                             }
 335:./tmk_core/common/action.c ****                         }
 336:./tmk_core/common/action.c ****                         break;
 337:./tmk_core/common/action.c ****                 }
 338:./tmk_core/common/action.c ****             }
 339:./tmk_core/common/action.c ****             break;
 340:./tmk_core/common/action.c **** #endif
 341:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:./tmk_core/common/action.c ****         /* other HID usage */
 343:./tmk_core/common/action.c ****         case ACT_USAGE:
 344:./tmk_core/common/action.c ****             switch (action.usage.page) {
 345:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:./tmk_core/common/action.c ****                     if (event.pressed) {
 347:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:./tmk_core/common/action.c ****                     } else {
 349:./tmk_core/common/action.c ****                         host_system_send(0);
 350:./tmk_core/common/action.c ****                     }
 351:./tmk_core/common/action.c ****                     break;
 352:./tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:./tmk_core/common/action.c ****                     if (event.pressed) {
 354:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:./tmk_core/common/action.c ****                     } else {
 356:./tmk_core/common/action.c ****                         host_consumer_send(0);
 357:./tmk_core/common/action.c ****                     }
 358:./tmk_core/common/action.c ****                     break;
 359:./tmk_core/common/action.c ****             }
 360:./tmk_core/common/action.c ****             break;
 361:./tmk_core/common/action.c **** #endif
 362:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:./tmk_core/common/action.c ****         /* Mouse key */
 364:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:./tmk_core/common/action.c ****             if (event.pressed) {
 366:./tmk_core/common/action.c ****                 switch (action.key.code) {
 367:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:./tmk_core/common/action.c ****                         break;
 370:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:./tmk_core/common/action.c ****                         break;
 373:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:./tmk_core/common/action.c ****                         break;
 376:./tmk_core/common/action.c ****                     default:
 377:./tmk_core/common/action.c ****                         break;
 378:./tmk_core/common/action.c ****                 }
 379:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:./tmk_core/common/action.c ****                 mousekey_send();
 381:./tmk_core/common/action.c ****             } else {
 382:./tmk_core/common/action.c ****                 switch (action.key.code) {
 383:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:./tmk_core/common/action.c ****                         break;
 386:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:./tmk_core/common/action.c ****                         break;
 389:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:./tmk_core/common/action.c ****                         break;
 392:./tmk_core/common/action.c ****                     default:
 393:./tmk_core/common/action.c ****                         break;
 394:./tmk_core/common/action.c ****                 }
 395:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:./tmk_core/common/action.c ****                 mousekey_send();
 397:./tmk_core/common/action.c ****             }
 398:./tmk_core/common/action.c ****             break;
 399:./tmk_core/common/action.c **** #endif
 400:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:./tmk_core/common/action.c ****         case ACT_LAYER:
 402:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:./tmk_core/common/action.c ****                 if (!event.pressed) {
 405:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:./tmk_core/common/action.c ****                     }
 414:./tmk_core/common/action.c ****                 }
 415:./tmk_core/common/action.c ****             } else {
 416:./tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:./tmk_core/common/action.c ****                     }
 428:./tmk_core/common/action.c ****                 }
 429:./tmk_core/common/action.c ****             }
 430:./tmk_core/common/action.c ****             break;
 431:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:./tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:./tmk_core/common/action.c ****                     if (event.pressed) {
 438:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:./tmk_core/common/action.c ****                     } else {
 441:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:./tmk_core/common/action.c ****                     }
 444:./tmk_core/common/action.c ****                     break;
 445:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:./tmk_core/common/action.c ****                     /* tap toggle */
 447:./tmk_core/common/action.c ****                     if (event.pressed) {
 448:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:./tmk_core/common/action.c ****                         }
 451:./tmk_core/common/action.c ****                     } else {
 452:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:./tmk_core/common/action.c ****                         }
 455:./tmk_core/common/action.c ****                     }
 456:./tmk_core/common/action.c ****                     break;
 457:./tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:./tmk_core/common/action.c ****                     break;
 461:./tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:./tmk_core/common/action.c ****                     break;
 465:./tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:./tmk_core/common/action.c ****                                     layer_clear();
 468:./tmk_core/common/action.c ****                     break;
 469:./tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:./tmk_core/common/action.c ****                     // Oneshot modifier
 472:./tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:./tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:./tmk_core/common/action.c ****                     if (event.pressed) {
 475:./tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:./tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:./tmk_core/common/action.c ****                             break;
 480:./tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:./tmk_core/common/action.c ****                         }
 484:./tmk_core/common/action.c ****                     } else {
 485:./tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:./tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:./tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:./tmk_core/common/action.c ****                         } else {
 491:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:./tmk_core/common/action.c ****                         }
 493:./tmk_core/common/action.c ****                     }
 494:./tmk_core/common/action.c ****                 #else
 495:./tmk_core/common/action.c ****                     if (event.pressed) {
 496:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:./tmk_core/common/action.c ****                     } else {
 499:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:./tmk_core/common/action.c ****                         }
 503:./tmk_core/common/action.c ****                     }
 504:./tmk_core/common/action.c ****                 #endif
 505:./tmk_core/common/action.c ****                     break;
 506:./tmk_core/common/action.c ****             #endif
 507:./tmk_core/common/action.c ****                 default:
 508:./tmk_core/common/action.c ****                     /* tap key */
 509:./tmk_core/common/action.c ****                     if (event.pressed) {
 510:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:./tmk_core/common/action.c ****                         } else {
 514:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:./tmk_core/common/action.c ****                         }
 517:./tmk_core/common/action.c ****                     } else {
 518:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:./tmk_core/common/action.c ****                                 wait_ms(80);
 522:./tmk_core/common/action.c ****                             }
 523:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:./tmk_core/common/action.c ****                         } else {
 525:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:./tmk_core/common/action.c ****                         }
 528:./tmk_core/common/action.c ****                     }
 529:./tmk_core/common/action.c ****                     break;
 530:./tmk_core/common/action.c ****             }
 531:./tmk_core/common/action.c ****             break;
 532:./tmk_core/common/action.c ****     #endif
 533:./tmk_core/common/action.c **** #endif
 534:./tmk_core/common/action.c ****         /* Extentions */
 535:./tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:./tmk_core/common/action.c ****         case ACT_MACRO:
 537:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:./tmk_core/common/action.c ****             break;
 539:./tmk_core/common/action.c **** #endif
 540:./tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 541:./tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:./tmk_core/common/action.c ****             if (!event.pressed) {
 543:./tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:./tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:./tmk_core/common/action.c ****                         backlight_increase();
 546:./tmk_core/common/action.c ****                         break;
 547:./tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:./tmk_core/common/action.c ****                         backlight_decrease();
 549:./tmk_core/common/action.c ****                         break;
 550:./tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:./tmk_core/common/action.c ****                         backlight_toggle();
 552:./tmk_core/common/action.c ****                         break;
 553:./tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:./tmk_core/common/action.c ****                         backlight_step();
 555:./tmk_core/common/action.c ****                         break;
 556:./tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:./tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:./tmk_core/common/action.c ****                         break;
 559:./tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:./tmk_core/common/action.c ****                         backlight_level(0);
 561:./tmk_core/common/action.c ****                         break;
 562:./tmk_core/common/action.c ****                 }
 563:./tmk_core/common/action.c ****             }
 564:./tmk_core/common/action.c ****             break;
 565:./tmk_core/common/action.c **** #endif
 566:./tmk_core/common/action.c ****         case ACT_COMMAND:
 567:./tmk_core/common/action.c ****             break;
 568:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:./tmk_core/common/action.c ****             switch (action.swap.code) {
 571:./tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:./tmk_core/common/action.c ****                     if (event.pressed) {
 573:./tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:./tmk_core/common/action.c ****                     }
 575:./tmk_core/common/action.c ****                     break;
 576:./tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:./tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:./tmk_core/common/action.c ****                     break;
 579:./tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:./tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:./tmk_core/common/action.c ****                     break;
 582:./tmk_core/common/action.c ****                 case OP_SH_ON:
 583:./tmk_core/common/action.c ****                     if (!event.pressed) {
 584:./tmk_core/common/action.c ****                         swap_hands = true;
 585:./tmk_core/common/action.c ****                     }
 586:./tmk_core/common/action.c ****                     break;
 587:./tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:./tmk_core/common/action.c ****                     if (!event.pressed) {
 589:./tmk_core/common/action.c ****                         swap_hands = false;
 590:./tmk_core/common/action.c ****                     }
 591:./tmk_core/common/action.c ****                     break;
 592:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:./tmk_core/common/action.c ****                     /* tap toggle */
 595:./tmk_core/common/action.c **** 
 596:./tmk_core/common/action.c ****                     if (event.pressed) {
 597:./tmk_core/common/action.c ****                         if (swap_held) {
 598:./tmk_core/common/action.c ****                             swap_held = false;
 599:./tmk_core/common/action.c ****                         } else {
 600:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:./tmk_core/common/action.c ****                         }
 602:./tmk_core/common/action.c ****                     } else {
 603:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:./tmk_core/common/action.c ****                         }
 606:./tmk_core/common/action.c ****                     }
 607:./tmk_core/common/action.c ****                     break;
 608:./tmk_core/common/action.c ****                 default:
 609:./tmk_core/common/action.c ****                     /* tap key */
 610:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:./tmk_core/common/action.c ****                         if (swap_held) {
 612:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:./tmk_core/common/action.c ****                             swap_held = false;
 614:./tmk_core/common/action.c ****                         }
 615:./tmk_core/common/action.c ****                         if (event.pressed) {
 616:./tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:./tmk_core/common/action.c ****                         } else {
 618:./tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:./tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:./tmk_core/common/action.c ****                         }
 621:./tmk_core/common/action.c ****                     } else {
 622:./tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:./tmk_core/common/action.c ****                             swap_held = false;
 625:./tmk_core/common/action.c ****                         }
 626:./tmk_core/common/action.c ****                     }
 627:./tmk_core/common/action.c ****     #endif
 628:./tmk_core/common/action.c ****             }
 629:./tmk_core/common/action.c **** #endif
 630:./tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:./tmk_core/common/action.c ****             break;
 634:./tmk_core/common/action.c **** #endif
 635:./tmk_core/common/action.c ****         default:
 636:./tmk_core/common/action.c ****             break;
 637:./tmk_core/common/action.c ****     }
 638:./tmk_core/common/action.c **** 
 639:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:./tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:./tmk_core/common/action.c ****     switch (action.kind.id) {
 642:./tmk_core/common/action.c ****         case ACT_LAYER:
 643:./tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:./tmk_core/common/action.c ****         #endif
 647:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:./tmk_core/common/action.c ****             break;
 649:./tmk_core/common/action.c ****         default:
 650:./tmk_core/common/action.c ****             break;
 651:./tmk_core/common/action.c ****     }
 652:./tmk_core/common/action.c **** #endif
 653:./tmk_core/common/action.c **** 
 654:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:./tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:./tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 657:./tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:./tmk_core/common/action.c ****   } else {
 659:./tmk_core/common/action.c ****     if (event.pressed) {
 660:./tmk_core/common/action.c ****         if (tap_count > 0) {
 661:./tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:./tmk_core/common/action.c ****         } else {
 663:./tmk_core/common/action.c **** 
 664:./tmk_core/common/action.c ****         }
 665:./tmk_core/common/action.c ****     } else {
 666:./tmk_core/common/action.c ****       if (tap_count > 0) {
 667:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:./tmk_core/common/action.c ****       } else {
 669:./tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:./tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:./tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:./tmk_core/common/action.c ****         }
 673:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:./tmk_core/common/action.c ****       }
 675:./tmk_core/common/action.c ****     }
 676:./tmk_core/common/action.c ****   }
 677:./tmk_core/common/action.c ****   #endif
 678:./tmk_core/common/action.c **** #endif
 679:./tmk_core/common/action.c **** 
 680:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:./tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:./tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:./tmk_core/common/action.c ****      */
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:./tmk_core/common/action.c ****         record->event.pressed = false;
 686:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:./tmk_core/common/action.c ****         process_record(record);
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:./tmk_core/common/action.c ****     }
 690:./tmk_core/common/action.c **** #endif
 691:./tmk_core/common/action.c **** }
 692:./tmk_core/common/action.c **** 
 693:./tmk_core/common/action.c **** 
 694:./tmk_core/common/action.c **** 
 695:./tmk_core/common/action.c **** 
 696:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:./tmk_core/common/action.c ****  *
 698:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:./tmk_core/common/action.c ****  */
 700:./tmk_core/common/action.c **** void register_code(uint8_t code)
 701:./tmk_core/common/action.c **** {
 144               		.loc 1 701 1 is_stmt 1 view -0
 145               		.cfi_startproc
 146               		.loc 1 701 1 is_stmt 0 view .LVU20
 147 0000 CF93      		push r28
 148               	.LCFI4:
 149               		.cfi_def_cfa_offset 3
 150               		.cfi_offset 28, -2
 151               	/* prologue: function */
 152               	/* frame size = 0 */
 153               	/* stack size = 1 */
 154               	.L__stack_usage = 1
 155 0002 C82F      		mov r28,r24
 702:./tmk_core/common/action.c ****     if (code == KC_NO) {
 156               		.loc 1 702 5 is_stmt 1 view .LVU21
 157               		.loc 1 702 8 is_stmt 0 view .LVU22
 158 0004 8823      		tst r24
 159 0006 01F4      		brne .+2
 160 0008 00C0      		rjmp .L4
 703:./tmk_core/common/action.c ****         return;
 704:./tmk_core/common/action.c ****     }
 705:./tmk_core/common/action.c **** 
 706:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 161               		.loc 1 707 10 is_stmt 1 view .LVU23
 162               		.loc 1 707 13 is_stmt 0 view .LVU24
 163 000a 8238      		cpi r24,lo8(-126)
 164 000c 01F4      		brne .L7
 708:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 165               		.loc 1 710 9 is_stmt 1 view .LVU25
 166               		.loc 1 710 13 is_stmt 0 view .LVU26
 167 000e 0E94 0000 		call host_keyboard_leds
 168               	.LVL10:
 169               		.loc 1 710 12 view .LVU27
 170 0012 81FD      		sbrc r24,1
 171 0014 00C0      		rjmp .L4
 711:./tmk_core/common/action.c **** #endif
 712:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 172               		.loc 1 712 9 is_stmt 1 view .LVU28
 173 0016 89E3      		ldi r24,lo8(57)
 174 0018 0E94 0000 		call add_key
 175               	.LVL11:
 713:./tmk_core/common/action.c ****         send_keyboard_report();
 176               		.loc 1 713 9 view .LVU29
 177 001c 0E94 0000 		call send_keyboard_report
 178               	.LVL12:
 714:./tmk_core/common/action.c ****         wait_ms(100);
 179               		.loc 1 714 9 view .LVU30
 180               	.LBB14:
 181               	.LBI14:
 182               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** _delay_ms(double __ms)
 183               		.loc 2 166 1 view .LVU31
 184               	.LBB15:
 167:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	double __tmp ;
 185               		.loc 2 168 2 view .LVU32
 169:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 186               		.loc 2 172 2 view .LVU33
 173:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 187               		.loc 2 173 2 view .LVU34
 174:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 188               		.loc 2 174 2 view .LVU35
 175:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 189               		.loc 2 184 3 view .LVU36
 185:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 190               		.loc 2 187 2 view .LVU37
 191 0020 2FEF      		ldi r18,lo8(319999)
 192 0022 81EE      		ldi r24,hi8(319999)
 193 0024 94E0      		ldi r25,hlo8(319999)
 194 0026 2150      	1:	subi r18,1
 195 0028 8040      		sbci r24,0
 196 002a 9040      		sbci r25,0
 197 002c 01F4      		brne 1b
 198 002e 00C0      		rjmp .
 199 0030 0000      		nop
 200               	.LVL13:
 201               		.loc 2 187 2 is_stmt 0 view .LVU38
 202               	.LBE15:
 203               	.LBE14:
 715:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 204               		.loc 1 715 9 is_stmt 1 view .LVU39
 205 0032 89E3      		ldi r24,lo8(57)
 206               	.L39:
 716:./tmk_core/common/action.c ****         send_keyboard_report();
 717:./tmk_core/common/action.c ****     }
 718:./tmk_core/common/action.c **** 
 719:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 720:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 722:./tmk_core/common/action.c **** #endif
 723:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:./tmk_core/common/action.c ****         send_keyboard_report();
 725:./tmk_core/common/action.c ****         wait_ms(100);
 726:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 207               		.loc 1 726 9 is_stmt 0 view .LVU40
 208 0034 0E94 0000 		call del_key
 209               	.LVL14:
 210               	.L40:
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 211               		.loc 1 727 9 is_stmt 1 view .LVU41
 212               	/* epilogue start */
 728:./tmk_core/common/action.c ****     }
 729:./tmk_core/common/action.c **** 
 730:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 731:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 733:./tmk_core/common/action.c **** #endif
 734:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:./tmk_core/common/action.c ****         send_keyboard_report();
 736:./tmk_core/common/action.c ****         wait_ms(100);
 737:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:./tmk_core/common/action.c ****         send_keyboard_report();
 739:./tmk_core/common/action.c ****     }
 740:./tmk_core/common/action.c **** #endif
 741:./tmk_core/common/action.c **** 
 742:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 743:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:./tmk_core/common/action.c **** 
 746:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:./tmk_core/common/action.c **** /* TODO: remove
 748:./tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:./tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:./tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:./tmk_core/common/action.c **** 
 752:./tmk_core/common/action.c ****             add_key(code);
 753:./tmk_core/common/action.c ****             send_keyboard_report();
 754:./tmk_core/common/action.c **** 
 755:./tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:./tmk_core/common/action.c ****             send_keyboard_report();
 757:./tmk_core/common/action.c ****             oneshot_cancel();
 758:./tmk_core/common/action.c ****         } else
 759:./tmk_core/common/action.c **** */
 760:./tmk_core/common/action.c **** #endif
 761:./tmk_core/common/action.c ****         {
 762:./tmk_core/common/action.c ****             add_key(code);
 763:./tmk_core/common/action.c ****             send_keyboard_report();
 764:./tmk_core/common/action.c ****         }
 765:./tmk_core/common/action.c ****     }
 766:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 767:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 768:./tmk_core/common/action.c ****         send_keyboard_report();
 769:./tmk_core/common/action.c ****     }
 770:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 772:./tmk_core/common/action.c ****     }
 773:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 775:./tmk_core/common/action.c ****     }
 776:./tmk_core/common/action.c **** }
 213               		.loc 1 776 1 is_stmt 0 view .LVU42
 214 0038 CF91      		pop r28
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 215               		.loc 1 727 9 view .LVU43
 216 003a 0C94 0000 		jmp send_keyboard_report
 217               	.LVL15:
 218               	.L7:
 719:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 219               		.loc 1 719 10 is_stmt 1 view .LVU44
 719:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 220               		.loc 1 719 13 is_stmt 0 view .LVU45
 221 003e 8338      		cpi r24,lo8(-125)
 222 0040 01F4      		brne .L9
 721:./tmk_core/common/action.c **** #endif
 223               		.loc 1 721 9 is_stmt 1 view .LVU46
 721:./tmk_core/common/action.c **** #endif
 224               		.loc 1 721 13 is_stmt 0 view .LVU47
 225 0042 0E94 0000 		call host_keyboard_leds
 226               	.LVL16:
 721:./tmk_core/common/action.c **** #endif
 227               		.loc 1 721 12 view .LVU48
 228 0046 80FD      		sbrc r24,0
 229 0048 00C0      		rjmp .L4
 723:./tmk_core/common/action.c ****         send_keyboard_report();
 230               		.loc 1 723 9 is_stmt 1 view .LVU49
 231 004a 83E5      		ldi r24,lo8(83)
 232 004c 0E94 0000 		call add_key
 233               	.LVL17:
 724:./tmk_core/common/action.c ****         wait_ms(100);
 234               		.loc 1 724 9 view .LVU50
 235 0050 0E94 0000 		call send_keyboard_report
 236               	.LVL18:
 725:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 237               		.loc 1 725 9 view .LVU51
 238               	.LBB16:
 239               	.LBI16:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 240               		.loc 2 166 1 view .LVU52
 241               	.LBB17:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 242               		.loc 2 168 2 view .LVU53
 172:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 243               		.loc 2 172 2 view .LVU54
 173:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 244               		.loc 2 173 2 view .LVU55
 174:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 245               		.loc 2 174 2 view .LVU56
 184:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 246               		.loc 2 184 3 view .LVU57
 247               		.loc 2 187 2 view .LVU58
 248 0054 2FEF      		ldi r18,lo8(319999)
 249 0056 81EE      		ldi r24,hi8(319999)
 250 0058 94E0      		ldi r25,hlo8(319999)
 251 005a 2150      	1:	subi r18,1
 252 005c 8040      		sbci r24,0
 253 005e 9040      		sbci r25,0
 254 0060 01F4      		brne 1b
 255 0062 00C0      		rjmp .
 256 0064 0000      		nop
 257               	.LVL19:
 258               		.loc 2 187 2 is_stmt 0 view .LVU59
 259               	.LBE17:
 260               	.LBE16:
 726:./tmk_core/common/action.c ****         send_keyboard_report();
 261               		.loc 1 726 9 is_stmt 1 view .LVU60
 262 0066 83E5      		ldi r24,lo8(83)
 263 0068 00C0      		rjmp .L39
 264               	.LVL20:
 265               	.L9:
 730:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 266               		.loc 1 730 10 view .LVU61
 730:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 267               		.loc 1 730 13 is_stmt 0 view .LVU62
 268 006a 8438      		cpi r24,lo8(-124)
 269 006c 01F4      		brne .L10
 732:./tmk_core/common/action.c **** #endif
 270               		.loc 1 732 9 is_stmt 1 view .LVU63
 732:./tmk_core/common/action.c **** #endif
 271               		.loc 1 732 13 is_stmt 0 view .LVU64
 272 006e 0E94 0000 		call host_keyboard_leds
 273               	.LVL21:
 732:./tmk_core/common/action.c **** #endif
 274               		.loc 1 732 12 view .LVU65
 275 0072 82FD      		sbrc r24,2
 276 0074 00C0      		rjmp .L4
 734:./tmk_core/common/action.c ****         send_keyboard_report();
 277               		.loc 1 734 9 is_stmt 1 view .LVU66
 278 0076 87E4      		ldi r24,lo8(71)
 279 0078 0E94 0000 		call add_key
 280               	.LVL22:
 735:./tmk_core/common/action.c ****         wait_ms(100);
 281               		.loc 1 735 9 view .LVU67
 282 007c 0E94 0000 		call send_keyboard_report
 283               	.LVL23:
 736:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 284               		.loc 1 736 9 view .LVU68
 285               	.LBB18:
 286               	.LBI18:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 287               		.loc 2 166 1 view .LVU69
 288               	.LBB19:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 289               		.loc 2 168 2 view .LVU70
 172:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 290               		.loc 2 172 2 view .LVU71
 173:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 291               		.loc 2 173 2 view .LVU72
 174:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 292               		.loc 2 174 2 view .LVU73
 184:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 293               		.loc 2 184 3 view .LVU74
 294               		.loc 2 187 2 view .LVU75
 295 0080 2FEF      		ldi r18,lo8(319999)
 296 0082 81EE      		ldi r24,hi8(319999)
 297 0084 94E0      		ldi r25,hlo8(319999)
 298 0086 2150      	1:	subi r18,1
 299 0088 8040      		sbci r24,0
 300 008a 9040      		sbci r25,0
 301 008c 01F4      		brne 1b
 302 008e 00C0      		rjmp .
 303 0090 0000      		nop
 304               	.LVL24:
 305               		.loc 2 187 2 is_stmt 0 view .LVU76
 306               	.LBE19:
 307               	.LBE18:
 737:./tmk_core/common/action.c ****         send_keyboard_report();
 308               		.loc 1 737 9 is_stmt 1 view .LVU77
 309 0092 87E4      		ldi r24,lo8(71)
 310 0094 00C0      		rjmp .L39
 311               	.LVL25:
 312               	.L10:
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 313               		.loc 1 742 10 view .LVU78
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 314               		.loc 1 742 13 is_stmt 0 view .LVU79
 315 0096 8CEF      		ldi r24,lo8(-4)
 316               	.LVL26:
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 317               		.loc 1 742 13 view .LVU80
 318 0098 8C0F      		add r24,r28
 319 009a 813A      		cpi r24,lo8(-95)
 320 009c 00F4      		brsh .L11
 744:./tmk_core/common/action.c **** 
 321               		.loc 1 744 9 is_stmt 1 view .LVU81
 744:./tmk_core/common/action.c **** 
 322               		.loc 1 744 13 is_stmt 0 view .LVU82
 323 009e 8C2F      		mov r24,r28
 324 00a0 0E94 0000 		call command_proc
 325               	.LVL27:
 744:./tmk_core/common/action.c **** 
 326               		.loc 1 744 12 view .LVU83
 327 00a4 8111      		cpse r24,__zero_reg__
 328 00a6 00C0      		rjmp .L4
 762:./tmk_core/common/action.c ****             send_keyboard_report();
 329               		.loc 1 762 13 is_stmt 1 view .LVU84
 330 00a8 8C2F      		mov r24,r28
 331 00aa 0E94 0000 		call add_key
 332               	.LVL28:
 763:./tmk_core/common/action.c ****         }
 333               		.loc 1 763 13 view .LVU85
 334 00ae 00C0      		rjmp .L40
 335               	.L11:
 766:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 336               		.loc 1 766 10 view .LVU86
 766:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 337               		.loc 1 766 13 is_stmt 0 view .LVU87
 338 00b0 80E2      		ldi r24,lo8(32)
 339 00b2 8C0F      		add r24,r28
 340 00b4 8830      		cpi r24,lo8(8)
 341 00b6 00F4      		brsh .L12
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 342               		.loc 1 767 9 is_stmt 1 view .LVU88
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 343               		.loc 1 767 18 is_stmt 0 view .LVU89
 344 00b8 C770      		andi r28,lo8(7)
 345               	.LVL29:
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 346               		.loc 1 767 9 view .LVU90
 347 00ba 81E0      		ldi r24,lo8(1)
 348 00bc 00C0      		rjmp 2f
 349               		1:
 350 00be 880F      		lsl r24
 351               		2:
 352 00c0 CA95      		dec r28
 353 00c2 02F4      		brpl 1b
 354 00c4 0E94 0000 		call add_mods
 355               	.LVL30:
 768:./tmk_core/common/action.c ****     }
 356               		.loc 1 768 9 is_stmt 1 view .LVU91
 357 00c8 00C0      		rjmp .L40
 358               	.LVL31:
 359               	.L12:
 770:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 360               		.loc 1 770 10 view .LVU92
 770:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 361               		.loc 1 770 13 is_stmt 0 view .LVU93
 362 00ca 8BE5      		ldi r24,lo8(91)
 363 00cc 8C0F      		add r24,r28
 364 00ce 8330      		cpi r24,lo8(3)
 365 00d0 00F4      		brsh .L13
 771:./tmk_core/common/action.c ****     }
 366               		.loc 1 771 9 is_stmt 1 view .LVU94
 367 00d2 81E8      		ldi r24,lo8(-127)
 368 00d4 90E0      		ldi r25,0
 369 00d6 C53A      		cpi r28,lo8(-91)
 370 00d8 01F0      		breq .L14
 771:./tmk_core/common/action.c ****     }
 371               		.loc 1 771 26 is_stmt 0 discriminator 1 view .LVU95
 372 00da 83E8      		ldi r24,lo8(-125)
 373 00dc 90E0      		ldi r25,0
 374 00de C63A      		cpi r28,lo8(-90)
 375 00e0 01F4      		brne .L14
 771:./tmk_core/common/action.c ****     }
 376               		.loc 1 771 26 view .LVU96
 377 00e2 82E8      		ldi r24,lo8(-126)
 378 00e4 90E0      		ldi r25,0
 379               	.L14:
 380               	/* epilogue start */
 381               		.loc 1 776 1 discriminator 12 view .LVU97
 382 00e6 CF91      		pop r28
 383               	.LVL32:
 771:./tmk_core/common/action.c ****     }
 384               		.loc 1 771 9 discriminator 12 view .LVU98
 385 00e8 0C94 0000 		jmp host_system_send
 386               	.LVL33:
 387               	.L13:
 773:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 388               		.loc 1 773 10 is_stmt 1 view .LVU99
 773:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 389               		.loc 1 773 13 is_stmt 0 view .LVU100
 390 00ec 88E5      		ldi r24,lo8(88)
 391 00ee 8C0F      		add r24,r28
 392 00f0 8531      		cpi r24,lo8(21)
 393 00f2 00F0      		brlo .+2
 394 00f4 00C0      		rjmp .L4
 774:./tmk_core/common/action.c ****     }
 395               		.loc 1 774 9 is_stmt 1 view .LVU101
 396 00f6 82EE      		ldi r24,lo8(-30)
 397 00f8 90E0      		ldi r25,0
 398 00fa C83A      		cpi r28,lo8(-88)
 399 00fc 01F4      		brne .+2
 400 00fe 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 401               		.loc 1 774 28 is_stmt 0 discriminator 1 view .LVU102
 402 0100 89EE      		ldi r24,lo8(-23)
 403 0102 90E0      		ldi r25,0
 404 0104 C93A      		cpi r28,lo8(-87)
 405 0106 01F4      		brne .+2
 406 0108 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 407               		.loc 1 774 28 discriminator 3 view .LVU103
 408 010a 8AEE      		ldi r24,lo8(-22)
 409 010c 90E0      		ldi r25,0
 410 010e CA3A      		cpi r28,lo8(-86)
 411 0110 01F4      		brne .+2
 412 0112 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 413               		.loc 1 774 28 discriminator 5 view .LVU104
 414 0114 85EB      		ldi r24,lo8(-75)
 415 0116 90E0      		ldi r25,0
 416 0118 CB3A      		cpi r28,lo8(-85)
 417 011a 01F4      		brne .+2
 418 011c 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 419               		.loc 1 774 28 discriminator 7 view .LVU105
 420 011e 86EB      		ldi r24,lo8(-74)
 421 0120 90E0      		ldi r25,0
 422 0122 CC3A      		cpi r28,lo8(-84)
 423 0124 01F4      		brne .+2
 424 0126 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 425               		.loc 1 774 28 discriminator 9 view .LVU106
 426 0128 83EB      		ldi r24,lo8(-77)
 427 012a 90E0      		ldi r25,0
 428 012c CB3B      		cpi r28,lo8(-69)
 429 012e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 430               		.loc 1 774 28 discriminator 11 view .LVU107
 431 0130 84EB      		ldi r24,lo8(-76)
 432 0132 90E0      		ldi r25,0
 433 0134 CC3B      		cpi r28,lo8(-68)
 434 0136 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 435               		.loc 1 774 28 discriminator 13 view .LVU108
 436 0138 87EB      		ldi r24,lo8(-73)
 437 013a 90E0      		ldi r25,0
 438 013c CD3A      		cpi r28,lo8(-83)
 439 013e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 440               		.loc 1 774 28 discriminator 15 view .LVU109
 441 0140 8CEC      		ldi r24,lo8(-52)
 442 0142 90E0      		ldi r25,0
 443 0144 C03B      		cpi r28,lo8(-80)
 444 0146 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 445               		.loc 1 774 28 discriminator 17 view .LVU110
 446 0148 8DEC      		ldi r24,lo8(-51)
 447 014a 90E0      		ldi r25,0
 448 014c CE3A      		cpi r28,lo8(-82)
 449 014e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 450               		.loc 1 774 28 discriminator 19 view .LVU111
 451 0150 83E8      		ldi r24,lo8(-125)
 452 0152 91E0      		ldi r25,lo8(1)
 453 0154 CF3A      		cpi r28,lo8(-81)
 454 0156 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 455               		.loc 1 774 28 discriminator 21 view .LVU112
 456 0158 8AE8      		ldi r24,lo8(-118)
 457 015a 91E0      		ldi r25,lo8(1)
 458 015c C13B      		cpi r28,lo8(-79)
 459 015e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 460               		.loc 1 774 28 discriminator 23 view .LVU113
 461 0160 82E9      		ldi r24,lo8(-110)
 462 0162 91E0      		ldi r25,lo8(1)
 463 0164 C23B      		cpi r28,lo8(-78)
 464 0166 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 465               		.loc 1 774 28 discriminator 25 view .LVU114
 466 0168 84E9      		ldi r24,lo8(-108)
 467 016a 91E0      		ldi r25,lo8(1)
 468 016c C33B      		cpi r28,lo8(-77)
 469 016e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 470               		.loc 1 774 28 discriminator 27 view .LVU115
 471 0170 81E2      		ldi r24,lo8(33)
 472 0172 92E0      		ldi r25,lo8(2)
 473 0174 C43B      		cpi r28,lo8(-76)
 474 0176 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 475               		.loc 1 774 28 discriminator 29 view .LVU116
 476 0178 83E2      		ldi r24,lo8(35)
 477 017a 92E0      		ldi r25,lo8(2)
 478 017c C53B      		cpi r28,lo8(-75)
 479 017e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 480               		.loc 1 774 28 discriminator 31 view .LVU117
 481 0180 84E2      		ldi r24,lo8(36)
 482 0182 92E0      		ldi r25,lo8(2)
 483 0184 C63B      		cpi r28,lo8(-74)
 484 0186 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 485               		.loc 1 774 28 discriminator 33 view .LVU118
 486 0188 85E2      		ldi r24,lo8(37)
 487 018a 92E0      		ldi r25,lo8(2)
 488 018c C73B      		cpi r28,lo8(-73)
 489 018e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 490               		.loc 1 774 28 discriminator 35 view .LVU119
 491 0190 86E2      		ldi r24,lo8(38)
 492 0192 92E0      		ldi r25,lo8(2)
 493 0194 C83B      		cpi r28,lo8(-72)
 494 0196 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 495               		.loc 1 774 28 discriminator 37 view .LVU120
 496 0198 87E2      		ldi r24,lo8(39)
 497 019a 92E0      		ldi r25,lo8(2)
 498 019c C93B      		cpi r28,lo8(-71)
 499 019e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 500               		.loc 1 774 28 discriminator 39 view .LVU121
 501 01a0 90E0      		ldi r25,0
 502 01a2 80E0      		ldi r24,0
 503 01a4 CA3B      		cpi r28,lo8(-70)
 504 01a6 01F4      		brne .L15
 774:./tmk_core/common/action.c ****     }
 505               		.loc 1 774 28 view .LVU122
 506 01a8 8AE2      		ldi r24,lo8(42)
 507 01aa 92E0      		ldi r25,lo8(2)
 508               	.L15:
 509               	/* epilogue start */
 510               		.loc 1 776 1 discriminator 84 view .LVU123
 511 01ac CF91      		pop r28
 512               	.LVL34:
 774:./tmk_core/common/action.c ****     }
 513               		.loc 1 774 9 discriminator 84 view .LVU124
 514 01ae 0C94 0000 		jmp host_consumer_send
 515               	.LVL35:
 516               	.L4:
 517               	/* epilogue start */
 518               		.loc 1 776 1 view .LVU125
 519 01b2 CF91      		pop r28
 520               	.LVL36:
 521               		.loc 1 776 1 view .LVU126
 522 01b4 0895      		ret
 523               		.cfi_endproc
 524               	.LFE19:
 526               		.section	.text.unregister_code,"ax",@progbits
 527               	.global	unregister_code
 529               	unregister_code:
 530               	.LVL37:
 531               	.LFB20:
 777:./tmk_core/common/action.c **** 
 778:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 779:./tmk_core/common/action.c ****  *
 780:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 781:./tmk_core/common/action.c ****  */
 782:./tmk_core/common/action.c **** void unregister_code(uint8_t code)
 783:./tmk_core/common/action.c **** {
 532               		.loc 1 783 1 is_stmt 1 view -0
 533               		.cfi_startproc
 534               	/* prologue: function */
 535               	/* frame size = 0 */
 536               	/* stack size = 0 */
 537               	.L__stack_usage = 0
 784:./tmk_core/common/action.c ****     if (code == KC_NO) {
 538               		.loc 1 784 5 view .LVU128
 539               		.loc 1 784 8 is_stmt 0 view .LVU129
 540 0000 8823      		tst r24
 541 0002 01F4      		brne .+2
 542 0004 00C0      		rjmp .L41
 785:./tmk_core/common/action.c ****         return;
 786:./tmk_core/common/action.c ****     }
 787:./tmk_core/common/action.c **** 
 788:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 789:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 543               		.loc 1 789 10 is_stmt 1 view .LVU130
 544               		.loc 1 789 13 is_stmt 0 view .LVU131
 545 0006 8238      		cpi r24,lo8(-126)
 546 0008 01F4      		brne .L44
 790:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 791:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 792:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 547               		.loc 1 792 9 is_stmt 1 view .LVU132
 548               		.loc 1 792 15 is_stmt 0 view .LVU133
 549 000a 0E94 0000 		call host_keyboard_leds
 550               	.LVL38:
 551               		.loc 1 792 12 view .LVU134
 552 000e 81FF      		sbrs r24,1
 553 0010 00C0      		rjmp .L41
 793:./tmk_core/common/action.c **** #endif
 794:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 554               		.loc 1 794 9 is_stmt 1 view .LVU135
 555 0012 89E3      		ldi r24,lo8(57)
 556 0014 0E94 0000 		call add_key
 557               	.LVL39:
 795:./tmk_core/common/action.c ****         send_keyboard_report();
 558               		.loc 1 795 9 view .LVU136
 559 0018 0E94 0000 		call send_keyboard_report
 560               	.LVL40:
 796:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 561               		.loc 1 796 9 view .LVU137
 562 001c 89E3      		ldi r24,lo8(57)
 563               	.L60:
 797:./tmk_core/common/action.c ****         send_keyboard_report();
 798:./tmk_core/common/action.c ****     }
 799:./tmk_core/common/action.c **** 
 800:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 801:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 802:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 803:./tmk_core/common/action.c **** #endif
 804:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:./tmk_core/common/action.c ****         send_keyboard_report();
 806:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 564               		.loc 1 806 9 is_stmt 0 view .LVU138
 565 001e 0E94 0000 		call del_key
 566               	.LVL41:
 567               	.L61:
 807:./tmk_core/common/action.c ****         send_keyboard_report();
 568               		.loc 1 807 9 is_stmt 1 view .LVU139
 569 0022 0C94 0000 		jmp send_keyboard_report
 570               	.LVL42:
 571               	.L44:
 800:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 572               		.loc 1 800 10 view .LVU140
 800:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 573               		.loc 1 800 13 is_stmt 0 view .LVU141
 574 0026 8338      		cpi r24,lo8(-125)
 575 0028 01F4      		brne .L46
 802:./tmk_core/common/action.c **** #endif
 576               		.loc 1 802 9 is_stmt 1 view .LVU142
 802:./tmk_core/common/action.c **** #endif
 577               		.loc 1 802 15 is_stmt 0 view .LVU143
 578 002a 0E94 0000 		call host_keyboard_leds
 579               	.LVL43:
 802:./tmk_core/common/action.c **** #endif
 580               		.loc 1 802 12 view .LVU144
 581 002e 80FF      		sbrs r24,0
 582 0030 00C0      		rjmp .L41
 804:./tmk_core/common/action.c ****         send_keyboard_report();
 583               		.loc 1 804 9 is_stmt 1 view .LVU145
 584 0032 83E5      		ldi r24,lo8(83)
 585 0034 0E94 0000 		call add_key
 586               	.LVL44:
 805:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 587               		.loc 1 805 9 view .LVU146
 588 0038 0E94 0000 		call send_keyboard_report
 589               	.LVL45:
 806:./tmk_core/common/action.c ****         send_keyboard_report();
 590               		.loc 1 806 9 view .LVU147
 591 003c 83E5      		ldi r24,lo8(83)
 592 003e 00C0      		rjmp .L60
 593               	.LVL46:
 594               	.L46:
 808:./tmk_core/common/action.c ****     }
 809:./tmk_core/common/action.c **** 
 810:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 595               		.loc 1 810 10 view .LVU148
 596               		.loc 1 810 13 is_stmt 0 view .LVU149
 597 0040 8438      		cpi r24,lo8(-124)
 598 0042 01F4      		brne .L47
 811:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 599               		.loc 1 812 9 is_stmt 1 view .LVU150
 600               		.loc 1 812 15 is_stmt 0 view .LVU151
 601 0044 0E94 0000 		call host_keyboard_leds
 602               	.LVL47:
 603               		.loc 1 812 12 view .LVU152
 604 0048 82FF      		sbrs r24,2
 605 004a 00C0      		rjmp .L41
 813:./tmk_core/common/action.c **** #endif
 814:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 606               		.loc 1 814 9 is_stmt 1 view .LVU153
 607 004c 87E4      		ldi r24,lo8(71)
 608 004e 0E94 0000 		call add_key
 609               	.LVL48:
 815:./tmk_core/common/action.c ****         send_keyboard_report();
 610               		.loc 1 815 9 view .LVU154
 611 0052 0E94 0000 		call send_keyboard_report
 612               	.LVL49:
 816:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 613               		.loc 1 816 9 view .LVU155
 614 0056 87E4      		ldi r24,lo8(71)
 615 0058 00C0      		rjmp .L60
 616               	.LVL50:
 617               	.L47:
 817:./tmk_core/common/action.c ****         send_keyboard_report();
 818:./tmk_core/common/action.c ****     }
 819:./tmk_core/common/action.c **** #endif
 820:./tmk_core/common/action.c **** 
 821:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 618               		.loc 1 821 10 view .LVU156
 619               		.loc 1 821 13 is_stmt 0 view .LVU157
 620 005a 9CEF      		ldi r25,lo8(-4)
 621 005c 980F      		add r25,r24
 622 005e 913A      		cpi r25,lo8(-95)
 623 0060 00F0      		brlo .L60
 822:./tmk_core/common/action.c ****         del_key(code);
 823:./tmk_core/common/action.c ****         send_keyboard_report();
 824:./tmk_core/common/action.c ****     }
 825:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 624               		.loc 1 825 10 is_stmt 1 view .LVU158
 625               		.loc 1 825 13 is_stmt 0 view .LVU159
 626 0062 90E2      		ldi r25,lo8(32)
 627 0064 980F      		add r25,r24
 628 0066 9830      		cpi r25,lo8(8)
 629 0068 00F4      		brsh .L49
 826:./tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 630               		.loc 1 826 9 is_stmt 1 view .LVU160
 631               		.loc 1 826 18 is_stmt 0 view .LVU161
 632 006a 8770      		andi r24,lo8(7)
 633               	.LVL51:
 634               		.loc 1 826 9 view .LVU162
 635 006c 91E0      		ldi r25,lo8(1)
 636 006e 00C0      		rjmp 2f
 637               		1:
 638 0070 990F      		lsl r25
 639               		2:
 640 0072 8A95      		dec r24
 641 0074 02F4      		brpl 1b
 642 0076 892F      		mov r24,r25
 643 0078 0E94 0000 		call del_mods
 644               	.LVL52:
 827:./tmk_core/common/action.c ****         send_keyboard_report();
 645               		.loc 1 827 9 is_stmt 1 view .LVU163
 646 007c 00C0      		rjmp .L61
 647               	.LVL53:
 648               	.L49:
 828:./tmk_core/common/action.c ****     }
 829:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 649               		.loc 1 829 10 view .LVU164
 650               		.loc 1 829 13 is_stmt 0 view .LVU165
 651 007e 9BE5      		ldi r25,lo8(91)
 652 0080 980F      		add r25,r24
 653 0082 9330      		cpi r25,lo8(3)
 654 0084 00F4      		brsh .L50
 830:./tmk_core/common/action.c ****         host_system_send(0);
 655               		.loc 1 830 9 is_stmt 1 view .LVU166
 656 0086 90E0      		ldi r25,0
 657 0088 80E0      		ldi r24,0
 658               	.LVL54:
 659               		.loc 1 830 9 is_stmt 0 view .LVU167
 660 008a 0C94 0000 		jmp host_system_send
 661               	.LVL55:
 662               	.L50:
 831:./tmk_core/common/action.c ****     }
 832:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 663               		.loc 1 832 10 is_stmt 1 view .LVU168
 664               		.loc 1 832 13 is_stmt 0 view .LVU169
 665 008e 885A      		subi r24,lo8(-(88))
 666               	.LVL56:
 667               		.loc 1 832 13 view .LVU170
 668 0090 8531      		cpi r24,lo8(21)
 669 0092 00F4      		brsh .L41
 833:./tmk_core/common/action.c ****         host_consumer_send(0);
 670               		.loc 1 833 9 is_stmt 1 view .LVU171
 671 0094 90E0      		ldi r25,0
 672 0096 80E0      		ldi r24,0
 673               	.LVL57:
 674               		.loc 1 833 9 is_stmt 0 view .LVU172
 675 0098 0C94 0000 		jmp host_consumer_send
 676               	.LVL58:
 677               	.L41:
 678               	/* epilogue start */
 834:./tmk_core/common/action.c ****     }
 835:./tmk_core/common/action.c **** }
 679               		.loc 1 835 1 view .LVU173
 680 009c 0895      		ret
 681               		.cfi_endproc
 682               	.LFE20:
 684               		.section	.text.register_mods,"ax",@progbits
 685               	.global	register_mods
 687               	register_mods:
 688               	.LVL59:
 689               	.LFB21:
 836:./tmk_core/common/action.c **** 
 837:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 838:./tmk_core/common/action.c ****  *
 839:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 840:./tmk_core/common/action.c ****  */
 841:./tmk_core/common/action.c **** void register_mods(uint8_t mods)
 842:./tmk_core/common/action.c **** {
 690               		.loc 1 842 1 is_stmt 1 view -0
 691               		.cfi_startproc
 692               	/* prologue: function */
 693               	/* frame size = 0 */
 694               	/* stack size = 0 */
 695               	.L__stack_usage = 0
 843:./tmk_core/common/action.c ****     if (mods) {
 696               		.loc 1 843 5 view .LVU175
 697               		.loc 1 843 8 is_stmt 0 view .LVU176
 698 0000 8823      		tst r24
 699 0002 01F0      		breq .L62
 844:./tmk_core/common/action.c ****         add_mods(mods);
 700               		.loc 1 844 9 is_stmt 1 view .LVU177
 701 0004 0E94 0000 		call add_mods
 702               	.LVL60:
 845:./tmk_core/common/action.c ****         send_keyboard_report();
 703               		.loc 1 845 9 view .LVU178
 704 0008 0C94 0000 		jmp send_keyboard_report
 705               	.LVL61:
 706               	.L62:
 707               	/* epilogue start */
 846:./tmk_core/common/action.c ****     }
 847:./tmk_core/common/action.c **** }
 708               		.loc 1 847 1 is_stmt 0 view .LVU179
 709 000c 0895      		ret
 710               		.cfi_endproc
 711               	.LFE21:
 713               		.section	.text.unregister_mods,"ax",@progbits
 714               	.global	unregister_mods
 716               	unregister_mods:
 717               	.LVL62:
 718               	.LFB22:
 848:./tmk_core/common/action.c **** 
 849:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 850:./tmk_core/common/action.c ****  *
 851:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 852:./tmk_core/common/action.c ****  */
 853:./tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 854:./tmk_core/common/action.c **** {
 719               		.loc 1 854 1 is_stmt 1 view -0
 720               		.cfi_startproc
 721               	/* prologue: function */
 722               	/* frame size = 0 */
 723               	/* stack size = 0 */
 724               	.L__stack_usage = 0
 855:./tmk_core/common/action.c ****     if (mods) {
 725               		.loc 1 855 5 view .LVU181
 726               		.loc 1 855 8 is_stmt 0 view .LVU182
 727 0000 8823      		tst r24
 728 0002 01F0      		breq .L64
 856:./tmk_core/common/action.c ****         del_mods(mods);
 729               		.loc 1 856 9 is_stmt 1 view .LVU183
 730 0004 0E94 0000 		call del_mods
 731               	.LVL63:
 857:./tmk_core/common/action.c ****         send_keyboard_report();
 732               		.loc 1 857 9 view .LVU184
 733 0008 0C94 0000 		jmp send_keyboard_report
 734               	.LVL64:
 735               	.L64:
 736               	/* epilogue start */
 858:./tmk_core/common/action.c ****     }
 859:./tmk_core/common/action.c **** }
 737               		.loc 1 859 1 is_stmt 0 view .LVU185
 738 000c 0895      		ret
 739               		.cfi_endproc
 740               	.LFE22:
 742               		.section	.text.process_action,"ax",@progbits
 743               	.global	process_action
 745               	process_action:
 746               	.LVL65:
 747               	.LFB18:
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 748               		.loc 1 195 1 is_stmt 1 view -0
 749               		.cfi_startproc
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 750               		.loc 1 195 1 is_stmt 0 view .LVU187
 751 0000 8F92      		push r8
 752               	.LCFI5:
 753               		.cfi_def_cfa_offset 3
 754               		.cfi_offset 8, -2
 755 0002 9F92      		push r9
 756               	.LCFI6:
 757               		.cfi_def_cfa_offset 4
 758               		.cfi_offset 9, -3
 759 0004 AF92      		push r10
 760               	.LCFI7:
 761               		.cfi_def_cfa_offset 5
 762               		.cfi_offset 10, -4
 763 0006 BF92      		push r11
 764               	.LCFI8:
 765               		.cfi_def_cfa_offset 6
 766               		.cfi_offset 11, -5
 767 0008 CF92      		push r12
 768               	.LCFI9:
 769               		.cfi_def_cfa_offset 7
 770               		.cfi_offset 12, -6
 771 000a DF92      		push r13
 772               	.LCFI10:
 773               		.cfi_def_cfa_offset 8
 774               		.cfi_offset 13, -7
 775 000c EF92      		push r14
 776               	.LCFI11:
 777               		.cfi_def_cfa_offset 9
 778               		.cfi_offset 14, -8
 779 000e FF92      		push r15
 780               	.LCFI12:
 781               		.cfi_def_cfa_offset 10
 782               		.cfi_offset 15, -9
 783 0010 0F93      		push r16
 784               	.LCFI13:
 785               		.cfi_def_cfa_offset 11
 786               		.cfi_offset 16, -10
 787 0012 1F93      		push r17
 788               	.LCFI14:
 789               		.cfi_def_cfa_offset 12
 790               		.cfi_offset 17, -11
 791 0014 CF93      		push r28
 792               	.LCFI15:
 793               		.cfi_def_cfa_offset 13
 794               		.cfi_offset 28, -12
 795 0016 DF93      		push r29
 796               	.LCFI16:
 797               		.cfi_def_cfa_offset 14
 798               		.cfi_offset 29, -13
 799               	/* prologue: function */
 800               	/* frame size = 0 */
 801               	/* stack size = 12 */
 802               	.L__stack_usage = 12
 803 0018 7C01      		movw r14,r24
 804 001a D62F      		mov r29,r22
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 805               		.loc 1 195 1 view .LVU188
 806 001c C72F      		mov r28,r23
 196:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 807               		.loc 1 196 5 is_stmt 1 view .LVU189
 808               	.LVL66:
 198:./tmk_core/common/action.c **** #endif
 809               		.loc 1 198 5 view .LVU190
 198:./tmk_core/common/action.c **** #endif
 810               		.loc 1 198 36 is_stmt 0 view .LVU191
 811 001e FC01      		movw r30,r24
 812 0020 0581      		ldd r16,Z+5
 813 0022 0295      		swap r16
 814 0024 0F70      		andi r16,lo8(15)
 815               	.LVL67:
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 816               		.loc 1 201 5 is_stmt 1 view .LVU192
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 817               		.loc 1 201 14 is_stmt 0 view .LVU193
 818 0026 1281      		ldd r17,Z+2
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 819               		.loc 1 201 8 view .LVU194
 820 0028 1111      		cpse r17,__zero_reg__
 203:./tmk_core/common/action.c ****     }
 821               		.loc 1 203 9 is_stmt 1 view .LVU195
 822 002a 0E94 0000 		call clear_weak_mods
 823               	.LVL68:
 824               	.L67:
 207:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 825               		.loc 1 207 5 view .LVU196
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 826               		.loc 1 209 5 view .LVU197
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 827               		.loc 1 209 9 is_stmt 0 view .LVU198
 828 002e 0E94 0000 		call is_oneshot_layer_active
 829               	.LVL69:
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 830               		.loc 1 209 9 view .LVU199
 831 0032 C82E      		mov r12,r24
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 832               		.loc 1 209 8 view .LVU200
 833 0034 8823      		tst r24
 834 0036 01F0      		breq .L68
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 835               		.loc 1 209 35 discriminator 1 view .LVU201
 836 0038 1123      		tst r17
 837 003a 01F0      		breq .L150
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 838               		.loc 1 209 55 discriminator 2 view .LVU202
 839 003c 80E2      		ldi r24,lo8(32)
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 840               		.loc 1 209 55 discriminator 2 view .LVU203
 841 003e 8D0F      		add r24,r29
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 842               		.loc 1 209 52 discriminator 2 view .LVU204
 843 0040 8830      		cpi r24,lo8(8)
 844 0042 00F0      		brlo .L150
 210:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 845               		.loc 1 210 9 is_stmt 1 view .LVU205
 846 0044 82E0      		ldi r24,lo8(2)
 847 0046 0E94 0000 		call clear_oneshot_layer_state
 848               	.LVL70:
 211:./tmk_core/common/action.c ****     }
 849               		.loc 1 211 9 view .LVU206
 211:./tmk_core/common/action.c ****     }
 850               		.loc 1 211 31 is_stmt 0 view .LVU207
 851 004a 0E94 0000 		call is_oneshot_layer_active
 852               	.LVL71:
 211:./tmk_core/common/action.c ****     }
 853               		.loc 1 211 9 view .LVU208
 854 004e 91E0      		ldi r25,lo8(1)
 855 0050 C82E      		mov r12,r24
 856 0052 C926      		eor r12,r25
 857               	.LVL72:
 858               	.L68:
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 859               		.loc 1 215 5 is_stmt 1 view .LVU209
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 860               		.loc 1 215 24 is_stmt 0 view .LVU210
 861 0054 DC2E      		mov r13,r28
 862 0056 D294      		swap r13
 863 0058 9FE0      		ldi r25,lo8(15)
 864 005a D922      		and r13,r25
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 865               		.loc 1 215 5 view .LVU211
 866 005c ED2D      		mov r30,r13
 867 005e F0E0      		ldi r31,0
 868 0060 E050      		subi r30,lo8(-(gs(.L71)))
 869 0062 F040      		sbci r31,hi8(-(gs(.L71)))
 870 0064 0C94 0000 		jmp __tablejump2__
 871               		.section	.jumptables.gcc.process_action,"a",@progbits
 872               		.p2align	1
 873               	.L71:
 874 0000 0000      		.word gs(.L78)
 875 0002 0000      		.word gs(.L78)
 876 0004 0000      		.word gs(.L77)
 877 0006 0000      		.word gs(.L77)
 878 0008 0000      		.word gs(.L76)
 879 000a 0000      		.word gs(.L75)
 880 000c 0000      		.word gs(.L69)
 881 000e 0000      		.word gs(.L69)
 882 0010 0000      		.word gs(.L74)
 883 0012 0000      		.word gs(.L69)
 884 0014 0000      		.word gs(.L73)
 885 0016 0000      		.word gs(.L73)
 886 0018 0000      		.word gs(.L72)
 887 001a 0000      		.word gs(.L69)
 888 001c 0000      		.word gs(.L69)
 889 001e 0000      		.word gs(.L70)
 890               		.section	.text.process_action
 891               	.LVL73:
 892               	.L150:
 207:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 893               		.loc 1 207 10 view .LVU212
 894 0068 C12C      		mov r12,__zero_reg__
 895 006a 00C0      		rjmp .L68
 896               	.LVL74:
 897               	.L78:
 898               	.LBB20:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 899               		.loc 1 220 17 is_stmt 1 view .LVU213
 900 006c 0C2F      		mov r16,r28
 901               	.LVL75:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 902               		.loc 1 220 17 is_stmt 0 view .LVU214
 903 006e 0F70      		andi r16,lo8(15)
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 904               		.loc 1 220 48 view .LVU215
 905 0070 C07F      		andi r28,lo8(-16)
 906               	.LVL76:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 907               		.loc 1 220 25 view .LVU216
 908 0072 01F0      		breq .L79
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 909               		.loc 1 220 25 discriminator 2 view .LVU217
 910 0074 0295      		swap r16
 911 0076 007F      		andi r16,lo8(-16)
 912               	.L79:
 913               	.LVL77:
 222:./tmk_core/common/action.c ****                     if (mods) {
 914               		.loc 1 222 17 is_stmt 1 discriminator 4 view .LVU218
 222:./tmk_core/common/action.c ****                     if (mods) {
 915               		.loc 1 222 20 is_stmt 0 discriminator 4 view .LVU219
 916 0078 1123      		tst r17
 917 007a 01F0      		breq .L80
 223:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 918               		.loc 1 223 21 is_stmt 1 view .LVU220
 223:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 919               		.loc 1 223 24 is_stmt 0 view .LVU221
 920 007c 0023      		tst r16
 921 007e 01F0      		breq .L186
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 922               		.loc 1 224 25 is_stmt 1 view .LVU222
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 923               		.loc 1 224 29 is_stmt 0 view .LVU223
 924 0080 80E2      		ldi r24,lo8(32)
 925 0082 8D0F      		add r24,r29
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 926               		.loc 1 224 28 view .LVU224
 927 0084 8830      		cpi r24,lo8(8)
 928 0086 00F0      		brlo .L82
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 929               		.loc 1 224 53 discriminator 1 view .LVU225
 930 0088 D111      		cpse r29,__zero_reg__
 931 008a 00C0      		rjmp .L83
 932               	.L82:
 228:./tmk_core/common/action.c ****                         } else {
 933               		.loc 1 228 29 is_stmt 1 view .LVU226
 934 008c 802F      		mov r24,r16
 935 008e 0E94 0000 		call add_mods
 936               	.LVL78:
 937               	.L84:
 232:./tmk_core/common/action.c ****                     }
 938               		.loc 1 232 25 view .LVU227
 939 0092 0E94 0000 		call send_keyboard_report
 940               	.LVL79:
 234:./tmk_core/common/action.c ****                 } else {
 941               		.loc 1 234 21 view .LVU228
 942               	.L186:
 234:./tmk_core/common/action.c ****                 } else {
 943               		.loc 1 234 21 is_stmt 0 view .LVU229
 944               	.LBE20:
 511:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 945               		.loc 1 511 75 is_stmt 1 view .LVU230
 512:./tmk_core/common/action.c ****                         } else {
 946               		.loc 1 512 29 view .LVU231
 947 0096 8D2F      		mov r24,r29
 948 0098 0E94 0000 		call register_code
 949               	.LVL80:
 950 009c 00C0      		rjmp .L69
 951               	.LVL81:
 952               	.L83:
 953               	.LBB21:
 230:./tmk_core/common/action.c ****                         }
 954               		.loc 1 230 29 view .LVU232
 955 009e 802F      		mov r24,r16
 956 00a0 0E94 0000 		call add_weak_mods
 957               	.LVL82:
 958 00a4 00C0      		rjmp .L84
 959               	.L80:
 236:./tmk_core/common/action.c ****                     if (mods) {
 960               		.loc 1 236 21 view .LVU233
 961 00a6 8D2F      		mov r24,r29
 962 00a8 0E94 0000 		call unregister_code
 963               	.LVL83:
 237:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 964               		.loc 1 237 21 view .LVU234
 237:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 965               		.loc 1 237 24 is_stmt 0 view .LVU235
 966 00ac 0023      		tst r16
 967 00ae 01F0      		breq .L69
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 968               		.loc 1 238 25 is_stmt 1 view .LVU236
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 969               		.loc 1 238 29 is_stmt 0 view .LVU237
 970 00b0 80E2      		ldi r24,lo8(32)
 971 00b2 8D0F      		add r24,r29
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 972               		.loc 1 238 28 view .LVU238
 973 00b4 8830      		cpi r24,lo8(8)
 974 00b6 00F0      		brlo .L86
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 975               		.loc 1 238 53 discriminator 1 view .LVU239
 976 00b8 D111      		cpse r29,__zero_reg__
 977 00ba 00C0      		rjmp .L87
 978               	.L86:
 239:./tmk_core/common/action.c ****                         } else {
 979               		.loc 1 239 29 is_stmt 1 view .LVU240
 980 00bc 802F      		mov r24,r16
 981 00be 0E94 0000 		call del_mods
 982               	.LVL84:
 983               	.L88:
 243:./tmk_core/common/action.c ****                     }
 984               		.loc 1 243 25 view .LVU241
 985 00c2 0E94 0000 		call send_keyboard_report
 986               	.LVL85:
 987               	.L69:
 243:./tmk_core/common/action.c ****                     }
 988               		.loc 1 243 25 is_stmt 0 view .LVU242
 989               	.LBE21:
 641:./tmk_core/common/action.c ****         case ACT_LAYER:
 990               		.loc 1 641 5 is_stmt 1 view .LVU243
 991 00c6 98E0      		ldi r25,lo8(8)
 992 00c8 D916      		cp r13,r25
 993 00ca 01F0      		breq .L144
 994 00cc D916      		cp r13,r25
 995 00ce 00F0      		brlo .L145
 996 00d0 86E0      		ldi r24,lo8(6)
 997 00d2 8D0D      		add r24,r13
 998 00d4 8F70      		andi r24,lo8(15)
 999 00d6 8230      		cpi r24,lo8(2)
 1000 00d8 00F4      		brsh .L145
 1001               	.L144:
 647:./tmk_core/common/action.c ****             break;
 1002               		.loc 1 647 13 view .LVU244
 1003 00da 0E94 0000 		call host_keyboard_leds
 1004               	.LVL86:
 1005 00de 0E94 0000 		call led_set
 1006               	.LVL87:
 648:./tmk_core/common/action.c ****         default:
 1007               		.loc 1 648 13 view .LVU245
 1008               	.L145:
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1009               		.loc 1 684 5 view .LVU246
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1010               		.loc 1 684 8 is_stmt 0 view .LVU247
 1011 00e2 CC20      		tst r12
 1012 00e4 01F4      		brne .+2
 1013 00e6 00C0      		rjmp .L66
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1014               		.loc 1 684 33 discriminator 1 view .LVU248
 1015 00e8 0E94 0000 		call get_oneshot_layer_state
 1016               	.LVL88:
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1017               		.loc 1 684 28 discriminator 1 view .LVU249
 1018 00ec 80FD      		sbrc r24,0
 1019 00ee 00C0      		rjmp .L66
 685:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1020               		.loc 1 685 9 is_stmt 1 view .LVU250
 685:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1021               		.loc 1 685 31 is_stmt 0 view .LVU251
 1022 00f0 F701      		movw r30,r14
 1023 00f2 1282      		std Z+2,__zero_reg__
 686:./tmk_core/common/action.c ****         process_record(record);
 1024               		.loc 1 686 9 is_stmt 1 view .LVU252
 1025 00f4 0E94 0000 		call get_oneshot_layer
 1026               	.LVL89:
 1027 00f8 0E94 0000 		call layer_on
 1028               	.LVL90:
 687:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1029               		.loc 1 687 9 view .LVU253
 1030 00fc C701      		movw r24,r14
 1031 00fe 0E94 0000 		call process_record
 1032               	.LVL91:
 688:./tmk_core/common/action.c ****     }
 1033               		.loc 1 688 9 view .LVU254
 1034 0102 0E94 0000 		call get_oneshot_layer
 1035               	.LVL92:
 1036               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1037               		.loc 1 691 1 is_stmt 0 view .LVU255
 1038 0106 DF91      		pop r29
 1039               	.LVL93:
 691:./tmk_core/common/action.c **** 
 1040               		.loc 1 691 1 view .LVU256
 1041 0108 CF91      		pop r28
 691:./tmk_core/common/action.c **** 
 1042               		.loc 1 691 1 view .LVU257
 1043 010a 1F91      		pop r17
 1044               	.LVL94:
 691:./tmk_core/common/action.c **** 
 1045               		.loc 1 691 1 view .LVU258
 1046 010c 0F91      		pop r16
 1047 010e FF90      		pop r15
 1048 0110 EF90      		pop r14
 1049               	.LVL95:
 691:./tmk_core/common/action.c **** 
 1050               		.loc 1 691 1 view .LVU259
 1051 0112 DF90      		pop r13
 1052 0114 CF90      		pop r12
 1053               	.LVL96:
 691:./tmk_core/common/action.c **** 
 1054               		.loc 1 691 1 view .LVU260
 1055 0116 BF90      		pop r11
 1056 0118 AF90      		pop r10
 1057 011a 9F90      		pop r9
 1058 011c 8F90      		pop r8
 688:./tmk_core/common/action.c ****     }
 1059               		.loc 1 688 9 view .LVU261
 1060 011e 0C94 0000 		jmp layer_off
 1061               	.LVL97:
 1062               	.L87:
 1063               	.LBB22:
 241:./tmk_core/common/action.c ****                         }
 1064               		.loc 1 241 29 is_stmt 1 view .LVU262
 1065 0122 802F      		mov r24,r16
 1066 0124 0E94 0000 		call del_weak_mods
 1067               	.LVL98:
 1068 0128 00C0      		rjmp .L88
 1069               	.LVL99:
 1070               	.L77:
 241:./tmk_core/common/action.c ****                         }
 1071               		.loc 1 241 29 is_stmt 0 view .LVU263
 1072               	.LBE22:
 1073               	.LBB23:
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1074               		.loc 1 252 17 is_stmt 1 view .LVU264
 1075 012a FC2F      		mov r31,r28
 1076 012c FF70      		andi r31,lo8(15)
 1077 012e BF2E      		mov r11,r31
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1078               		.loc 1 252 48 is_stmt 0 view .LVU265
 1079 0130 C07F      		andi r28,lo8(-16)
 1080               	.LVL100:
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1081               		.loc 1 252 25 view .LVU266
 1082 0132 C032      		cpi r28,lo8(32)
 1083 0134 01F0      		breq .L89
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1084               		.loc 1 252 25 discriminator 2 view .LVU267
 1085 0136 B294      		swap r11
 1086 0138 80EF      		ldi r24,lo8(-16)
 1087 013a B822      		and r11,r24
 1088               	.L89:
 1089               	.LVL101:
 254:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 1090               		.loc 1 254 17 is_stmt 1 discriminator 4 view .LVU268
 1091 013c DD23      		tst r29
 1092 013e 01F0      		breq .L90
 1093 0140 D130      		cpi r29,lo8(1)
 1094 0142 01F0      		breq .L91
 309:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1095               		.loc 1 309 25 view .LVU269
 309:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1096               		.loc 1 309 28 is_stmt 0 view .LVU270
 1097 0144 1123      		tst r17
 1098 0146 01F0      		breq .L99
 310:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1099               		.loc 1 310 29 is_stmt 1 view .LVU271
 310:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1100               		.loc 1 310 32 is_stmt 0 view .LVU272
 1101 0148 0023      		tst r16
 1102 014a 01F0      		breq .L187
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1103               		.loc 1 312 33 is_stmt 1 view .LVU273
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1104               		.loc 1 312 37 is_stmt 0 view .LVU274
 1105 014c F701      		movw r30,r14
 1106 014e 8581      		ldd r24,Z+5
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1107               		.loc 1 312 36 view .LVU275
 1108 0150 80FF      		sbrs r24,0
 1109 0152 00C0      		rjmp .L186
 313:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 1110               		.loc 1 313 80 is_stmt 1 view .LVU276
 315:./tmk_core/common/action.c ****                                     register_mods(mods);
 1111               		.loc 1 315 37 view .LVU277
 315:./tmk_core/common/action.c ****                                     register_mods(mods);
 1112               		.loc 1 315 55 is_stmt 0 view .LVU278
 1113 0154 8F70      		andi r24,lo8(15)
 1114 0156 8583      		std Z+5,r24
 1115 0158 00C0      		rjmp .L187
 1116               	.L90:
 258:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1117               		.loc 1 258 25 is_stmt 1 view .LVU279
 258:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1118               		.loc 1 258 28 is_stmt 0 view .LVU280
 1119 015a 1123      		tst r17
 1120 015c 01F0      		breq .L93
 259:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1121               		.loc 1 259 29 is_stmt 1 view .LVU281
 259:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1122               		.loc 1 259 32 is_stmt 0 view .LVU282
 1123 015e 0111      		cpse r16,__zero_reg__
 1124 0160 00C0      		rjmp .L94
 1125               	.L95:
 273:./tmk_core/common/action.c ****                             }
 1126               		.loc 1 273 33 is_stmt 1 view .LVU283
 273:./tmk_core/common/action.c ****                             }
 1127               		.loc 1 273 54 is_stmt 0 view .LVU284
 1128 0162 0E94 0000 		call get_oneshot_mods
 1129               	.LVL102:
 273:./tmk_core/common/action.c ****                             }
 1130               		.loc 1 273 33 view .LVU285
 1131 0166 8B29      		or r24,r11
 1132               	.LVL103:
 1133               	.L184:
 316:./tmk_core/common/action.c ****                                 } else
 1134               		.loc 1 316 37 view .LVU286
 1135 0168 0E94 0000 		call register_mods
 1136               	.LVL104:
 1137 016c 00C0      		rjmp .L69
 1138               	.LVL105:
 1139               	.L94:
 262:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1140               		.loc 1 262 36 is_stmt 1 view .LVU287
 262:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1141               		.loc 1 262 39 is_stmt 0 view .LVU288
 1142 016e 0130      		cpi r16,lo8(1)
 1143 0170 01F4      		brne .L95
 263:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 1144               		.loc 1 263 69 is_stmt 1 view .LVU289
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1145               		.loc 1 264 33 view .LVU290
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1146               		.loc 1 264 57 is_stmt 0 view .LVU291
 1147 0172 0E94 0000 		call get_oneshot_mods
 1148               	.LVL106:
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1149               		.loc 1 264 33 view .LVU292
 1150 0176 8B29      		or r24,r11
 1151 0178 0E94 0000 		call set_oneshot_mods
 1152               	.LVL107:
 1153 017c 00C0      		rjmp .L69
 1154               	.L93:
 276:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1155               		.loc 1 276 29 is_stmt 1 view .LVU293
 276:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1156               		.loc 1 276 32 is_stmt 0 view .LVU294
 1157 017e 0111      		cpse r16,__zero_reg__
 1158 0180 00C0      		rjmp .L96
 1159               	.L191:
 291:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1160               		.loc 1 291 33 is_stmt 1 view .LVU295
 1161 0182 0E94 0000 		call clear_oneshot_mods
 1162               	.LVL108:
 292:./tmk_core/common/action.c ****                             }
 1163               		.loc 1 292 33 view .LVU296
 1164               	.L102:
 332:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1165               		.loc 1 332 71 view .LVU297
 333:./tmk_core/common/action.c ****                             }
 1166               		.loc 1 333 33 view .LVU298
 1167 0186 8B2D      		mov r24,r11
 1168               	.LVL109:
 1169               	.L185:
 333:./tmk_core/common/action.c ****                             }
 1170               		.loc 1 333 33 is_stmt 0 view .LVU299
 1171               	.LBE23:
 442:./tmk_core/common/action.c ****                     }
 1172               		.loc 1 442 25 view .LVU300
 1173 0188 0E94 0000 		call unregister_mods
 1174               	.LVL110:
 1175 018c 00C0      		rjmp .L69
 1176               	.LVL111:
 1177               	.L96:
 1178               	.LBB24:
 279:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1179               		.loc 1 279 36 is_stmt 1 view .LVU301
 279:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1180               		.loc 1 279 39 is_stmt 0 view .LVU302
 1181 018e 0130      		cpi r16,lo8(1)
 1182 0190 01F4      		brne .+2
 1183 0192 00C0      		rjmp .L69
 1184 0194 00C0      		rjmp .L191
 1185               	.L91:
 298:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1186               		.loc 1 298 25 is_stmt 1 view .LVU303
 298:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1187               		.loc 1 298 28 is_stmt 0 view .LVU304
 1188 0196 1123      		tst r17
 1189 0198 01F0      		breq .L98
 299:./tmk_core/common/action.c ****                                 register_mods(mods);
 1190               		.loc 1 299 29 is_stmt 1 view .LVU305
 299:./tmk_core/common/action.c ****                                 register_mods(mods);
 1191               		.loc 1 299 32 is_stmt 0 view .LVU306
 1192 019a 0630      		cpi r16,lo8(6)
 1193 019c 00F0      		brlo .+2
 1194 019e 00C0      		rjmp .L69
 1195               	.L187:
 316:./tmk_core/common/action.c ****                                 } else
 1196               		.loc 1 316 37 is_stmt 1 view .LVU307
 1197 01a0 8B2D      		mov r24,r11
 1198 01a2 00C0      		rjmp .L184
 1199               	.L98:
 303:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1200               		.loc 1 303 29 view .LVU308
 303:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1201               		.loc 1 303 32 is_stmt 0 view .LVU309
 1202 01a4 0530      		cpi r16,lo8(5)
 1203 01a6 00F0      		brlo .+2
 1204 01a8 00C0      		rjmp .L69
 1205 01aa 00C0      		rjmp .L102
 1206               	.L99:
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1207               		.loc 1 328 29 is_stmt 1 view .LVU310
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1208               		.loc 1 328 32 is_stmt 0 view .LVU311
 1209 01ac 0023      		tst r16
 1210 01ae 01F0      		breq .L102
 1211               	.LVL112:
 1212               	.L143:
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1213               		.loc 1 328 32 view .LVU312
 1214               	.LBE24:
 523:./tmk_core/common/action.c ****                         } else {
 1215               		.loc 1 523 29 is_stmt 1 view .LVU313
 1216 01b0 8D2F      		mov r24,r29
 1217 01b2 0E94 0000 		call unregister_code
 1218               	.LVL113:
 1219 01b6 00C0      		rjmp .L69
 1220               	.L76:
 344:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1221               		.loc 1 344 13 view .LVU314
 344:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1222               		.loc 1 344 33 is_stmt 0 view .LVU315
 1223 01b8 8C2F      		mov r24,r28
 1224 01ba 8695      		lsr r24
 1225 01bc 8695      		lsr r24
 1226 01be 8370      		andi r24,lo8(3)
 1227 01c0 01F0      		breq .L103
 1228 01c2 8130      		cpi r24,lo8(1)
 1229 01c4 01F0      		breq .+2
 1230 01c6 00C0      		rjmp .L69
 353:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1231               		.loc 1 353 21 is_stmt 1 view .LVU316
 354:./tmk_core/common/action.c ****                     } else {
 1232               		.loc 1 354 25 is_stmt 0 view .LVU317
 1233 01c8 8D2F      		mov r24,r29
 1234 01ca 9C2F      		mov r25,r28
 1235 01cc 9370      		andi r25,lo8(3)
 353:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1236               		.loc 1 353 24 view .LVU318
 1237 01ce 1111      		cpse r17,__zero_reg__
 1238 01d0 00C0      		rjmp .L188
 356:./tmk_core/common/action.c ****                     }
 1239               		.loc 1 356 25 is_stmt 1 view .LVU319
 1240 01d2 90E0      		ldi r25,0
 1241 01d4 80E0      		ldi r24,0
 1242               	.L188:
 1243 01d6 0E94 0000 		call host_consumer_send
 1244               	.LVL114:
 1245 01da 00C0      		rjmp .L69
 1246               	.L103:
 346:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1247               		.loc 1 346 21 view .LVU320
 347:./tmk_core/common/action.c ****                     } else {
 1248               		.loc 1 347 25 is_stmt 0 view .LVU321
 1249 01dc 8D2F      		mov r24,r29
 1250 01de 9C2F      		mov r25,r28
 1251 01e0 9370      		andi r25,lo8(3)
 346:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1252               		.loc 1 346 24 view .LVU322
 1253 01e2 1111      		cpse r17,__zero_reg__
 1254 01e4 00C0      		rjmp .L181
 349:./tmk_core/common/action.c ****                     }
 1255               		.loc 1 349 25 is_stmt 1 view .LVU323
 1256 01e6 90E0      		ldi r25,0
 1257 01e8 80E0      		ldi r24,0
 1258               	.L181:
 1259 01ea 0E94 0000 		call host_system_send
 1260               	.LVL115:
 1261 01ee 00C0      		rjmp .L69
 1262               	.L75:
 365:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1263               		.loc 1 365 13 view .LVU324
 365:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1264               		.loc 1 365 16 is_stmt 0 view .LVU325
 1265 01f0 1123      		tst r17
 1266 01f2 01F0      		breq .L107
 366:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1267               		.loc 1 366 17 is_stmt 1 view .LVU326
 1268 01f4 D53F      		cpi r29,lo8(-11)
 1269 01f6 01F0      		breq .L108
 1270 01f8 D63F      		cpi r29,lo8(-10)
 1271 01fa 01F0      		breq .L109
 1272 01fc D43F      		cpi r29,lo8(-12)
 1273 01fe 01F4      		brne .L110
 368:./tmk_core/common/action.c ****                         break;
 1274               		.loc 1 368 25 view .LVU327
 368:./tmk_core/common/action.c ****                         break;
 1275               		.loc 1 368 36 is_stmt 0 view .LVU328
 1276 0200 8091 0000 		lds r24,tp_buttons
 1277 0204 9091 0000 		lds r25,tp_buttons+1
 1278 0208 8160      		ori r24,1
 1279               	.L178:
 374:./tmk_core/common/action.c ****                         break;
 1280               		.loc 1 374 36 view .LVU329
 1281 020a 9093 0000 		sts tp_buttons+1,r25
 1282 020e 8093 0000 		sts tp_buttons,r24
 375:./tmk_core/common/action.c ****                     default:
 1283               		.loc 1 375 25 is_stmt 1 view .LVU330
 1284               	.L110:
 379:./tmk_core/common/action.c ****                 mousekey_send();
 1285               		.loc 1 379 17 view .LVU331
 1286 0212 8D2F      		mov r24,r29
 1287 0214 0E94 0000 		call mousekey_on
 1288               	.LVL116:
 380:./tmk_core/common/action.c ****             } else {
 1289               		.loc 1 380 17 view .LVU332
 1290               	.L182:
 396:./tmk_core/common/action.c ****             }
 1291               		.loc 1 396 17 view .LVU333
 1292 0218 0E94 0000 		call mousekey_send
 1293               	.LVL117:
 1294 021c 00C0      		rjmp .L69
 1295               	.L108:
 371:./tmk_core/common/action.c ****                         break;
 1296               		.loc 1 371 25 view .LVU334
 371:./tmk_core/common/action.c ****                         break;
 1297               		.loc 1 371 36 is_stmt 0 view .LVU335
 1298 021e 8091 0000 		lds r24,tp_buttons
 1299 0222 9091 0000 		lds r25,tp_buttons+1
 1300 0226 8260      		ori r24,2
 1301 0228 00C0      		rjmp .L178
 1302               	.L109:
 374:./tmk_core/common/action.c ****                         break;
 1303               		.loc 1 374 25 is_stmt 1 view .LVU336
 374:./tmk_core/common/action.c ****                         break;
 1304               		.loc 1 374 36 is_stmt 0 view .LVU337
 1305 022a 8091 0000 		lds r24,tp_buttons
 1306 022e 9091 0000 		lds r25,tp_buttons+1
 1307 0232 8460      		ori r24,4
 1308 0234 00C0      		rjmp .L178
 1309               	.L107:
 382:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1310               		.loc 1 382 17 is_stmt 1 view .LVU338
 1311 0236 D53F      		cpi r29,lo8(-11)
 1312 0238 01F0      		breq .L111
 1313 023a D63F      		cpi r29,lo8(-10)
 1314 023c 01F0      		breq .L112
 1315 023e D43F      		cpi r29,lo8(-12)
 1316 0240 01F4      		brne .L113
 384:./tmk_core/common/action.c ****                         break;
 1317               		.loc 1 384 25 view .LVU339
 384:./tmk_core/common/action.c ****                         break;
 1318               		.loc 1 384 36 is_stmt 0 view .LVU340
 1319 0242 8091 0000 		lds r24,tp_buttons
 1320 0246 9091 0000 		lds r25,tp_buttons+1
 1321 024a 8E7F      		andi r24,254
 1322               	.L179:
 390:./tmk_core/common/action.c ****                         break;
 1323               		.loc 1 390 36 view .LVU341
 1324 024c 9093 0000 		sts tp_buttons+1,r25
 1325 0250 8093 0000 		sts tp_buttons,r24
 391:./tmk_core/common/action.c ****                     default:
 1326               		.loc 1 391 25 is_stmt 1 view .LVU342
 1327               	.L113:
 395:./tmk_core/common/action.c ****                 mousekey_send();
 1328               		.loc 1 395 17 view .LVU343
 1329 0254 8D2F      		mov r24,r29
 1330 0256 0E94 0000 		call mousekey_off
 1331               	.LVL118:
 1332 025a 00C0      		rjmp .L182
 1333               	.L111:
 387:./tmk_core/common/action.c ****                         break;
 1334               		.loc 1 387 25 view .LVU344
 387:./tmk_core/common/action.c ****                         break;
 1335               		.loc 1 387 36 is_stmt 0 view .LVU345
 1336 025c 8091 0000 		lds r24,tp_buttons
 1337 0260 9091 0000 		lds r25,tp_buttons+1
 1338 0264 8D7F      		andi r24,253
 1339 0266 00C0      		rjmp .L179
 1340               	.L112:
 390:./tmk_core/common/action.c ****                         break;
 1341               		.loc 1 390 25 is_stmt 1 view .LVU346
 390:./tmk_core/common/action.c ****                         break;
 1342               		.loc 1 390 36 is_stmt 0 view .LVU347
 1343 0268 8091 0000 		lds r24,tp_buttons
 1344 026c 9091 0000 		lds r25,tp_buttons+1
 1345 0270 8B7F      		andi r24,251
 1346 0272 00C0      		rjmp .L179
 1347               	.L74:
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1348               		.loc 1 402 13 is_stmt 1 view .LVU348
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1349               		.loc 1 402 39 is_stmt 0 view .LVU349
 1350 0274 8C2F      		mov r24,r28
 1351 0276 8370      		andi r24,lo8(3)
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1352               		.loc 1 402 16 view .LVU350
 1353 0278 01F0      		breq .+2
 1354 027a 00C0      		rjmp .L114
 404:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1355               		.loc 1 404 17 is_stmt 1 view .LVU351
 404:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1356               		.loc 1 404 20 is_stmt 0 view .LVU352
 1357 027c 1111      		cpse r17,__zero_reg__
 1358 027e 00C0      		rjmp .L69
 1359               	.LBB25:
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1360               		.loc 1 405 21 is_stmt 1 view .LVU353
 1361               	.LVL119:
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1362               		.loc 1 406 21 view .LVU354
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1363               		.loc 1 405 55 is_stmt 0 view .LVU355
 1364 0280 2D2F      		mov r18,r29
 1365 0282 2295      		swap r18
 1366 0284 2695      		lsr r18
 1367 0286 2770      		andi r18,lo8(7)
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1368               		.loc 1 405 29 view .LVU356
 1369 0288 220F      		lsl r18
 1370 028a 220F      		lsl r18
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1371               		.loc 1 406 66 view .LVU357
 1372 028c 6D2F      		mov r22,r29
 1373 028e 6F70      		andi r22,lo8(15)
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1374               		.loc 1 406 38 view .LVU358
 1375 0290 862E      		mov r8,r22
 1376 0292 912C      		mov r9,__zero_reg__
 1377 0294 B12C      		mov r11,__zero_reg__
 1378 0296 A12C      		mov r10,__zero_reg__
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1379               		.loc 1 406 30 view .LVU359
 1380 0298 022E      		mov r0,r18
 1381 029a 00C0      		rjmp 2f
 1382               		1:
 1383 029c 880C      		lsl r8
 1384 029e 991C      		rol r9
 1385 02a0 AA1C      		rol r10
 1386 02a2 BB1C      		rol r11
 1387               		2:
 1388 02a4 0A94      		dec r0
 1389 02a6 02F4      		brpl 1b
 1390               	.LVL120:
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1391               		.loc 1 407 21 is_stmt 1 view .LVU360
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1392               		.loc 1 407 91 is_stmt 0 view .LVU361
 1393 02a8 60E0      		ldi r22,0
 1394 02aa 70E0      		ldi r23,0
 1395 02ac CB01      		movw r24,r22
 1396 02ae D4FF      		sbrs r29,4
 1397 02b0 00C0      		rjmp .L115
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1398               		.loc 1 407 82 discriminator 1 view .LVU362
 1399 02b2 6FE0      		ldi r22,lo8(15)
 1400 02b4 70E0      		ldi r23,0
 1401 02b6 80E0      		ldi r24,0
 1402 02b8 90E0      		ldi r25,0
 1403 02ba 00C0      		rjmp 2f
 1404               		1:
 1405 02bc 660F      		lsl r22
 1406 02be 771F      		rol r23
 1407 02c0 881F      		rol r24
 1408 02c2 991F      		rol r25
 1409               		2:
 1410 02c4 2A95      		dec r18
 1411 02c6 02F4      		brpl 1b
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1412               		.loc 1 407 91 discriminator 1 view .LVU363
 1413 02c8 6095      		com r22
 1414 02ca 7095      		com r23
 1415 02cc 8095      		com r24
 1416 02ce 9095      		com r25
 1417               	.L115:
 1418               	.LVL121:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1419               		.loc 1 408 21 is_stmt 1 discriminator 4 view .LVU364
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1420               		.loc 1 408 47 is_stmt 0 discriminator 4 view .LVU365
 1421 02d0 C695      		lsr r28
 1422 02d2 C695      		lsr r28
 1423               	.LVL122:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1424               		.loc 1 408 47 discriminator 4 view .LVU366
 1425 02d4 C370      		andi r28,lo8(3)
 1426 02d6 C230      		cpi r28,lo8(2)
 1427 02d8 01F0      		breq .L116
 1428 02da 00F4      		brsh .L117
 1429 02dc 6829      		or r22,r8
 1430               	.LVL123:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1431               		.loc 1 408 47 discriminator 4 view .LVU367
 1432 02de 7929      		or r23,r9
 1433 02e0 8A29      		or r24,r10
 1434 02e2 9B29      		or r25,r11
 1435 02e4 C130      		cpi r28,lo8(1)
 1436 02e6 01F0      		breq .L190
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1437               		.loc 1 409 42 is_stmt 1 view .LVU368
 1438 02e8 0E94 0000 		call default_layer_and
 1439               	.LVL124:
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1440               		.loc 1 409 74 view .LVU369
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1441               		.loc 1 409 25 is_stmt 0 view .LVU370
 1442 02ec 00C0      		rjmp .L69
 1443               	.LVL125:
 1444               	.L116:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1445               		.loc 1 411 42 is_stmt 1 view .LVU371
 1446 02ee 6829      		or r22,r8
 1447               	.LVL126:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1448               		.loc 1 411 42 is_stmt 0 view .LVU372
 1449 02f0 7929      		or r23,r9
 1450 02f2 8A29      		or r24,r10
 1451 02f4 9B29      		or r25,r11
 1452 02f6 0E94 0000 		call default_layer_xor
 1453               	.LVL127:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1454               		.loc 1 411 74 is_stmt 1 view .LVU373
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1455               		.loc 1 411 25 is_stmt 0 view .LVU374
 1456 02fa 00C0      		rjmp .L69
 1457               	.LVL128:
 1458               	.L117:
 412:./tmk_core/common/action.c ****                     }
 1459               		.loc 1 412 42 is_stmt 1 view .LVU375
 1460 02fc 0E94 0000 		call default_layer_and
 1461               	.LVL129:
 412:./tmk_core/common/action.c ****                     }
 1462               		.loc 1 412 67 view .LVU376
 1463 0300 C501      		movw r24,r10
 1464 0302 B401      		movw r22,r8
 1465               	.L190:
 1466 0304 0E94 0000 		call default_layer_or
 1467               	.LVL130:
 412:./tmk_core/common/action.c ****                     }
 1468               		.loc 1 412 91 view .LVU377
 412:./tmk_core/common/action.c ****                     }
 1469               		.loc 1 412 25 is_stmt 0 view .LVU378
 1470 0308 00C0      		rjmp .L69
 1471               	.LVL131:
 1472               	.L114:
 412:./tmk_core/common/action.c ****                     }
 1473               		.loc 1 412 25 view .LVU379
 1474               	.LBE25:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1475               		.loc 1 417 17 is_stmt 1 view .LVU380
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1476               		.loc 1 417 21 is_stmt 0 view .LVU381
 1477 030a 8695      		lsr r24
 1478 030c 1123      		tst r17
 1479 030e 01F0      		breq .L120
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1480               		.loc 1 417 21 discriminator 1 view .LVU382
 1481 0310 8C2F      		mov r24,r28
 1482 0312 8170      		andi r24,lo8(1)
 1483               	.L120:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1484               		.loc 1 417 20 discriminator 4 view .LVU383
 1485 0314 8823      		tst r24
 1486 0316 01F4      		brne .+2
 1487 0318 00C0      		rjmp .L69
 1488               	.LBB26:
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1489               		.loc 1 419 21 is_stmt 1 view .LVU384
 1490               	.LVL132:
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1491               		.loc 1 420 21 view .LVU385
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1492               		.loc 1 419 55 is_stmt 0 view .LVU386
 1493 031a 2D2F      		mov r18,r29
 1494 031c 2295      		swap r18
 1495 031e 2695      		lsr r18
 1496 0320 2770      		andi r18,lo8(7)
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1497               		.loc 1 419 29 view .LVU387
 1498 0322 220F      		lsl r18
 1499 0324 220F      		lsl r18
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1500               		.loc 1 420 66 view .LVU388
 1501 0326 6D2F      		mov r22,r29
 1502 0328 6F70      		andi r22,lo8(15)
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1503               		.loc 1 420 38 view .LVU389
 1504 032a 862E      		mov r8,r22
 1505 032c 912C      		mov r9,__zero_reg__
 1506 032e B12C      		mov r11,__zero_reg__
 1507 0330 A12C      		mov r10,__zero_reg__
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1508               		.loc 1 420 30 view .LVU390
 1509 0332 022E      		mov r0,r18
 1510 0334 00C0      		rjmp 2f
 1511               		1:
 1512 0336 880C      		lsl r8
 1513 0338 991C      		rol r9
 1514 033a AA1C      		rol r10
 1515 033c BB1C      		rol r11
 1516               		2:
 1517 033e 0A94      		dec r0
 1518 0340 02F4      		brpl 1b
 1519               	.LVL133:
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1520               		.loc 1 421 21 is_stmt 1 view .LVU391
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1521               		.loc 1 421 91 is_stmt 0 view .LVU392
 1522 0342 60E0      		ldi r22,0
 1523 0344 70E0      		ldi r23,0
 1524 0346 CB01      		movw r24,r22
 1525 0348 D4FF      		sbrs r29,4
 1526 034a 00C0      		rjmp .L121
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1527               		.loc 1 421 82 discriminator 1 view .LVU393
 1528 034c 6FE0      		ldi r22,lo8(15)
 1529 034e 70E0      		ldi r23,0
 1530 0350 80E0      		ldi r24,0
 1531 0352 90E0      		ldi r25,0
 1532 0354 00C0      		rjmp 2f
 1533               		1:
 1534 0356 660F      		lsl r22
 1535 0358 771F      		rol r23
 1536 035a 881F      		rol r24
 1537 035c 991F      		rol r25
 1538               		2:
 1539 035e 2A95      		dec r18
 1540 0360 02F4      		brpl 1b
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1541               		.loc 1 421 91 discriminator 1 view .LVU394
 1542 0362 6095      		com r22
 1543 0364 7095      		com r23
 1544 0366 8095      		com r24
 1545 0368 9095      		com r25
 1546               	.L121:
 1547               	.LVL134:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1548               		.loc 1 422 21 is_stmt 1 discriminator 4 view .LVU395
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1549               		.loc 1 422 47 is_stmt 0 discriminator 4 view .LVU396
 1550 036a C695      		lsr r28
 1551 036c C695      		lsr r28
 1552               	.LVL135:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1553               		.loc 1 422 47 discriminator 4 view .LVU397
 1554 036e C370      		andi r28,lo8(3)
 1555 0370 C230      		cpi r28,lo8(2)
 1556 0372 01F0      		breq .L122
 1557 0374 00F4      		brsh .L123
 1558 0376 6829      		or r22,r8
 1559               	.LVL136:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1560               		.loc 1 422 47 discriminator 4 view .LVU398
 1561 0378 7929      		or r23,r9
 1562 037a 8A29      		or r24,r10
 1563 037c 9B29      		or r25,r11
 1564 037e C130      		cpi r28,lo8(1)
 1565 0380 01F0      		breq .L189
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1566               		.loc 1 423 42 is_stmt 1 view .LVU399
 1567 0382 0E94 0000 		call layer_and
 1568               	.LVL137:
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1569               		.loc 1 423 66 view .LVU400
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1570               		.loc 1 423 25 is_stmt 0 view .LVU401
 1571 0386 00C0      		rjmp .L69
 1572               	.LVL138:
 1573               	.L122:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1574               		.loc 1 425 42 is_stmt 1 view .LVU402
 1575 0388 6829      		or r22,r8
 1576               	.LVL139:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1577               		.loc 1 425 42 is_stmt 0 view .LVU403
 1578 038a 7929      		or r23,r9
 1579 038c 8A29      		or r24,r10
 1580 038e 9B29      		or r25,r11
 1581 0390 0E94 0000 		call layer_xor
 1582               	.LVL140:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1583               		.loc 1 425 66 is_stmt 1 view .LVU404
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1584               		.loc 1 425 25 is_stmt 0 view .LVU405
 1585 0394 00C0      		rjmp .L69
 1586               	.LVL141:
 1587               	.L123:
 426:./tmk_core/common/action.c ****                     }
 1588               		.loc 1 426 42 is_stmt 1 view .LVU406
 1589 0396 0E94 0000 		call layer_and
 1590               	.LVL142:
 426:./tmk_core/common/action.c ****                     }
 1591               		.loc 1 426 59 view .LVU407
 1592 039a C501      		movw r24,r10
 1593 039c B401      		movw r22,r8
 1594               	.L189:
 1595 039e 0E94 0000 		call layer_or
 1596               	.LVL143:
 426:./tmk_core/common/action.c ****                     }
 1597               		.loc 1 426 75 view .LVU408
 426:./tmk_core/common/action.c ****                     }
 1598               		.loc 1 426 25 is_stmt 0 view .LVU409
 1599 03a2 00C0      		rjmp .L69
 1600               	.LVL144:
 1601               	.L73:
 426:./tmk_core/common/action.c ****                     }
 1602               		.loc 1 426 25 view .LVU410
 1603               	.LBE26:
 434:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1604               		.loc 1 434 13 is_stmt 1 view .LVU411
 1605 03a4 E0E2      		ldi r30,lo8(32)
 1606 03a6 ED0F      		add r30,r29
 1607 03a8 E531      		cpi r30,lo8(21)
 1608 03aa 00F0      		brlo .+2
 1609 03ac 00C0      		rjmp .L125
 1610 03ae F0E0      		ldi r31,0
 1611 03b0 E050      		subi r30,lo8(-(gs(.L127)))
 1612 03b2 F040      		sbci r31,hi8(-(gs(.L127)))
 1613 03b4 0C94 0000 		jmp __tablejump2__
 1614               		.section	.jumptables.gcc.process_action,"a",@progbits
 1615               		.p2align	1
 1616               	.L127:
 1617 0020 0000      		.word gs(.L132)
 1618 0022 0000      		.word gs(.L132)
 1619 0024 0000      		.word gs(.L132)
 1620 0026 0000      		.word gs(.L132)
 1621 0028 0000      		.word gs(.L132)
 1622 002a 0000      		.word gs(.L132)
 1623 002c 0000      		.word gs(.L132)
 1624 002e 0000      		.word gs(.L132)
 1625 0030 0000      		.word gs(.L132)
 1626 0032 0000      		.word gs(.L132)
 1627 0034 0000      		.word gs(.L132)
 1628 0036 0000      		.word gs(.L132)
 1629 0038 0000      		.word gs(.L132)
 1630 003a 0000      		.word gs(.L132)
 1631 003c 0000      		.word gs(.L132)
 1632 003e 0000      		.word gs(.L132)
 1633 0040 0000      		.word gs(.L131)
 1634 0042 0000      		.word gs(.L130)
 1635 0044 0000      		.word gs(.L129)
 1636 0046 0000      		.word gs(.L128)
 1637 0048 0000      		.word gs(.L126)
 1638               		.section	.text.process_action
 1639               	.L132:
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1640               		.loc 1 437 21 view .LVU412
 1641 03b8 DF70      		andi r29,lo8(15)
 1642               	.LVL145:
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1643               		.loc 1 437 21 is_stmt 0 view .LVU413
 1644 03ba 8C2F      		mov r24,r28
 1645 03bc 8F71      		andi r24,lo8(31)
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1646               		.loc 1 437 24 view .LVU414
 1647 03be 1123      		tst r17
 1648 03c0 01F0      		breq .L133
 438:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1649               		.loc 1 438 25 is_stmt 1 view .LVU415
 1650 03c2 0E94 0000 		call layer_on
 1651               	.LVL146:
 439:./tmk_core/common/action.c ****                     } else {
 1652               		.loc 1 439 25 view .LVU416
 1653 03c6 8D2F      		mov r24,r29
 1654 03c8 00C0      		rjmp .L184
 1655               	.L133:
 441:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1656               		.loc 1 441 25 view .LVU417
 1657 03ca 0E94 0000 		call layer_off
 1658               	.LVL147:
 442:./tmk_core/common/action.c ****                     }
 1659               		.loc 1 442 25 view .LVU418
 1660 03ce 8D2F      		mov r24,r29
 1661 03d0 00C0      		rjmp .L185
 1662               	.LVL148:
 1663               	.L131:
 447:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1664               		.loc 1 447 21 view .LVU419
 447:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1665               		.loc 1 447 24 is_stmt 0 view .LVU420
 1666 03d2 1123      		tst r17
 1667 03d4 01F0      		breq .L134
 448:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1668               		.loc 1 448 25 is_stmt 1 view .LVU421
 448:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1669               		.loc 1 448 28 is_stmt 0 view .LVU422
 1670 03d6 0530      		cpi r16,lo8(5)
 1671 03d8 00F0      		brlo .+2
 1672 03da 00C0      		rjmp .L69
 1673               	.L135:
 449:./tmk_core/common/action.c ****                         }
 1674               		.loc 1 449 29 is_stmt 1 view .LVU423
 1675 03dc 8C2F      		mov r24,r28
 1676 03de 8F71      		andi r24,lo8(31)
 1677 03e0 0E94 0000 		call layer_invert
 1678               	.LVL149:
 1679 03e4 00C0      		rjmp .L69
 1680               	.L134:
 452:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1681               		.loc 1 452 25 view .LVU424
 452:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1682               		.loc 1 452 28 is_stmt 0 view .LVU425
 1683 03e6 0630      		cpi r16,lo8(6)
 1684 03e8 00F0      		brlo .+2
 1685 03ea 00C0      		rjmp .L69
 1686 03ec 00C0      		rjmp .L135
 1687               	.L130:
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1688               		.loc 1 458 21 is_stmt 1 view .LVU426
 1689 03ee 8C2F      		mov r24,r28
 1690 03f0 8F71      		andi r24,lo8(31)
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1691               		.loc 1 458 68 is_stmt 0 view .LVU427
 1692 03f2 1123      		tst r17
 1693 03f4 01F0      		breq .L180
 1694               	.L183:
 515:./tmk_core/common/action.c ****                         }
 1695               		.loc 1 515 29 view .LVU428
 1696 03f6 0E94 0000 		call layer_on
 1697               	.LVL150:
 1698 03fa 00C0      		rjmp .L69
 1699               	.L129:
 462:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1700               		.loc 1 462 21 is_stmt 1 view .LVU429
 1701 03fc 8C2F      		mov r24,r28
 1702 03fe 8F71      		andi r24,lo8(31)
 462:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1703               		.loc 1 462 69 is_stmt 0 view .LVU430
 1704 0400 1123      		tst r17
 1705 0402 01F0      		breq .L183
 1706               	.L180:
 526:./tmk_core/common/action.c ****                         }
 1707               		.loc 1 526 29 view .LVU431
 1708 0404 0E94 0000 		call layer_off
 1709               	.LVL151:
 1710 0408 00C0      		rjmp .L69
 1711               	.L128:
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1712               		.loc 1 466 21 is_stmt 1 view .LVU432
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1713               		.loc 1 466 70 is_stmt 0 view .LVU433
 1714 040a 1123      		tst r17
 1715 040c 01F0      		breq .L138
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1716               		.loc 1 466 37 discriminator 1 view .LVU434
 1717 040e 8C2F      		mov r24,r28
 1718 0410 8F71      		andi r24,lo8(31)
 1719 0412 0E94 0000 		call layer_move
 1720               	.LVL152:
 1721 0416 00C0      		rjmp .L69
 1722               	.L138:
 467:./tmk_core/common/action.c ****                     break;
 1723               		.loc 1 467 37 view .LVU435
 1724 0418 0E94 0000 		call layer_clear
 1725               	.LVL153:
 1726 041c 00C0      		rjmp .L69
 1727               	.L126:
 495:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1728               		.loc 1 495 21 is_stmt 1 view .LVU436
 495:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1729               		.loc 1 495 24 is_stmt 0 view .LVU437
 1730 041e 1123      		tst r17
 1731 0420 01F0      		breq .L139
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1732               		.loc 1 496 25 is_stmt 1 view .LVU438
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1733               		.loc 1 496 50 is_stmt 0 view .LVU439
 1734 0422 CF71      		andi r28,lo8(31)
 1735               	.LVL154:
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1736               		.loc 1 496 25 view .LVU440
 1737 0424 8C2F      		mov r24,r28
 1738 0426 0E94 0000 		call layer_on
 1739               	.LVL155:
 497:./tmk_core/common/action.c ****                     } else {
 1740               		.loc 1 497 25 is_stmt 1 view .LVU441
 1741 042a 63E0      		ldi r22,lo8(3)
 1742 042c 8C2F      		mov r24,r28
 1743 042e 0E94 0000 		call set_oneshot_layer
 1744               	.LVL156:
 1745 0432 00C0      		rjmp .L69
 1746               	.LVL157:
 1747               	.L139:
 499:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 1748               		.loc 1 499 25 view .LVU442
 1749 0434 81E0      		ldi r24,lo8(1)
 1750 0436 0E94 0000 		call clear_oneshot_layer_state
 1751               	.LVL158:
 500:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1752               		.loc 1 500 25 view .LVU443
 500:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1753               		.loc 1 500 28 is_stmt 0 view .LVU444
 1754 043a 0230      		cpi r16,lo8(2)
 1755 043c 00F4      		brsh .+2
 1756 043e 00C0      		rjmp .L69
 501:./tmk_core/common/action.c ****                         }
 1757               		.loc 1 501 29 is_stmt 1 view .LVU445
 1758 0440 82E0      		ldi r24,lo8(2)
 1759 0442 0E94 0000 		call clear_oneshot_layer_state
 1760               	.LVL159:
 1761 0446 00C0      		rjmp .L69
 1762               	.L125:
 509:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1763               		.loc 1 509 21 view .LVU446
 509:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1764               		.loc 1 509 24 is_stmt 0 view .LVU447
 1765 0448 1123      		tst r17
 1766 044a 01F0      		breq .L140
 510:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1767               		.loc 1 510 25 is_stmt 1 view .LVU448
 510:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1768               		.loc 1 510 28 is_stmt 0 view .LVU449
 1769 044c 0111      		cpse r16,__zero_reg__
 1770 044e 00C0      		rjmp .L186
 514:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1771               		.loc 1 514 76 is_stmt 1 view .LVU450
 515:./tmk_core/common/action.c ****                         }
 1772               		.loc 1 515 29 view .LVU451
 1773 0450 8C2F      		mov r24,r28
 1774 0452 8F71      		andi r24,lo8(31)
 1775 0454 00C0      		rjmp .L183
 1776               	.L140:
 518:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1777               		.loc 1 518 25 view .LVU452
 518:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1778               		.loc 1 518 28 is_stmt 0 view .LVU453
 1779 0456 0023      		tst r16
 1780 0458 01F0      		breq .L142
 519:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1781               		.loc 1 519 77 is_stmt 1 view .LVU454
 520:./tmk_core/common/action.c ****                                 wait_ms(80);
 1782               		.loc 1 520 29 view .LVU455
 520:./tmk_core/common/action.c ****                                 wait_ms(80);
 1783               		.loc 1 520 32 is_stmt 0 view .LVU456
 1784 045a D933      		cpi r29,lo8(57)
 1785 045c 01F0      		breq .+2
 1786 045e 00C0      		rjmp .L143
 521:./tmk_core/common/action.c ****                             }
 1787               		.loc 1 521 33 is_stmt 1 view .LVU457
 1788               	.LVL160:
 1789               	.LBB27:
 1790               	.LBI27:
 166:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 1791               		.loc 2 166 1 view .LVU458
 1792               	.LBB28:
 168:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1793               		.loc 2 168 2 view .LVU459
 172:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1794               		.loc 2 172 2 view .LVU460
 173:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1795               		.loc 2 173 2 view .LVU461
 174:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 1796               		.loc 2 174 2 view .LVU462
 184:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 1797               		.loc 2 184 3 view .LVU463
 1798               		.loc 2 187 2 view .LVU464
 1799 0460 FFEF      		ldi r31,lo8(255999)
 1800 0462 27EE      		ldi r18,hi8(255999)
 1801 0464 83E0      		ldi r24,hlo8(255999)
 1802 0466 F150      	1:	subi r31,1
 1803 0468 2040      		sbci r18,0
 1804 046a 8040      		sbci r24,0
 1805 046c 01F4      		brne 1b
 1806 046e 00C0      		rjmp .
 1807 0470 0000      		nop
 1808 0472 00C0      		rjmp .L143
 1809               	.LVL161:
 1810               	.L142:
 1811               		.loc 2 187 2 is_stmt 0 view .LVU465
 1812               	.LBE28:
 1813               	.LBE27:
 525:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1814               		.loc 1 525 79 is_stmt 1 view .LVU466
 526:./tmk_core/common/action.c ****                         }
 1815               		.loc 1 526 29 view .LVU467
 1816 0474 8C2F      		mov r24,r28
 1817 0476 8F71      		andi r24,lo8(31)
 1818 0478 00C0      		rjmp .L180
 1819               	.L72:
 537:./tmk_core/common/action.c ****             break;
 1820               		.loc 1 537 13 view .LVU468
 537:./tmk_core/common/action.c ****             break;
 1821               		.loc 1 537 83 is_stmt 0 view .LVU469
 1822 047a 4C2F      		mov r20,r28
 1823 047c 4F70      		andi r20,lo8(15)
 537:./tmk_core/common/action.c ****             break;
 1824               		.loc 1 537 13 view .LVU470
 1825 047e 6D2F      		mov r22,r29
 1826 0480 C701      		movw r24,r14
 1827 0482 0E94 0000 		call action_get_macro
 1828               	.LVL162:
 1829 0486 0E94 0000 		call action_macro_play
 1830               	.LVL163:
 538:./tmk_core/common/action.c **** #endif
 1831               		.loc 1 538 13 is_stmt 1 view .LVU471
 1832 048a 00C0      		rjmp .L69
 1833               	.L70:
 632:./tmk_core/common/action.c ****             break;
 1834               		.loc 1 632 13 view .LVU472
 632:./tmk_core/common/action.c ****             break;
 1835               		.loc 1 632 64 is_stmt 0 view .LVU473
 1836 048c 4C2F      		mov r20,r28
 1837 048e 4F70      		andi r20,lo8(15)
 632:./tmk_core/common/action.c ****             break;
 1838               		.loc 1 632 13 view .LVU474
 1839 0490 6D2F      		mov r22,r29
 1840 0492 C701      		movw r24,r14
 1841 0494 0E94 0000 		call action_function
 1842               	.LVL164:
 633:./tmk_core/common/action.c **** #endif
 1843               		.loc 1 633 13 is_stmt 1 view .LVU475
 1844 0498 00C0      		rjmp .L69
 1845               	.LVL165:
 1846               	.L66:
 1847               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1848               		.loc 1 691 1 is_stmt 0 view .LVU476
 1849 049a DF91      		pop r29
 1850               	.LVL166:
 691:./tmk_core/common/action.c **** 
 1851               		.loc 1 691 1 view .LVU477
 1852 049c CF91      		pop r28
 691:./tmk_core/common/action.c **** 
 1853               		.loc 1 691 1 view .LVU478
 1854 049e 1F91      		pop r17
 1855               	.LVL167:
 691:./tmk_core/common/action.c **** 
 1856               		.loc 1 691 1 view .LVU479
 1857 04a0 0F91      		pop r16
 1858 04a2 FF90      		pop r15
 1859 04a4 EF90      		pop r14
 1860               	.LVL168:
 691:./tmk_core/common/action.c **** 
 1861               		.loc 1 691 1 view .LVU480
 1862 04a6 DF90      		pop r13
 1863 04a8 CF90      		pop r12
 1864               	.LVL169:
 691:./tmk_core/common/action.c **** 
 1865               		.loc 1 691 1 view .LVU481
 1866 04aa BF90      		pop r11
 1867 04ac AF90      		pop r10
 1868 04ae 9F90      		pop r9
 1869 04b0 8F90      		pop r8
 1870 04b2 0895      		ret
 1871               		.cfi_endproc
 1872               	.LFE18:
 1874               		.section	.text.process_record,"ax",@progbits
 1875               	.global	process_record
 1877               	process_record:
 1878               	.LVL170:
 1879               	.LFB17:
 173:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1880               		.loc 1 173 1 is_stmt 1 view -0
 1881               		.cfi_startproc
 173:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1882               		.loc 1 173 1 is_stmt 0 view .LVU483
 1883 0000 0F93      		push r16
 1884               	.LCFI17:
 1885               		.cfi_def_cfa_offset 3
 1886               		.cfi_offset 16, -2
 1887 0002 1F93      		push r17
 1888               	.LCFI18:
 1889               		.cfi_def_cfa_offset 4
 1890               		.cfi_offset 17, -3
 1891 0004 CF93      		push r28
 1892               	.LCFI19:
 1893               		.cfi_def_cfa_offset 5
 1894               		.cfi_offset 28, -4
 1895 0006 DF93      		push r29
 1896               	.LCFI20:
 1897               		.cfi_def_cfa_offset 6
 1898               		.cfi_offset 29, -5
 1899               	/* prologue: function */
 1900               	/* frame size = 0 */
 1901               	/* stack size = 4 */
 1902               	.L__stack_usage = 4
 1903 0008 EC01      		movw r28,r24
 174:./tmk_core/common/action.c **** 
 1904               		.loc 1 174 5 is_stmt 1 view .LVU484
 1905               	.LBB31:
 1906               	.LBI31:
 1907               		.file 3 "./tmk_core/common/keyboard.h"
   1:./tmk_core/common/keyboard.h **** /*
   2:./tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/keyboard.h **** 
   4:./tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/keyboard.h **** (at your option) any later version.
   8:./tmk_core/common/keyboard.h **** 
   9:./tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:./tmk_core/common/keyboard.h **** 
  14:./tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/keyboard.h **** */
  17:./tmk_core/common/keyboard.h **** 
  18:./tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:./tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:./tmk_core/common/keyboard.h **** 
  21:./tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:./tmk_core/common/keyboard.h **** #include <stdint.h>
  23:./tmk_core/common/keyboard.h **** 
  24:./tmk_core/common/keyboard.h **** 
  25:./tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:./tmk_core/common/keyboard.h **** extern "C" {
  27:./tmk_core/common/keyboard.h **** #endif
  28:./tmk_core/common/keyboard.h **** 
  29:./tmk_core/common/keyboard.h **** /* key matrix position */
  30:./tmk_core/common/keyboard.h **** typedef struct {
  31:./tmk_core/common/keyboard.h ****     uint8_t col;
  32:./tmk_core/common/keyboard.h ****     uint8_t row;
  33:./tmk_core/common/keyboard.h **** } keypos_t;
  34:./tmk_core/common/keyboard.h **** 
  35:./tmk_core/common/keyboard.h **** /* key event */
  36:./tmk_core/common/keyboard.h **** typedef struct {
  37:./tmk_core/common/keyboard.h ****     keypos_t key;
  38:./tmk_core/common/keyboard.h ****     bool     pressed;
  39:./tmk_core/common/keyboard.h ****     uint16_t time;
  40:./tmk_core/common/keyboard.h **** } keyevent_t;
  41:./tmk_core/common/keyboard.h **** 
  42:./tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:./tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:./tmk_core/common/keyboard.h **** 
  45:./tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:./tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:./tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:./tmk_core/common/keyboard.h ****  */
  49:./tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1908               		.loc 3 49 20 view .LVU485
 1909               	.LBB32:
 1910               		.loc 3 49 51 view .LVU486
 1911               		.loc 3 49 74 is_stmt 0 view .LVU487
 1912 000a 8B81      		ldd r24,Y+3
 1913 000c 9C81      		ldd r25,Y+4
 1914               	.LVL171:
 1915               		.loc 3 49 74 view .LVU488
 1916 000e 892B      		or r24,r25
 1917 0010 01F0      		breq .L192
 1918 0012 8881      		ld r24,Y
 1919 0014 9981      		ldd r25,Y+1
 1920 0016 8923      		and r24,r25
 1921 0018 8F3F      		cpi r24,lo8(-1)
 1922 001a 01F4      		brne .L202
 1923               	.L192:
 1924               	/* epilogue start */
 1925               	.LBE32:
 1926               	.LBE31:
 188:./tmk_core/common/action.c **** 
 1927               		.loc 1 188 1 view .LVU489
 1928 001c DF91      		pop r29
 1929 001e CF91      		pop r28
 1930               	.LVL172:
 188:./tmk_core/common/action.c **** 
 1931               		.loc 1 188 1 view .LVU490
 1932 0020 1F91      		pop r17
 1933 0022 0F91      		pop r16
 1934 0024 0895      		ret
 1935               	.LVL173:
 1936               	.L202:
 176:./tmk_core/common/action.c ****         return;
 1937               		.loc 1 176 5 is_stmt 1 view .LVU491
 176:./tmk_core/common/action.c ****         return;
 1938               		.loc 1 176 9 is_stmt 0 view .LVU492
 1939 0026 CE01      		movw r24,r28
 1940 0028 0E94 0000 		call process_record_quantum
 1941               	.LVL174:
 176:./tmk_core/common/action.c ****         return;
 1942               		.loc 1 176 7 view .LVU493
 1943 002c 8823      		tst r24
 1944 002e 01F0      		breq .L192
 179:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1945               		.loc 1 179 5 is_stmt 1 view .LVU494
 179:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 1946               		.loc 1 179 23 is_stmt 0 view .LVU495
 1947 0030 6881      		ld r22,Y
 1948 0032 7981      		ldd r23,Y+1
 1949 0034 8A81      		ldd r24,Y+2
 1950 0036 0E94 0000 		call store_or_get_action
 1951               	.LVL175:
 1952 003a 8C01      		movw r16,r24
 1953               	.LVL176:
 180:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1954               		.loc 1 180 23 is_stmt 1 view .LVU496
 180:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 1955               		.loc 1 180 25 view .LVU497
 182:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1956               		.loc 1 182 29 view .LVU498
 182:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 1957               		.loc 1 182 31 view .LVU499
 1958 003c 0E94 0000 		call layer_debug
 1959               	.LVL177:
 183:./tmk_core/common/action.c **** #endif
 1960               		.loc 1 183 37 view .LVU500
 183:./tmk_core/common/action.c **** #endif
 1961               		.loc 1 183 39 view .LVU501
 1962 0040 0E94 0000 		call default_layer_debug
 1963               	.LVL178:
 185:./tmk_core/common/action.c **** 
 1964               		.loc 1 185 15 view .LVU502
 187:./tmk_core/common/action.c **** }
 1965               		.loc 1 187 5 view .LVU503
 187:./tmk_core/common/action.c **** }
 1966               		.loc 1 187 5 is_stmt 0 view .LVU504
 1967 0044 B801      		movw r22,r16
 1968 0046 CE01      		movw r24,r28
 1969               	/* epilogue start */
 188:./tmk_core/common/action.c **** 
 1970               		.loc 1 188 1 view .LVU505
 1971 0048 DF91      		pop r29
 1972 004a CF91      		pop r28
 1973               	.LVL179:
 188:./tmk_core/common/action.c **** 
 1974               		.loc 1 188 1 view .LVU506
 1975 004c 1F91      		pop r17
 1976 004e 0F91      		pop r16
 1977               	.LVL180:
 187:./tmk_core/common/action.c **** }
 1978               		.loc 1 187 5 view .LVU507
 1979 0050 0C94 0000 		jmp process_action
 1980               	.LVL181:
 187:./tmk_core/common/action.c **** }
 1981               		.loc 1 187 5 view .LVU508
 1982               		.cfi_endproc
 1983               	.LFE17:
 1985               		.section	.text.process_record_nocache,"ax",@progbits
 1986               	.global	process_record_nocache
 1988               	process_record_nocache:
 1989               	.LVL182:
 1990               	.LFB14:
 134:./tmk_core/common/action.c ****     process_record(record);
 1991               		.loc 1 134 1 is_stmt 1 view -0
 1992               		.cfi_startproc
 1993               	/* prologue: function */
 1994               	/* frame size = 0 */
 1995               	/* stack size = 0 */
 1996               	.L__stack_usage = 0
 135:./tmk_core/common/action.c **** }
 1997               		.loc 1 135 5 view .LVU510
 1998 0000 0C94 0000 		jmp process_record
 1999               	.LVL183:
 135:./tmk_core/common/action.c **** }
 2000               		.loc 1 135 5 is_stmt 0 view .LVU511
 2001               		.cfi_endproc
 2002               	.LFE14:
 2004               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2005               	.global	clear_keyboard_but_mods
 2007               	clear_keyboard_but_mods:
 2008               	.LFB24:
 860:./tmk_core/common/action.c **** 
 861:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:./tmk_core/common/action.c ****  *
 863:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:./tmk_core/common/action.c ****  */
 865:./tmk_core/common/action.c **** void clear_keyboard(void)
 866:./tmk_core/common/action.c **** {
 867:./tmk_core/common/action.c ****     clear_mods();
 868:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 869:./tmk_core/common/action.c **** }
 870:./tmk_core/common/action.c **** 
 871:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:./tmk_core/common/action.c ****  *
 873:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:./tmk_core/common/action.c ****  */
 875:./tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 876:./tmk_core/common/action.c **** {
 2009               		.loc 1 876 1 is_stmt 1 view -0
 2010               		.cfi_startproc
 2011               	/* prologue: function */
 2012               	/* frame size = 0 */
 2013               	/* stack size = 0 */
 2014               	.L__stack_usage = 0
 877:./tmk_core/common/action.c ****     clear_weak_mods();
 2015               		.loc 1 877 5 view .LVU513
 2016 0000 0E94 0000 		call clear_weak_mods
 2017               	.LVL184:
 878:./tmk_core/common/action.c ****     clear_macro_mods();
 2018               		.loc 1 878 5 view .LVU514
 2019 0004 0E94 0000 		call clear_macro_mods
 2020               	.LVL185:
 879:./tmk_core/common/action.c ****     clear_keys();
 2021               		.loc 1 879 5 view .LVU515
 2022 0008 0E94 0000 		call clear_keys
 2023               	.LVL186:
 880:./tmk_core/common/action.c ****     send_keyboard_report();
 2024               		.loc 1 880 5 view .LVU516
 2025 000c 0E94 0000 		call send_keyboard_report
 2026               	.LVL187:
 881:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 882:./tmk_core/common/action.c ****     mousekey_clear();
 2027               		.loc 1 882 5 view .LVU517
 2028 0010 0E94 0000 		call mousekey_clear
 2029               	.LVL188:
 883:./tmk_core/common/action.c ****     mousekey_send();
 2030               		.loc 1 883 5 view .LVU518
 2031 0014 0E94 0000 		call mousekey_send
 2032               	.LVL189:
 884:./tmk_core/common/action.c **** #endif
 885:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 886:./tmk_core/common/action.c ****     host_system_send(0);
 2033               		.loc 1 886 5 view .LVU519
 2034 0018 90E0      		ldi r25,0
 2035 001a 80E0      		ldi r24,0
 2036 001c 0E94 0000 		call host_system_send
 2037               	.LVL190:
 887:./tmk_core/common/action.c ****     host_consumer_send(0);
 2038               		.loc 1 887 5 view .LVU520
 2039 0020 90E0      		ldi r25,0
 2040 0022 80E0      		ldi r24,0
 2041 0024 0C94 0000 		jmp host_consumer_send
 2042               	.LVL191:
 2043               		.cfi_endproc
 2044               	.LFE24:
 2046               		.section	.text.clear_keyboard,"ax",@progbits
 2047               	.global	clear_keyboard
 2049               	clear_keyboard:
 2050               	.LFB23:
 866:./tmk_core/common/action.c ****     clear_mods();
 2051               		.loc 1 866 1 view -0
 2052               		.cfi_startproc
 2053               	/* prologue: function */
 2054               	/* frame size = 0 */
 2055               	/* stack size = 0 */
 2056               	.L__stack_usage = 0
 867:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2057               		.loc 1 867 5 view .LVU522
 2058 0000 0E94 0000 		call clear_mods
 2059               	.LVL192:
 868:./tmk_core/common/action.c **** }
 2060               		.loc 1 868 5 view .LVU523
 2061 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2062               	.LVL193:
 2063               		.cfi_endproc
 2064               	.LFE23:
 2066               		.section	.text.is_tap_key,"ax",@progbits
 2067               	.global	is_tap_key
 2069               	is_tap_key:
 2070               	.LVL194:
 2071               	.LFB25:
 888:./tmk_core/common/action.c **** #endif
 889:./tmk_core/common/action.c **** }
 890:./tmk_core/common/action.c **** 
 891:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 892:./tmk_core/common/action.c ****  *
 893:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 894:./tmk_core/common/action.c ****  */
 895:./tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 896:./tmk_core/common/action.c **** {
 2072               		.loc 1 896 1 view -0
 2073               		.cfi_startproc
 2074               	/* prologue: function */
 2075               	/* frame size = 0 */
 2076               	/* stack size = 0 */
 2077               	.L__stack_usage = 0
 897:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2078               		.loc 1 897 5 view .LVU525
 2079               		.loc 1 897 23 is_stmt 0 view .LVU526
 2080 0000 0E94 0000 		call layer_switch_get_action
 2081               	.LVL195:
 898:./tmk_core/common/action.c **** 
 899:./tmk_core/common/action.c ****     switch (action.kind.id) {
 2082               		.loc 1 899 5 is_stmt 1 view .LVU527
 2083               		.loc 1 899 24 is_stmt 0 view .LVU528
 2084 0004 E92F      		mov r30,r25
 2085 0006 E295      		swap r30
 2086 0008 EF70      		andi r30,lo8(15)
 2087               		.loc 1 899 5 view .LVU529
 2088 000a E250      		subi r30,lo8(-(-2))
 2089 000c EE30      		cpi r30,lo8(14)
 2090 000e 00F4      		brsh .L215
 2091 0010 F0E0      		ldi r31,0
 2092 0012 E050      		subi r30,lo8(-(gs(.L209)))
 2093 0014 F040      		sbci r31,hi8(-(gs(.L209)))
 2094 0016 0C94 0000 		jmp __tablejump2__
 2095               		.section	.jumptables.gcc.is_tap_key,"a",@progbits
 2096               		.p2align	1
 2097               	.L209:
 2098 0000 0000      		.word gs(.L210)
 2099 0002 0000      		.word gs(.L210)
 2100 0004 0000      		.word gs(.L215)
 2101 0006 0000      		.word gs(.L215)
 2102 0008 0000      		.word gs(.L211)
 2103 000a 0000      		.word gs(.L215)
 2104 000c 0000      		.word gs(.L215)
 2105 000e 0000      		.word gs(.L215)
 2106 0010 0000      		.word gs(.L210)
 2107 0012 0000      		.word gs(.L210)
 2108 0014 0000      		.word gs(.L208)
 2109 0016 0000      		.word gs(.L215)
 2110 0018 0000      		.word gs(.L215)
 2111 001a 0000      		.word gs(.L208)
 2112               		.section	.text.is_tap_key
 2113               	.L210:
 900:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 901:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 902:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 903:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 904:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 2114               		.loc 1 904 13 is_stmt 1 view .LVU530
 2115 001a 803F      		cpi r24,lo8(-16)
 2116 001c 01F0      		breq .L218
 2117 001e 00F4      		brsh .L212
 2118 0020 803E      		cpi r24,lo8(-32)
 2119 0022 00F4      		brsh .L215
 2120               	.L218:
 905:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 906:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 907:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 908:./tmk_core/common/action.c ****                     return true;
 2121               		.loc 1 908 28 is_stmt 0 view .LVU531
 2122 0024 81E0      		ldi r24,lo8(1)
 2123               	.LVL196:
 2124               	/* epilogue start */
 909:./tmk_core/common/action.c ****             }
 910:./tmk_core/common/action.c ****             return false;
 911:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 912:./tmk_core/common/action.c ****             switch (action.swap.code) {
 913:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 914:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 915:./tmk_core/common/action.c ****                     return true;
 916:./tmk_core/common/action.c ****             }
 917:./tmk_core/common/action.c ****             return false;
 918:./tmk_core/common/action.c ****         case ACT_MACRO:
 919:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 920:./tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 921:./tmk_core/common/action.c ****             return false;
 922:./tmk_core/common/action.c ****     }
 923:./tmk_core/common/action.c ****     return false;
 924:./tmk_core/common/action.c **** }
 2125               		.loc 1 924 1 view .LVU532
 2126 0026 0895      		ret
 2127               	.LVL197:
 2128               	.L212:
 2129               		.loc 1 924 1 view .LVU533
 2130 0028 843F      		cpi r24,lo8(-12)
 2131 002a 01F0      		breq .L218
 2132               	.L215:
 910:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2133               		.loc 1 910 20 view .LVU534
 2134 002c 80E0      		ldi r24,0
 2135               	.LVL198:
 910:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 2136               		.loc 1 910 20 view .LVU535
 2137 002e 0895      		ret
 2138               	.LVL199:
 2139               	.L211:
 912:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 2140               		.loc 1 912 13 is_stmt 1 view .LVU536
 2141 0030 803E      		cpi r24,lo8(-32)
 2142 0032 00F0      		brlo .L218
 2143 0034 813F      		cpi r24,lo8(-15)
 2144 0036 01F4      		brne .L215
 2145 0038 00C0      		rjmp .L218
 2146               	.L208:
 920:./tmk_core/common/action.c ****             return false;
 2147               		.loc 1 920 13 view .LVU537
 920:./tmk_core/common/action.c ****             return false;
 2148               		.loc 1 920 16 is_stmt 0 view .LVU538
 2149 003a 93FB      		bst r25,3
 2150 003c 8827      		clr r24
 2151 003e 80F9      		bld r24,0
 2152               	.LVL200:
 920:./tmk_core/common/action.c ****             return false;
 2153               		.loc 1 920 16 view .LVU539
 2154 0040 0895      		ret
 2155               		.cfi_endproc
 2156               	.LFE25:
 2158               		.section	.text.debug_event,"ax",@progbits
 2159               	.global	debug_event
 2161               	debug_event:
 2162               	.LFB26:
 925:./tmk_core/common/action.c **** 
 926:./tmk_core/common/action.c **** 
 927:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 928:./tmk_core/common/action.c ****  *
 929:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:./tmk_core/common/action.c ****  */
 931:./tmk_core/common/action.c **** void debug_event(keyevent_t event)
 932:./tmk_core/common/action.c **** {
 2163               		.loc 1 932 1 is_stmt 1 view -0
 2164               		.cfi_startproc
 2165 0000 CF93      		push r28
 2166               	.LCFI21:
 2167               		.cfi_def_cfa_offset 3
 2168               		.cfi_offset 28, -2
 2169 0002 DF93      		push r29
 2170               	.LCFI22:
 2171               		.cfi_def_cfa_offset 4
 2172               		.cfi_offset 29, -3
 2173 0004 00D0      		rcall .
 2174 0006 00D0      		rcall .
 2175 0008 0F92      		push __tmp_reg__
 2176               	.LCFI23:
 2177               		.cfi_def_cfa_offset 9
 2178 000a CDB7      		in r28,__SP_L__
 2179 000c DEB7      		in r29,__SP_H__
 2180               	.LCFI24:
 2181               		.cfi_def_cfa_register 28
 2182               	/* prologue: function */
 2183               	/* frame size = 5 */
 2184               	/* stack size = 7 */
 2185               	.L__stack_usage = 7
 933:./tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 2186               		.loc 1 933 103 view .LVU541
 2187               	/* epilogue start */
 934:./tmk_core/common/action.c **** }
 2188               		.loc 1 934 1 is_stmt 0 view .LVU542
 2189 000e 0F90      		pop __tmp_reg__
 2190 0010 0F90      		pop __tmp_reg__
 2191 0012 0F90      		pop __tmp_reg__
 2192 0014 0F90      		pop __tmp_reg__
 2193 0016 0F90      		pop __tmp_reg__
 2194 0018 DF91      		pop r29
 2195 001a CF91      		pop r28
 2196 001c 0895      		ret
 2197               		.cfi_endproc
 2198               	.LFE26:
 2200               		.section	.text.debug_record,"ax",@progbits
 2201               	.global	debug_record
 2203               	debug_record:
 2204               	.LFB27:
 935:./tmk_core/common/action.c **** 
 936:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 937:./tmk_core/common/action.c ****  *
 938:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:./tmk_core/common/action.c ****  */
 940:./tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 941:./tmk_core/common/action.c **** {
 2205               		.loc 1 941 1 is_stmt 1 view -0
 2206               		.cfi_startproc
 2207 0000 CF93      		push r28
 2208               	.LCFI25:
 2209               		.cfi_def_cfa_offset 3
 2210               		.cfi_offset 28, -2
 2211 0002 DF93      		push r29
 2212               	.LCFI26:
 2213               		.cfi_def_cfa_offset 4
 2214               		.cfi_offset 29, -3
 2215 0004 00D0      		rcall .
 2216 0006 00D0      		rcall .
 2217 0008 00D0      		rcall .
 2218               	.LCFI27:
 2219               		.cfi_def_cfa_offset 10
 2220 000a CDB7      		in r28,__SP_L__
 2221 000c DEB7      		in r29,__SP_H__
 2222               	.LCFI28:
 2223               		.cfi_def_cfa_register 28
 2224               	/* prologue: function */
 2225               	/* frame size = 6 */
 2226               	/* stack size = 8 */
 2227               	.L__stack_usage = 8
 942:./tmk_core/common/action.c ****     debug_event(record.event);
 2228               		.loc 1 942 5 view .LVU544
 943:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 944:./tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2229               		.loc 1 944 77 view .LVU545
 2230               	/* epilogue start */
 945:./tmk_core/common/action.c **** #endif
 946:./tmk_core/common/action.c **** }
 2231               		.loc 1 946 1 is_stmt 0 view .LVU546
 2232 000e 2696      		adiw r28,6
 2233 0010 0FB6      		in __tmp_reg__,__SREG__
 2234 0012 F894      		cli
 2235 0014 DEBF      		out __SP_H__,r29
 2236 0016 0FBE      		out __SREG__,__tmp_reg__
 2237 0018 CDBF      		out __SP_L__,r28
 2238 001a DF91      		pop r29
 2239 001c CF91      		pop r28
 2240 001e 0895      		ret
 2241               		.cfi_endproc
 2242               	.LFE27:
 2244               		.section	.text.debug_action,"ax",@progbits
 2245               	.global	debug_action
 2247               	debug_action:
 2248               	.LVL201:
 2249               	.LFB28:
 947:./tmk_core/common/action.c **** 
 948:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 949:./tmk_core/common/action.c ****  *
 950:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:./tmk_core/common/action.c ****  */
 952:./tmk_core/common/action.c **** void debug_action(action_t action)
 953:./tmk_core/common/action.c **** {
 2250               		.loc 1 953 1 is_stmt 1 view -0
 2251               		.cfi_startproc
 2252               	/* prologue: function */
 2253               	/* frame size = 0 */
 2254               	/* stack size = 0 */
 2255               	.L__stack_usage = 0
 954:./tmk_core/common/action.c ****     switch (action.kind.id) {
 2256               		.loc 1 954 5 view .LVU548
 955:./tmk_core/common/action.c ****         case ACT_LMODS:             dprint("ACT_LMODS");             break;
 956:./tmk_core/common/action.c ****         case ACT_RMODS:             dprint("ACT_RMODS");             break;
 957:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:         dprint("ACT_LMODS_TAP");         break;
 958:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:         dprint("ACT_RMODS_TAP");         break;
 959:./tmk_core/common/action.c ****         case ACT_USAGE:             dprint("ACT_USAGE");             break;
 960:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:          dprint("ACT_MOUSEKEY");          break;
 961:./tmk_core/common/action.c ****         case ACT_LAYER:             dprint("ACT_LAYER");             break;
 962:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:         dprint("ACT_LAYER_TAP");         break;
 963:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:     dprint("ACT_LAYER_TAP_EXT");     break;
 964:./tmk_core/common/action.c ****         case ACT_MACRO:             dprint("ACT_MACRO");             break;
 965:./tmk_core/common/action.c ****         case ACT_COMMAND:           dprint("ACT_COMMAND");           break;
 966:./tmk_core/common/action.c ****         case ACT_FUNCTION:          dprint("ACT_FUNCTION");          break;
 967:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:        dprint("ACT_SWAP_HANDS");        break;
 968:./tmk_core/common/action.c ****         default:                    dprint("UNKNOWN");               break;
 969:./tmk_core/common/action.c ****     }
 970:./tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param>>8, action.kind.param&0xff);
 2257               		.loc 1 970 71 view .LVU549
 2258               	/* epilogue start */
 971:./tmk_core/common/action.c **** }
 2259               		.loc 1 971 1 is_stmt 0 view .LVU550
 2260 0000 0895      		ret
 2261               		.cfi_endproc
 2262               	.LFE28:
 2264               		.comm	tp_buttons,2,1
 2265               		.text
 2266               	.Letext0:
 2267               		.file 4 "/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/stdint.h"
 2268               		.file 5 "./tmk_core/common/keycode.h"
 2269               		.file 6 "./tmk_core/common/report.h"
 2270               		.file 7 "./tmk_core/common/host.h"
 2271               		.file 8 "./tmk_core/common/mousekey.h"
 2272               		.file 9 "./tmk_core/common/command.h"
 2273               		.file 10 "./tmk_core/common/action_code.h"
 2274               		.file 11 "./tmk_core/common/action.h"
 2275               		.file 12 "./tmk_core/common/action_layer.h"
 2276               		.file 13 "./tmk_core/common/action_util.h"
 2277               		.file 14 "./tmk_core/common/avr/xprintf.h"
 2278               		.file 15 "./tmk_core/common/debug.h"
 2279               		.file 16 "./tmk_core/common/led.h"
 2280               		.file 17 "./tmk_core/common/action_macro.h"
 2281               		.file 18 "./tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:4      *ABS*:000000000000003f __SREG__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:94     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:116    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:141    .text.register_code:0000000000000000 register_code
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:529    .text.unregister_code:0000000000000000 unregister_code
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:687    .text.register_mods:0000000000000000 register_mods
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:716    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:745    .text.process_action:0000000000000000 process_action
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:1877   .text.process_record:0000000000000000 process_record
                            *COM*:0000000000000002 tp_buttons
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:1988   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:2007   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:2049   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:2069   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:2161   .text.debug_event:0000000000000000 debug_event
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:2203   .text.debug_record:0000000000000000 debug_record
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccEPGcqd.s:2247   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
led_set
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
mousekey_on
mousekey_send
mousekey_off
default_layer_and
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
layer_invert
layer_move
layer_clear
set_oneshot_layer
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
mousekey_clear
clear_mods
__do_clear_bss
