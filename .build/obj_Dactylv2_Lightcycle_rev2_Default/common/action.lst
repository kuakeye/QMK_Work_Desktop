   1               		.file	"action.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.action_exec,"ax",@progbits
  11               	.global	action_exec
  13               	action_exec:
  14               	.LFB13:
  15               		.file 1 "./tmk_core/common/action.c"
   1:./tmk_core/common/action.c **** /*
   2:./tmk_core/common/action.c **** Copyright 2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action.c **** 
   4:./tmk_core/common/action.c **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action.c **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action.c **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action.c **** (at your option) any later version.
   8:./tmk_core/common/action.c **** 
   9:./tmk_core/common/action.c **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action.c **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action.c **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action.c **** GNU General Public License for more details.
  13:./tmk_core/common/action.c **** 
  14:./tmk_core/common/action.c **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action.c **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action.c **** */
  17:./tmk_core/common/action.c **** #include "host.h"
  18:./tmk_core/common/action.c **** #include "keycode.h"
  19:./tmk_core/common/action.c **** #include "keyboard.h"
  20:./tmk_core/common/action.c **** #include "mousekey.h"
  21:./tmk_core/common/action.c **** #include "command.h"
  22:./tmk_core/common/action.c **** #include "led.h"
  23:./tmk_core/common/action.c **** #include "backlight.h"
  24:./tmk_core/common/action.c **** #include "action_layer.h"
  25:./tmk_core/common/action.c **** #include "action_tapping.h"
  26:./tmk_core/common/action.c **** #include "action_macro.h"
  27:./tmk_core/common/action.c **** #include "action_util.h"
  28:./tmk_core/common/action.c **** #include "action.h"
  29:./tmk_core/common/action.c **** #include "wait.h"
  30:./tmk_core/common/action.c **** 
  31:./tmk_core/common/action.c **** #ifdef DEBUG_ACTION
  32:./tmk_core/common/action.c **** #include "debug.h"
  33:./tmk_core/common/action.c **** #else
  34:./tmk_core/common/action.c **** #include "nodebug.h"
  35:./tmk_core/common/action.c **** #endif
  36:./tmk_core/common/action.c **** 
  37:./tmk_core/common/action.c **** int tp_buttons;
  38:./tmk_core/common/action.c **** 
  39:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  40:./tmk_core/common/action.c **** int retro_tapping_counter = 0;
  41:./tmk_core/common/action.c **** #endif
  42:./tmk_core/common/action.c **** 
  43:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  44:./tmk_core/common/action.c **** #include <fauxclicky.h>
  45:./tmk_core/common/action.c **** #endif
  46:./tmk_core/common/action.c **** 
  47:./tmk_core/common/action.c **** /** \brief Called to execute an action.
  48:./tmk_core/common/action.c ****  *
  49:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
  50:./tmk_core/common/action.c ****  */
  51:./tmk_core/common/action.c **** void action_exec(keyevent_t event)
  52:./tmk_core/common/action.c **** {
  16               		.loc 1 52 1 view -0
  17               		.cfi_startproc
  18 0000 CF93      		push r28
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 28, -2
  22 0002 DF93      		push r29
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 29, -3
  26 0004 CDB7      		in r28,__SP_L__
  27 0006 DEB7      		in r29,__SP_H__
  28               	.LCFI2:
  29               		.cfi_def_cfa_register 28
  30 0008 2B97      		sbiw r28,11
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 15
  33 000a 0FB6      		in __tmp_reg__,__SREG__
  34 000c F894      		cli
  35 000e DEBF      		out __SP_H__,r29
  36 0010 0FBE      		out __SREG__,__tmp_reg__
  37 0012 CDBF      		out __SP_L__,r28
  38               	/* prologue: function */
  39               	/* frame size = 11 */
  40               	/* stack size = 13 */
  41               	.L__stack_usage = 13
  42 0014 4F83      		std Y+7,r20
  43 0016 5887      		std Y+8,r21
  44 0018 6987      		std Y+9,r22
  45 001a 7A87      		std Y+10,r23
  46 001c 8B87      		std Y+11,r24
  47               	.LVL0:
  53:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  48               		.loc 1 53 5 view .LVU1
  54:./tmk_core/common/action.c ****         dprint("\n---- action_exec: start -----\n");
  55:./tmk_core/common/action.c ****         dprint("EVENT: "); debug_event(event); dprintln();
  49               		.loc 1 55 58 view .LVU2
  56:./tmk_core/common/action.c **** #ifdef RETRO_TAPPING
  57:./tmk_core/common/action.c ****         retro_tapping_counter++;
  58:./tmk_core/common/action.c **** #endif
  59:./tmk_core/common/action.c ****     }
  60:./tmk_core/common/action.c **** 
  61:./tmk_core/common/action.c **** #ifdef FAUXCLICKY_ENABLE
  62:./tmk_core/common/action.c ****     if (IS_PRESSED(event)) {
  63:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_PRESS;
  64:./tmk_core/common/action.c ****     }
  65:./tmk_core/common/action.c ****     if (IS_RELEASED(event)) {
  66:./tmk_core/common/action.c ****         FAUXCLICKY_ACTION_RELEASE;
  67:./tmk_core/common/action.c ****     }
  68:./tmk_core/common/action.c ****     fauxclicky_check();
  69:./tmk_core/common/action.c **** #endif
  70:./tmk_core/common/action.c **** 
  71:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  72:./tmk_core/common/action.c ****     if (!IS_NOEVENT(event)) {
  73:./tmk_core/common/action.c ****         process_hand_swap(&event);
  74:./tmk_core/common/action.c ****     }
  75:./tmk_core/common/action.c **** #endif
  76:./tmk_core/common/action.c **** 
  77:./tmk_core/common/action.c ****     keyrecord_t record = { .event = event };
  50               		.loc 1 77 5 view .LVU3
  51               		.loc 1 77 17 is_stmt 0 view .LVU4
  52 001e 1E82      		std Y+6,__zero_reg__
  53 0020 85E0      		ldi r24,lo8(5)
  54 0022 FE01      		movw r30,r28
  55 0024 3796      		adiw r30,7
  56 0026 DE01      		movw r26,r28
  57 0028 1196      		adiw r26,1
  58               		0:
  59 002a 0190      		ld r0,Z+
  60 002c 0D92      		st X+,r0
  61 002e 8A95      		dec r24
  62 0030 01F4      		brne 0b
  78:./tmk_core/common/action.c **** 
  79:./tmk_core/common/action.c **** #if (defined(ONESHOT_TIMEOUT) && (ONESHOT_TIMEOUT > 0))
  80:./tmk_core/common/action.c ****     if (has_oneshot_layer_timed_out()) {
  81:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
  82:./tmk_core/common/action.c ****     }
  83:./tmk_core/common/action.c ****     if (has_oneshot_mods_timed_out()) {
  84:./tmk_core/common/action.c ****         clear_oneshot_mods();
  85:./tmk_core/common/action.c ****     }
  86:./tmk_core/common/action.c **** #endif
  87:./tmk_core/common/action.c **** 
  88:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
  89:./tmk_core/common/action.c ****     action_tapping_process(record);
  63               		.loc 1 89 5 is_stmt 1 view .LVU5
  64 0032 4981      		ldd r20,Y+1
  65               	.LVL1:
  66               		.loc 1 89 5 is_stmt 0 view .LVU6
  67 0034 5A81      		ldd r21,Y+2
  68               	.LVL2:
  69               		.loc 1 89 5 view .LVU7
  70 0036 6B81      		ldd r22,Y+3
  71 0038 7C81      		ldd r23,Y+4
  72 003a 8D81      		ldd r24,Y+5
  73 003c 9E81      		ldd r25,Y+6
  74               	/* epilogue start */
  90:./tmk_core/common/action.c **** #else
  91:./tmk_core/common/action.c ****     process_record(&record);
  92:./tmk_core/common/action.c ****     if (!IS_NOEVENT(record.event)) {
  93:./tmk_core/common/action.c ****         dprint("processed: "); debug_record(record); dprintln();
  94:./tmk_core/common/action.c ****     }
  95:./tmk_core/common/action.c **** #endif
  96:./tmk_core/common/action.c **** }
  75               		.loc 1 96 1 view .LVU8
  76 003e 2B96      		adiw r28,11
  77 0040 0FB6      		in __tmp_reg__,__SREG__
  78 0042 F894      		cli
  79 0044 DEBF      		out __SP_H__,r29
  80 0046 0FBE      		out __SREG__,__tmp_reg__
  81 0048 CDBF      		out __SP_L__,r28
  82 004a DF91      		pop r29
  83 004c CF91      		pop r28
  89:./tmk_core/common/action.c **** #else
  84               		.loc 1 89 5 view .LVU9
  85 004e 0C94 0000 		jmp action_tapping_process
  86               	.LVL3:
  87               		.cfi_endproc
  88               	.LFE13:
  90               		.section	.text.process_record_quantum,"ax",@progbits
  91               		.weak	process_record_quantum
  93               	process_record_quantum:
  94               	.LVL4:
  95               	.LFB15:
  97:./tmk_core/common/action.c **** 
  98:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
  99:./tmk_core/common/action.c **** bool swap_hands = false;
 100:./tmk_core/common/action.c **** bool swap_held = false;
 101:./tmk_core/common/action.c **** 
 102:./tmk_core/common/action.c **** /** \brief Process Hand Swap
 103:./tmk_core/common/action.c ****  *
 104:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 105:./tmk_core/common/action.c ****  */
 106:./tmk_core/common/action.c **** void process_hand_swap(keyevent_t *event) {
 107:./tmk_core/common/action.c ****     static swap_state_row_t swap_state[MATRIX_ROWS];
 108:./tmk_core/common/action.c **** 
 109:./tmk_core/common/action.c ****     keypos_t pos = event->key;
 110:./tmk_core/common/action.c ****     swap_state_row_t col_bit = (swap_state_row_t)1<<pos.col;
 111:./tmk_core/common/action.c ****     bool do_swap = event->pressed ? swap_hands :
 112:./tmk_core/common/action.c ****                                     swap_state[pos.row] & (col_bit);
 113:./tmk_core/common/action.c **** 
 114:./tmk_core/common/action.c ****     if (do_swap) {
 115:./tmk_core/common/action.c ****         event->key = hand_swap_config[pos.row][pos.col];
 116:./tmk_core/common/action.c ****         swap_state[pos.row] |= col_bit;
 117:./tmk_core/common/action.c ****     } else {
 118:./tmk_core/common/action.c ****         swap_state[pos.row] &= ~(col_bit);
 119:./tmk_core/common/action.c ****     }
 120:./tmk_core/common/action.c **** }
 121:./tmk_core/common/action.c **** #endif
 122:./tmk_core/common/action.c **** 
 123:./tmk_core/common/action.c **** #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 124:./tmk_core/common/action.c **** bool disable_action_cache = false;
 125:./tmk_core/common/action.c **** 
 126:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 127:./tmk_core/common/action.c **** {
 128:./tmk_core/common/action.c ****     disable_action_cache = true;
 129:./tmk_core/common/action.c ****     process_record(record);
 130:./tmk_core/common/action.c ****     disable_action_cache = false;
 131:./tmk_core/common/action.c **** }
 132:./tmk_core/common/action.c **** #else
 133:./tmk_core/common/action.c **** void process_record_nocache(keyrecord_t *record)
 134:./tmk_core/common/action.c **** {
 135:./tmk_core/common/action.c ****     process_record(record);
 136:./tmk_core/common/action.c **** }
 137:./tmk_core/common/action.c **** #endif
 138:./tmk_core/common/action.c **** 
 139:./tmk_core/common/action.c **** __attribute__ ((weak))
 140:./tmk_core/common/action.c **** bool process_record_quantum(keyrecord_t *record) {
  96               		.loc 1 140 50 is_stmt 1 view -0
  97               		.cfi_startproc
  98               	/* prologue: function */
  99               	/* frame size = 0 */
 100               	/* stack size = 0 */
 101               	.L__stack_usage = 0
 141:./tmk_core/common/action.c ****     return true;
 102               		.loc 1 141 5 view .LVU11
 142:./tmk_core/common/action.c **** }
 103               		.loc 1 142 1 is_stmt 0 view .LVU12
 104 0000 81E0      		ldi r24,lo8(1)
 105               	.LVL5:
 106               	/* epilogue start */
 107               		.loc 1 142 1 view .LVU13
 108 0002 0895      		ret
 109               		.cfi_endproc
 110               	.LFE15:
 112               		.section	.text.process_record_tap_hint,"ax",@progbits
 113               	.global	process_record_tap_hint
 115               	process_record_tap_hint:
 116               	.LVL6:
 117               	.LFB16:
 143:./tmk_core/common/action.c **** 
 144:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 145:./tmk_core/common/action.c **** /** \brief Allows for handling tap-hold actions immediately instead of waiting for TAPPING_TERM or 
 146:./tmk_core/common/action.c ****  *
 147:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 148:./tmk_core/common/action.c ****  */
 149:./tmk_core/common/action.c **** void process_record_tap_hint(keyrecord_t *record)
 150:./tmk_core/common/action.c **** {
 118               		.loc 1 150 1 is_stmt 1 view -0
 119               		.cfi_startproc
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 0 */
 123               	.L__stack_usage = 0
 151:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(record->event.key);
 124               		.loc 1 151 5 view .LVU15
 125               		.loc 1 151 23 is_stmt 0 view .LVU16
 126 0000 FC01      		movw r30,r24
 127 0002 8081      		ld r24,Z
 128 0004 9181      		ldd r25,Z+1
 129               	.LVL7:
 130               		.loc 1 151 23 view .LVU17
 131 0006 0C94 0000 		jmp layer_switch_get_action
 132               	.LVL8:
 133               		.loc 1 151 23 view .LVU18
 134               		.cfi_endproc
 135               	.LFE16:
 137               		.section	.text.register_code,"ax",@progbits
 138               	.global	register_code
 140               	register_code:
 141               	.LVL9:
 142               	.LFB19:
 152:./tmk_core/common/action.c **** 
 153:./tmk_core/common/action.c ****     switch (action.kind.id) {
 154:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 155:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 156:./tmk_core/common/action.c ****             switch (action.swap.code) {
 157:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 158:./tmk_core/common/action.c ****                 default:
 159:./tmk_core/common/action.c ****                     swap_hands = !swap_hands;
 160:./tmk_core/common/action.c ****                     swap_held = true;
 161:./tmk_core/common/action.c ****             }
 162:./tmk_core/common/action.c ****             break;
 163:./tmk_core/common/action.c **** #endif
 164:./tmk_core/common/action.c ****     }
 165:./tmk_core/common/action.c **** }
 166:./tmk_core/common/action.c **** #endif
 167:./tmk_core/common/action.c **** 
 168:./tmk_core/common/action.c **** /** \brief Take a key event (key press or key release) and processes it.
 169:./tmk_core/common/action.c ****  *
 170:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 171:./tmk_core/common/action.c ****  */
 172:./tmk_core/common/action.c **** void process_record(keyrecord_t *record)
 173:./tmk_core/common/action.c **** {
 174:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 175:./tmk_core/common/action.c **** 
 176:./tmk_core/common/action.c ****     if(!process_record_quantum(record))
 177:./tmk_core/common/action.c ****         return;
 178:./tmk_core/common/action.c **** 
 179:./tmk_core/common/action.c ****     action_t action = store_or_get_action(record->event.pressed, record->event.key);
 180:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 181:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 182:./tmk_core/common/action.c ****     dprint(" layer_state: "); layer_debug();
 183:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 184:./tmk_core/common/action.c **** #endif
 185:./tmk_core/common/action.c ****     dprintln();
 186:./tmk_core/common/action.c **** 
 187:./tmk_core/common/action.c ****     process_action(record, action);
 188:./tmk_core/common/action.c **** }
 189:./tmk_core/common/action.c **** 
 190:./tmk_core/common/action.c **** /** \brief Take an action and processes it.
 191:./tmk_core/common/action.c ****  *
 192:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 193:./tmk_core/common/action.c ****  */
 194:./tmk_core/common/action.c **** void process_action(keyrecord_t *record, action_t action)
 195:./tmk_core/common/action.c **** {
 196:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 197:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 198:./tmk_core/common/action.c ****     uint8_t tap_count = record->tap.count;
 199:./tmk_core/common/action.c **** #endif
 200:./tmk_core/common/action.c **** 
 201:./tmk_core/common/action.c ****     if (event.pressed) {
 202:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 203:./tmk_core/common/action.c ****         clear_weak_mods();
 204:./tmk_core/common/action.c ****     }
 205:./tmk_core/common/action.c **** 
 206:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 207:./tmk_core/common/action.c ****     bool do_release_oneshot = false;
 208:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 209:./tmk_core/common/action.c ****     if (is_oneshot_layer_active() && event.pressed && !IS_MOD(action.key.code)) {
 210:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 211:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 212:./tmk_core/common/action.c ****     }
 213:./tmk_core/common/action.c **** #endif
 214:./tmk_core/common/action.c **** 
 215:./tmk_core/common/action.c ****     switch (action.kind.id) {
 216:./tmk_core/common/action.c ****         /* Key and Mods */
 217:./tmk_core/common/action.c ****         case ACT_LMODS:
 218:./tmk_core/common/action.c ****         case ACT_RMODS:
 219:./tmk_core/common/action.c ****             {
 220:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS) ?  action.key.mods :
 221:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 222:./tmk_core/common/action.c ****                 if (event.pressed) {
 223:./tmk_core/common/action.c ****                     if (mods) {
 224:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 225:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 226:./tmk_core/common/action.c ****                             // This also makes LSFT(KC_LGUI) behave exactly the same as LGUI(KC_LSF
 227:./tmk_core/common/action.c ****                             // Same applies for some keys like KC_MEH which are declared as MEH(KC_
 228:./tmk_core/common/action.c ****                             add_mods(mods);
 229:./tmk_core/common/action.c ****                         } else {
 230:./tmk_core/common/action.c ****                             add_weak_mods(mods);
 231:./tmk_core/common/action.c ****                         }
 232:./tmk_core/common/action.c ****                         send_keyboard_report();
 233:./tmk_core/common/action.c ****                     }
 234:./tmk_core/common/action.c ****                     register_code(action.key.code);
 235:./tmk_core/common/action.c ****                 } else {
 236:./tmk_core/common/action.c ****                     unregister_code(action.key.code);
 237:./tmk_core/common/action.c ****                     if (mods) {
 238:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 239:./tmk_core/common/action.c ****                             del_mods(mods);
 240:./tmk_core/common/action.c ****                         } else {
 241:./tmk_core/common/action.c ****                             del_weak_mods(mods);
 242:./tmk_core/common/action.c ****                         }
 243:./tmk_core/common/action.c ****                         send_keyboard_report();
 244:./tmk_core/common/action.c ****                     }
 245:./tmk_core/common/action.c ****                 }
 246:./tmk_core/common/action.c ****             }
 247:./tmk_core/common/action.c ****             break;
 248:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 249:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 250:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 251:./tmk_core/common/action.c ****             {
 252:./tmk_core/common/action.c ****                 uint8_t mods = (action.kind.id == ACT_LMODS_TAP) ?  action.key.mods :
 253:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 254:./tmk_core/common/action.c ****                 switch (action.layer_tap.code) {
 255:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 256:./tmk_core/common/action.c ****                     case MODS_ONESHOT:
 257:./tmk_core/common/action.c ****                         // Oneshot modifier
 258:./tmk_core/common/action.c ****                         if (event.pressed) {
 259:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 260:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 261:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 262:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 263:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 264:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 265:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 266:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 267:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Toggling oneshot");
 268:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 269:./tmk_core/common/action.c ****                                 set_oneshot_locked_mods(mods);
 270:./tmk_core/common/action.c ****                                 register_mods(mods);
 271:./tmk_core/common/action.c ****                     #endif
 272:./tmk_core/common/action.c ****                             } else {
 273:./tmk_core/common/action.c ****                                 register_mods(mods | get_oneshot_mods());
 274:./tmk_core/common/action.c ****                             }
 275:./tmk_core/common/action.c ****                         } else {
 276:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 277:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 278:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 279:./tmk_core/common/action.c ****                             } else if (tap_count == 1) {
 280:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 281:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 282:./tmk_core/common/action.c ****                                 if (mods & get_mods()) {
 283:./tmk_core/common/action.c ****                                     clear_oneshot_locked_mods();
 284:./tmk_core/common/action.c ****                                     clear_oneshot_mods();
 285:./tmk_core/common/action.c ****                                     unregister_mods(mods);
 286:./tmk_core/common/action.c ****                                 }
 287:./tmk_core/common/action.c ****                             } else if (tap_count == ONESHOT_TAP_TOGGLE) {
 288:./tmk_core/common/action.c ****                                 // Toggle Oneshot Layer
 289:./tmk_core/common/action.c ****                     #endif
 290:./tmk_core/common/action.c ****                             } else {
 291:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 292:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 293:./tmk_core/common/action.c ****                             }
 294:./tmk_core/common/action.c ****                         }
 295:./tmk_core/common/action.c ****                         break;
 296:./tmk_core/common/action.c ****     #endif
 297:./tmk_core/common/action.c ****                     case MODS_TAP_TOGGLE:
 298:./tmk_core/common/action.c ****                         if (event.pressed) {
 299:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 300:./tmk_core/common/action.c ****                                 register_mods(mods);
 301:./tmk_core/common/action.c ****                             }
 302:./tmk_core/common/action.c ****                         } else {
 303:./tmk_core/common/action.c ****                             if (tap_count < TAPPING_TOGGLE) {
 304:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 305:./tmk_core/common/action.c ****                             }
 306:./tmk_core/common/action.c ****                         }
 307:./tmk_core/common/action.c ****                         break;
 308:./tmk_core/common/action.c ****                     default:
 309:./tmk_core/common/action.c ****                         if (event.pressed) {
 310:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 311:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 312:./tmk_core/common/action.c ****                                 if (record->tap.interrupted) {
 313:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 314:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 315:./tmk_core/common/action.c ****                                     record->tap.count = 0;
 316:./tmk_core/common/action.c ****                                     register_mods(mods);
 317:./tmk_core/common/action.c ****                                 } else
 318:./tmk_core/common/action.c **** #endif
 319:./tmk_core/common/action.c ****                                 {
 320:./tmk_core/common/action.c ****                                     dprint("MODS_TAP: Tap: register_code\n");
 321:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 322:./tmk_core/common/action.c ****                                 }
 323:./tmk_core/common/action.c ****                             } else {
 324:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 325:./tmk_core/common/action.c ****                                 register_mods(mods);
 326:./tmk_core/common/action.c ****                             }
 327:./tmk_core/common/action.c ****                         } else {
 328:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 329:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 330:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 331:./tmk_core/common/action.c ****                             } else {
 332:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: No tap: add_mods\n");
 333:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 334:./tmk_core/common/action.c ****                             }
 335:./tmk_core/common/action.c ****                         }
 336:./tmk_core/common/action.c ****                         break;
 337:./tmk_core/common/action.c ****                 }
 338:./tmk_core/common/action.c ****             }
 339:./tmk_core/common/action.c ****             break;
 340:./tmk_core/common/action.c **** #endif
 341:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 342:./tmk_core/common/action.c ****         /* other HID usage */
 343:./tmk_core/common/action.c ****         case ACT_USAGE:
 344:./tmk_core/common/action.c ****             switch (action.usage.page) {
 345:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 346:./tmk_core/common/action.c ****                     if (event.pressed) {
 347:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 348:./tmk_core/common/action.c ****                     } else {
 349:./tmk_core/common/action.c ****                         host_system_send(0);
 350:./tmk_core/common/action.c ****                     }
 351:./tmk_core/common/action.c ****                     break;
 352:./tmk_core/common/action.c ****                 case PAGE_CONSUMER:
 353:./tmk_core/common/action.c ****                     if (event.pressed) {
 354:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 355:./tmk_core/common/action.c ****                     } else {
 356:./tmk_core/common/action.c ****                         host_consumer_send(0);
 357:./tmk_core/common/action.c ****                     }
 358:./tmk_core/common/action.c ****                     break;
 359:./tmk_core/common/action.c ****             }
 360:./tmk_core/common/action.c ****             break;
 361:./tmk_core/common/action.c **** #endif
 362:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 363:./tmk_core/common/action.c ****         /* Mouse key */
 364:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:
 365:./tmk_core/common/action.c ****             if (event.pressed) {
 366:./tmk_core/common/action.c ****                 switch (action.key.code) {
 367:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 368:./tmk_core/common/action.c ****                         tp_buttons |= (1<<0);
 369:./tmk_core/common/action.c ****                         break;
 370:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 371:./tmk_core/common/action.c ****                         tp_buttons |= (1<<1);
 372:./tmk_core/common/action.c ****                         break;
 373:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 374:./tmk_core/common/action.c ****                         tp_buttons |= (1<<2);
 375:./tmk_core/common/action.c ****                         break;
 376:./tmk_core/common/action.c ****                     default:
 377:./tmk_core/common/action.c ****                         break;
 378:./tmk_core/common/action.c ****                 }
 379:./tmk_core/common/action.c ****                 mousekey_on(action.key.code);
 380:./tmk_core/common/action.c ****                 mousekey_send();
 381:./tmk_core/common/action.c ****             } else {
 382:./tmk_core/common/action.c ****                 switch (action.key.code) {
 383:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 384:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<0);
 385:./tmk_core/common/action.c ****                         break;
 386:./tmk_core/common/action.c ****                     case KC_MS_BTN2:
 387:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<1);
 388:./tmk_core/common/action.c ****                         break;
 389:./tmk_core/common/action.c ****                     case KC_MS_BTN3:
 390:./tmk_core/common/action.c ****                         tp_buttons &= ~(1<<2);
 391:./tmk_core/common/action.c ****                         break;
 392:./tmk_core/common/action.c ****                     default:
 393:./tmk_core/common/action.c ****                         break;
 394:./tmk_core/common/action.c ****                 }
 395:./tmk_core/common/action.c ****                 mousekey_off(action.key.code);
 396:./tmk_core/common/action.c ****                 mousekey_send();
 397:./tmk_core/common/action.c ****             }
 398:./tmk_core/common/action.c ****             break;
 399:./tmk_core/common/action.c **** #endif
 400:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 401:./tmk_core/common/action.c ****         case ACT_LAYER:
 402:./tmk_core/common/action.c ****             if (action.layer_bitop.on == 0) {
 403:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 404:./tmk_core/common/action.c ****                 if (!event.pressed) {
 405:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 406:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 407:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 408:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 409:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 410:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 411:./tmk_core/common/action.c ****                         case OP_BIT_XOR: default_layer_xor(bits | mask); break;
 412:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 413:./tmk_core/common/action.c ****                     }
 414:./tmk_core/common/action.c ****                 }
 415:./tmk_core/common/action.c ****             } else {
 416:./tmk_core/common/action.c ****                 /* Layer Bitwise Operation */
 417:./tmk_core/common/action.c ****                 if (event.pressed ? (action.layer_bitop.on & ON_PRESS) :
 418:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 419:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 420:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 421:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 422:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 423:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 424:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 425:./tmk_core/common/action.c ****                         case OP_BIT_XOR: layer_xor(bits | mask); break;
 426:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 427:./tmk_core/common/action.c ****                     }
 428:./tmk_core/common/action.c ****                 }
 429:./tmk_core/common/action.c ****             }
 430:./tmk_core/common/action.c ****             break;
 431:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 432:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 433:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 434:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 435:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 436:./tmk_core/common/action.c ****                     /* layer On/Off with modifiers(left only) */
 437:./tmk_core/common/action.c ****                     if (event.pressed) {
 438:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 439:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 440:./tmk_core/common/action.c ****                     } else {
 441:./tmk_core/common/action.c ****                         layer_off(action.layer_tap.val);
 442:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 443:./tmk_core/common/action.c ****                     }
 444:./tmk_core/common/action.c ****                     break;
 445:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 446:./tmk_core/common/action.c ****                     /* tap toggle */
 447:./tmk_core/common/action.c ****                     if (event.pressed) {
 448:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 449:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 450:./tmk_core/common/action.c ****                         }
 451:./tmk_core/common/action.c ****                     } else {
 452:./tmk_core/common/action.c ****                         if (tap_count <= TAPPING_TOGGLE) {
 453:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 454:./tmk_core/common/action.c ****                         }
 455:./tmk_core/common/action.c ****                     }
 456:./tmk_core/common/action.c ****                     break;
 457:./tmk_core/common/action.c ****                 case OP_ON_OFF:
 458:./tmk_core/common/action.c ****                     event.pressed ? layer_on(action.layer_tap.val) :
 459:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 460:./tmk_core/common/action.c ****                     break;
 461:./tmk_core/common/action.c ****                 case OP_OFF_ON:
 462:./tmk_core/common/action.c ****                     event.pressed ? layer_off(action.layer_tap.val) :
 463:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 464:./tmk_core/common/action.c ****                     break;
 465:./tmk_core/common/action.c ****                 case OP_SET_CLEAR:
 466:./tmk_core/common/action.c ****                     event.pressed ? layer_move(action.layer_tap.val) :
 467:./tmk_core/common/action.c ****                                     layer_clear();
 468:./tmk_core/common/action.c ****                     break;
 469:./tmk_core/common/action.c ****             #ifndef NO_ACTION_ONESHOT
 470:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 471:./tmk_core/common/action.c ****                     // Oneshot modifier
 472:./tmk_core/common/action.c ****                 #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 473:./tmk_core/common/action.c ****                     do_release_oneshot = false;
 474:./tmk_core/common/action.c ****                     if (event.pressed) {
 475:./tmk_core/common/action.c ****                         del_mods(get_oneshot_locked_mods());
 476:./tmk_core/common/action.c ****                         if (get_oneshot_layer_state() == ONESHOT_TOGGLED) {
 477:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 478:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 479:./tmk_core/common/action.c ****                             break;
 480:./tmk_core/common/action.c ****                         } else if (tap_count < ONESHOT_TAP_TOGGLE) {
 481:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 482:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 483:./tmk_core/common/action.c ****                         }
 484:./tmk_core/common/action.c ****                     } else {
 485:./tmk_core/common/action.c ****                         add_mods(get_oneshot_locked_mods());
 486:./tmk_core/common/action.c ****                         if (tap_count >= ONESHOT_TAP_TOGGLE) {
 487:./tmk_core/common/action.c ****                             reset_oneshot_layer();
 488:./tmk_core/common/action.c ****                             clear_oneshot_locked_mods();
 489:./tmk_core/common/action.c ****                             set_oneshot_layer(action.layer_tap.val, ONESHOT_TOGGLED);
 490:./tmk_core/common/action.c ****                         } else {
 491:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_PRESSED);
 492:./tmk_core/common/action.c ****                         }
 493:./tmk_core/common/action.c ****                     }
 494:./tmk_core/common/action.c ****                 #else
 495:./tmk_core/common/action.c ****                     if (event.pressed) {
 496:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 497:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 498:./tmk_core/common/action.c ****                     } else {
 499:./tmk_core/common/action.c ****                         clear_oneshot_layer_state(ONESHOT_PRESSED);
 500:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 501:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 502:./tmk_core/common/action.c ****                         }
 503:./tmk_core/common/action.c ****                     }
 504:./tmk_core/common/action.c ****                 #endif
 505:./tmk_core/common/action.c ****                     break;
 506:./tmk_core/common/action.c ****             #endif
 507:./tmk_core/common/action.c ****                 default:
 508:./tmk_core/common/action.c ****                     /* tap key */
 509:./tmk_core/common/action.c ****                     if (event.pressed) {
 510:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 511:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 512:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 513:./tmk_core/common/action.c ****                         } else {
 514:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: On on press\n");
 515:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 516:./tmk_core/common/action.c ****                         }
 517:./tmk_core/common/action.c ****                     } else {
 518:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 519:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 520:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 521:./tmk_core/common/action.c ****                                 wait_ms(80);
 522:./tmk_core/common/action.c ****                             }
 523:./tmk_core/common/action.c ****                             unregister_code(action.layer_tap.code);
 524:./tmk_core/common/action.c ****                         } else {
 525:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: No tap: Off on release\n");
 526:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 527:./tmk_core/common/action.c ****                         }
 528:./tmk_core/common/action.c ****                     }
 529:./tmk_core/common/action.c ****                     break;
 530:./tmk_core/common/action.c ****             }
 531:./tmk_core/common/action.c ****             break;
 532:./tmk_core/common/action.c ****     #endif
 533:./tmk_core/common/action.c **** #endif
 534:./tmk_core/common/action.c ****         /* Extentions */
 535:./tmk_core/common/action.c **** #ifndef NO_ACTION_MACRO
 536:./tmk_core/common/action.c ****         case ACT_MACRO:
 537:./tmk_core/common/action.c ****             action_macro_play(action_get_macro(record, action.func.id, action.func.opt));
 538:./tmk_core/common/action.c ****             break;
 539:./tmk_core/common/action.c **** #endif
 540:./tmk_core/common/action.c **** #ifdef BACKLIGHT_ENABLE
 541:./tmk_core/common/action.c ****         case ACT_BACKLIGHT:
 542:./tmk_core/common/action.c ****             if (!event.pressed) {
 543:./tmk_core/common/action.c ****                 switch (action.backlight.opt) {
 544:./tmk_core/common/action.c ****                     case BACKLIGHT_INCREASE:
 545:./tmk_core/common/action.c ****                         backlight_increase();
 546:./tmk_core/common/action.c ****                         break;
 547:./tmk_core/common/action.c ****                     case BACKLIGHT_DECREASE:
 548:./tmk_core/common/action.c ****                         backlight_decrease();
 549:./tmk_core/common/action.c ****                         break;
 550:./tmk_core/common/action.c ****                     case BACKLIGHT_TOGGLE:
 551:./tmk_core/common/action.c ****                         backlight_toggle();
 552:./tmk_core/common/action.c ****                         break;
 553:./tmk_core/common/action.c ****                     case BACKLIGHT_STEP:
 554:./tmk_core/common/action.c ****                         backlight_step();
 555:./tmk_core/common/action.c ****                         break;
 556:./tmk_core/common/action.c ****                     case BACKLIGHT_ON:
 557:./tmk_core/common/action.c ****                         backlight_level(BACKLIGHT_LEVELS);
 558:./tmk_core/common/action.c ****                         break;
 559:./tmk_core/common/action.c ****                     case BACKLIGHT_OFF:
 560:./tmk_core/common/action.c ****                         backlight_level(0);
 561:./tmk_core/common/action.c ****                         break;
 562:./tmk_core/common/action.c ****                 }
 563:./tmk_core/common/action.c ****             }
 564:./tmk_core/common/action.c ****             break;
 565:./tmk_core/common/action.c **** #endif
 566:./tmk_core/common/action.c ****         case ACT_COMMAND:
 567:./tmk_core/common/action.c ****             break;
 568:./tmk_core/common/action.c **** #ifdef SWAP_HANDS_ENABLE
 569:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 570:./tmk_core/common/action.c ****             switch (action.swap.code) {
 571:./tmk_core/common/action.c ****                 case OP_SH_TOGGLE:
 572:./tmk_core/common/action.c ****                     if (event.pressed) {
 573:./tmk_core/common/action.c ****                         swap_hands = !swap_hands;
 574:./tmk_core/common/action.c ****                     }
 575:./tmk_core/common/action.c ****                     break;
 576:./tmk_core/common/action.c ****                 case OP_SH_ON_OFF:
 577:./tmk_core/common/action.c ****                     swap_hands = event.pressed;
 578:./tmk_core/common/action.c ****                     break;
 579:./tmk_core/common/action.c ****                 case OP_SH_OFF_ON:
 580:./tmk_core/common/action.c ****                     swap_hands = !event.pressed;
 581:./tmk_core/common/action.c ****                     break;
 582:./tmk_core/common/action.c ****                 case OP_SH_ON:
 583:./tmk_core/common/action.c ****                     if (!event.pressed) {
 584:./tmk_core/common/action.c ****                         swap_hands = true;
 585:./tmk_core/common/action.c ****                     }
 586:./tmk_core/common/action.c ****                     break;
 587:./tmk_core/common/action.c ****                 case OP_SH_OFF:
 588:./tmk_core/common/action.c ****                     if (!event.pressed) {
 589:./tmk_core/common/action.c ****                         swap_hands = false;
 590:./tmk_core/common/action.c ****                     }
 591:./tmk_core/common/action.c ****                     break;
 592:./tmk_core/common/action.c ****     #ifndef NO_ACTION_TAPPING
 593:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 594:./tmk_core/common/action.c ****                     /* tap toggle */
 595:./tmk_core/common/action.c **** 
 596:./tmk_core/common/action.c ****                     if (event.pressed) {
 597:./tmk_core/common/action.c ****                         if (swap_held) {
 598:./tmk_core/common/action.c ****                             swap_held = false;
 599:./tmk_core/common/action.c ****                         } else {
 600:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 601:./tmk_core/common/action.c ****                         }
 602:./tmk_core/common/action.c ****                     } else {
 603:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 604:./tmk_core/common/action.c ****                             swap_hands = !swap_hands;
 605:./tmk_core/common/action.c ****                         }
 606:./tmk_core/common/action.c ****                     }
 607:./tmk_core/common/action.c ****                     break;
 608:./tmk_core/common/action.c ****                 default:
 609:./tmk_core/common/action.c ****                     /* tap key */
 610:./tmk_core/common/action.c ****                     if (tap_count > 0) {
 611:./tmk_core/common/action.c ****                         if (swap_held) {
 612:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 613:./tmk_core/common/action.c ****                             swap_held = false;
 614:./tmk_core/common/action.c ****                         }
 615:./tmk_core/common/action.c ****                         if (event.pressed) {
 616:./tmk_core/common/action.c ****                             register_code(action.swap.code);
 617:./tmk_core/common/action.c ****                         } else {
 618:./tmk_core/common/action.c ****                             unregister_code(action.swap.code);
 619:./tmk_core/common/action.c ****                             *record = (keyrecord_t){}; // hack: reset tap mode
 620:./tmk_core/common/action.c ****                         }
 621:./tmk_core/common/action.c ****                     } else {
 622:./tmk_core/common/action.c ****                         if (swap_held && !event.pressed) {
 623:./tmk_core/common/action.c ****                             swap_hands = !swap_hands; // undo hold set up in _tap_hint
 624:./tmk_core/common/action.c ****                             swap_held = false;
 625:./tmk_core/common/action.c ****                         }
 626:./tmk_core/common/action.c ****                     }
 627:./tmk_core/common/action.c ****     #endif
 628:./tmk_core/common/action.c ****             }
 629:./tmk_core/common/action.c **** #endif
 630:./tmk_core/common/action.c **** #ifndef NO_ACTION_FUNCTION
 631:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 632:./tmk_core/common/action.c ****             action_function(record, action.func.id, action.func.opt);
 633:./tmk_core/common/action.c ****             break;
 634:./tmk_core/common/action.c **** #endif
 635:./tmk_core/common/action.c ****         default:
 636:./tmk_core/common/action.c ****             break;
 637:./tmk_core/common/action.c ****     }
 638:./tmk_core/common/action.c **** 
 639:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 640:./tmk_core/common/action.c ****     // if this event is a layer action, update the leds
 641:./tmk_core/common/action.c ****     switch (action.kind.id) {
 642:./tmk_core/common/action.c ****         case ACT_LAYER:
 643:./tmk_core/common/action.c ****         #ifndef NO_ACTION_TAPPING
 644:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 645:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 646:./tmk_core/common/action.c ****         #endif
 647:./tmk_core/common/action.c ****             led_set(host_keyboard_leds());
 648:./tmk_core/common/action.c ****             break;
 649:./tmk_core/common/action.c ****         default:
 650:./tmk_core/common/action.c ****             break;
 651:./tmk_core/common/action.c ****     }
 652:./tmk_core/common/action.c **** #endif
 653:./tmk_core/common/action.c **** 
 654:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 655:./tmk_core/common/action.c ****   #ifdef RETRO_TAPPING
 656:./tmk_core/common/action.c ****   if (!is_tap_key(record->event.key)) {
 657:./tmk_core/common/action.c ****     retro_tapping_counter = 0;
 658:./tmk_core/common/action.c ****   } else {
 659:./tmk_core/common/action.c ****     if (event.pressed) {
 660:./tmk_core/common/action.c ****         if (tap_count > 0) {
 661:./tmk_core/common/action.c ****           retro_tapping_counter = 0;
 662:./tmk_core/common/action.c ****         } else {
 663:./tmk_core/common/action.c **** 
 664:./tmk_core/common/action.c ****         }
 665:./tmk_core/common/action.c ****     } else {
 666:./tmk_core/common/action.c ****       if (tap_count > 0) {
 667:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 668:./tmk_core/common/action.c ****       } else {
 669:./tmk_core/common/action.c ****         if (retro_tapping_counter == 2) {
 670:./tmk_core/common/action.c ****           register_code(action.layer_tap.code);
 671:./tmk_core/common/action.c ****           unregister_code(action.layer_tap.code);
 672:./tmk_core/common/action.c ****         }
 673:./tmk_core/common/action.c ****         retro_tapping_counter = 0;
 674:./tmk_core/common/action.c ****       }
 675:./tmk_core/common/action.c ****     }
 676:./tmk_core/common/action.c ****   }
 677:./tmk_core/common/action.c ****   #endif
 678:./tmk_core/common/action.c **** #endif
 679:./tmk_core/common/action.c **** 
 680:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 681:./tmk_core/common/action.c ****     /* Because we switch layers after a oneshot event, we need to release the
 682:./tmk_core/common/action.c ****      * key before we leave the layer or no key up event will be generated.
 683:./tmk_core/common/action.c ****      */
 684:./tmk_core/common/action.c ****     if (do_release_oneshot && !(get_oneshot_layer_state() & ONESHOT_PRESSED )   ) {
 685:./tmk_core/common/action.c ****         record->event.pressed = false;
 686:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 687:./tmk_core/common/action.c ****         process_record(record);
 688:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 689:./tmk_core/common/action.c ****     }
 690:./tmk_core/common/action.c **** #endif
 691:./tmk_core/common/action.c **** }
 692:./tmk_core/common/action.c **** 
 693:./tmk_core/common/action.c **** 
 694:./tmk_core/common/action.c **** 
 695:./tmk_core/common/action.c **** 
 696:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 697:./tmk_core/common/action.c ****  *
 698:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 699:./tmk_core/common/action.c ****  */
 700:./tmk_core/common/action.c **** void register_code(uint8_t code)
 701:./tmk_core/common/action.c **** {
 143               		.loc 1 701 1 is_stmt 1 view -0
 144               		.cfi_startproc
 145               		.loc 1 701 1 is_stmt 0 view .LVU20
 146 0000 CF93      		push r28
 147               	.LCFI4:
 148               		.cfi_def_cfa_offset 3
 149               		.cfi_offset 28, -2
 150               	/* prologue: function */
 151               	/* frame size = 0 */
 152               	/* stack size = 1 */
 153               	.L__stack_usage = 1
 154 0002 C82F      		mov r28,r24
 702:./tmk_core/common/action.c ****     if (code == KC_NO) {
 155               		.loc 1 702 5 is_stmt 1 view .LVU21
 156               		.loc 1 702 8 is_stmt 0 view .LVU22
 157 0004 8823      		tst r24
 158 0006 01F4      		brne .+2
 159 0008 00C0      		rjmp .L4
 703:./tmk_core/common/action.c ****         return;
 704:./tmk_core/common/action.c ****     }
 705:./tmk_core/common/action.c **** 
 706:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 707:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 160               		.loc 1 707 10 is_stmt 1 view .LVU23
 161               		.loc 1 707 13 is_stmt 0 view .LVU24
 162 000a 8238      		cpi r24,lo8(-126)
 163 000c 01F4      		brne .L7
 708:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 709:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is on
 710:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK)) return;
 164               		.loc 1 710 9 is_stmt 1 view .LVU25
 165               		.loc 1 710 13 is_stmt 0 view .LVU26
 166 000e 0E94 0000 		call host_keyboard_leds
 167               	.LVL10:
 168               		.loc 1 710 12 view .LVU27
 169 0012 81FD      		sbrc r24,1
 170 0014 00C0      		rjmp .L4
 711:./tmk_core/common/action.c **** #endif
 712:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 171               		.loc 1 712 9 is_stmt 1 view .LVU28
 172 0016 89E3      		ldi r24,lo8(57)
 173 0018 0E94 0000 		call add_key
 174               	.LVL11:
 713:./tmk_core/common/action.c ****         send_keyboard_report();
 175               		.loc 1 713 9 view .LVU29
 176 001c 0E94 0000 		call send_keyboard_report
 177               	.LVL12:
 714:./tmk_core/common/action.c ****         wait_ms(100);
 178               		.loc 1 714 9 view .LVU30
 179               	.LBB14:
 180               	.LBI14:
 181               		.file 2 "/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** _delay_ms(double __ms)
 182               		.loc 2 166 1 view .LVU31
 183               	.LBB15:
 167:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	double __tmp ;
 184               		.loc 2 168 2 view .LVU32
 169:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 185               		.loc 2 172 2 view .LVU33
 173:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 186               		.loc 2 173 2 view .LVU34
 174:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 187               		.loc 2 174 2 view .LVU35
 175:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 188               		.loc 2 184 3 view .LVU36
 185:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 189               		.loc 2 187 2 view .LVU37
 190 0020 2FEF      		ldi r18,lo8(319999)
 191 0022 81EE      		ldi r24,hi8(319999)
 192 0024 94E0      		ldi r25,hlo8(319999)
 193 0026 2150      	1:	subi r18,1
 194 0028 8040      		sbci r24,0
 195 002a 9040      		sbci r25,0
 196 002c 01F4      		brne 1b
 197 002e 00C0      		rjmp .
 198 0030 0000      		nop
 199               	.LVL13:
 200               		.loc 2 187 2 is_stmt 0 view .LVU38
 201               	.LBE15:
 202               	.LBE14:
 715:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 203               		.loc 1 715 9 is_stmt 1 view .LVU39
 204 0032 89E3      		ldi r24,lo8(57)
 205               	.L39:
 716:./tmk_core/common/action.c ****         send_keyboard_report();
 717:./tmk_core/common/action.c ****     }
 718:./tmk_core/common/action.c **** 
 719:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 720:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 721:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_NUM_LOCK)) return;
 722:./tmk_core/common/action.c **** #endif
 723:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 724:./tmk_core/common/action.c ****         send_keyboard_report();
 725:./tmk_core/common/action.c ****         wait_ms(100);
 726:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 206               		.loc 1 726 9 is_stmt 0 view .LVU40
 207 0034 0E94 0000 		call del_key
 208               	.LVL14:
 209               	.L40:
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 210               		.loc 1 727 9 is_stmt 1 view .LVU41
 211               	/* epilogue start */
 728:./tmk_core/common/action.c ****     }
 729:./tmk_core/common/action.c **** 
 730:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 731:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 732:./tmk_core/common/action.c ****         if (host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK)) return;
 733:./tmk_core/common/action.c **** #endif
 734:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 735:./tmk_core/common/action.c ****         send_keyboard_report();
 736:./tmk_core/common/action.c ****         wait_ms(100);
 737:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 738:./tmk_core/common/action.c ****         send_keyboard_report();
 739:./tmk_core/common/action.c ****     }
 740:./tmk_core/common/action.c **** #endif
 741:./tmk_core/common/action.c **** 
 742:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 743:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 744:./tmk_core/common/action.c ****         if (command_proc(code)) return;
 745:./tmk_core/common/action.c **** 
 746:./tmk_core/common/action.c **** #ifndef NO_ACTION_ONESHOT
 747:./tmk_core/common/action.c **** /* TODO: remove
 748:./tmk_core/common/action.c ****         if (oneshot_state.mods && !oneshot_state.disabled) {
 749:./tmk_core/common/action.c ****             uint8_t tmp_mods = get_mods();
 750:./tmk_core/common/action.c ****             add_mods(oneshot_state.mods);
 751:./tmk_core/common/action.c **** 
 752:./tmk_core/common/action.c ****             add_key(code);
 753:./tmk_core/common/action.c ****             send_keyboard_report();
 754:./tmk_core/common/action.c **** 
 755:./tmk_core/common/action.c ****             set_mods(tmp_mods);
 756:./tmk_core/common/action.c ****             send_keyboard_report();
 757:./tmk_core/common/action.c ****             oneshot_cancel();
 758:./tmk_core/common/action.c ****         } else
 759:./tmk_core/common/action.c **** */
 760:./tmk_core/common/action.c **** #endif
 761:./tmk_core/common/action.c ****         {
 762:./tmk_core/common/action.c ****             add_key(code);
 763:./tmk_core/common/action.c ****             send_keyboard_report();
 764:./tmk_core/common/action.c ****         }
 765:./tmk_core/common/action.c ****     }
 766:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 767:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 768:./tmk_core/common/action.c ****         send_keyboard_report();
 769:./tmk_core/common/action.c ****     }
 770:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 771:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 772:./tmk_core/common/action.c ****     }
 773:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 774:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 775:./tmk_core/common/action.c ****     }
 776:./tmk_core/common/action.c **** }
 212               		.loc 1 776 1 is_stmt 0 view .LVU42
 213 0038 CF91      		pop r28
 727:./tmk_core/common/action.c ****         send_keyboard_report();
 214               		.loc 1 727 9 view .LVU43
 215 003a 0C94 0000 		jmp send_keyboard_report
 216               	.LVL15:
 217               	.L7:
 719:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 218               		.loc 1 719 10 is_stmt 1 view .LVU44
 719:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 219               		.loc 1 719 13 is_stmt 0 view .LVU45
 220 003e 8338      		cpi r24,lo8(-125)
 221 0040 01F4      		brne .L9
 721:./tmk_core/common/action.c **** #endif
 222               		.loc 1 721 9 is_stmt 1 view .LVU46
 721:./tmk_core/common/action.c **** #endif
 223               		.loc 1 721 13 is_stmt 0 view .LVU47
 224 0042 0E94 0000 		call host_keyboard_leds
 225               	.LVL16:
 721:./tmk_core/common/action.c **** #endif
 226               		.loc 1 721 12 view .LVU48
 227 0046 80FD      		sbrc r24,0
 228 0048 00C0      		rjmp .L4
 723:./tmk_core/common/action.c ****         send_keyboard_report();
 229               		.loc 1 723 9 is_stmt 1 view .LVU49
 230 004a 83E5      		ldi r24,lo8(83)
 231 004c 0E94 0000 		call add_key
 232               	.LVL17:
 724:./tmk_core/common/action.c ****         wait_ms(100);
 233               		.loc 1 724 9 view .LVU50
 234 0050 0E94 0000 		call send_keyboard_report
 235               	.LVL18:
 725:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 236               		.loc 1 725 9 view .LVU51
 237               	.LBB16:
 238               	.LBI16:
 166:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** {
 239               		.loc 2 166 1 view .LVU52
 240               	.LBB17:
 168:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 241               		.loc 2 168 2 view .LVU53
 172:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 242               		.loc 2 172 2 view .LVU54
 173:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 243               		.loc 2 173 2 view .LVU55
 174:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 244               		.loc 2 174 2 view .LVU56
 184:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#endif
 245               		.loc 2 184 3 view .LVU57
 246               		.loc 2 187 2 view .LVU58
 247 0054 2FEF      		ldi r18,lo8(319999)
 248 0056 81EE      		ldi r24,hi8(319999)
 249 0058 94E0      		ldi r25,hlo8(319999)
 250 005a 2150      	1:	subi r18,1
 251 005c 8040      		sbci r24,0
 252 005e 9040      		sbci r25,0
 253 0060 01F4      		brne 1b
 254 0062 00C0      		rjmp .
 255 0064 0000      		nop
 256               	.LVL19:
 257               		.loc 2 187 2 is_stmt 0 view .LVU59
 258               	.LBE17:
 259               	.LBE16:
 726:./tmk_core/common/action.c ****         send_keyboard_report();
 260               		.loc 1 726 9 is_stmt 1 view .LVU60
 261 0066 83E5      		ldi r24,lo8(83)
 262 0068 00C0      		rjmp .L39
 263               	.LVL20:
 264               	.L9:
 730:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 265               		.loc 1 730 10 view .LVU61
 730:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 266               		.loc 1 730 13 is_stmt 0 view .LVU62
 267 006a 8438      		cpi r24,lo8(-124)
 268 006c 01F4      		brne .L10
 732:./tmk_core/common/action.c **** #endif
 269               		.loc 1 732 9 is_stmt 1 view .LVU63
 732:./tmk_core/common/action.c **** #endif
 270               		.loc 1 732 13 is_stmt 0 view .LVU64
 271 006e 0E94 0000 		call host_keyboard_leds
 272               	.LVL21:
 732:./tmk_core/common/action.c **** #endif
 273               		.loc 1 732 12 view .LVU65
 274 0072 82FD      		sbrc r24,2
 275 0074 00C0      		rjmp .L4
 734:./tmk_core/common/action.c ****         send_keyboard_report();
 276               		.loc 1 734 9 is_stmt 1 view .LVU66
 277 0076 87E4      		ldi r24,lo8(71)
 278 0078 0E94 0000 		call add_key
 279               	.LVL22:
 735:./tmk_core/common/action.c ****         wait_ms(100);
 280               		.loc 1 735 9 view .LVU67
 281 007c 0E94 0000 		call send_keyboard_report
 282               	.LVL23:
 736:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 283               		.loc 1 736 9 view .LVU68
 284               	.LBB18:
 285               	.LBI18:
 166:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** {
 286               		.loc 2 166 1 view .LVU69
 287               	.LBB19:
 168:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 288               		.loc 2 168 2 view .LVU70
 172:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 289               		.loc 2 172 2 view .LVU71
 173:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 290               		.loc 2 173 2 view .LVU72
 174:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 291               		.loc 2 174 2 view .LVU73
 184:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#endif
 292               		.loc 2 184 3 view .LVU74
 293               		.loc 2 187 2 view .LVU75
 294 0080 2FEF      		ldi r18,lo8(319999)
 295 0082 81EE      		ldi r24,hi8(319999)
 296 0084 94E0      		ldi r25,hlo8(319999)
 297 0086 2150      	1:	subi r18,1
 298 0088 8040      		sbci r24,0
 299 008a 9040      		sbci r25,0
 300 008c 01F4      		brne 1b
 301 008e 00C0      		rjmp .
 302 0090 0000      		nop
 303               	.LVL24:
 304               		.loc 2 187 2 is_stmt 0 view .LVU76
 305               	.LBE19:
 306               	.LBE18:
 737:./tmk_core/common/action.c ****         send_keyboard_report();
 307               		.loc 1 737 9 is_stmt 1 view .LVU77
 308 0092 87E4      		ldi r24,lo8(71)
 309 0094 00C0      		rjmp .L39
 310               	.LVL25:
 311               	.L10:
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 312               		.loc 1 742 10 view .LVU78
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 313               		.loc 1 742 13 is_stmt 0 view .LVU79
 314 0096 8CEF      		ldi r24,lo8(-4)
 315               	.LVL26:
 742:./tmk_core/common/action.c ****         // TODO: should push command_proc out of this block?
 316               		.loc 1 742 13 view .LVU80
 317 0098 8C0F      		add r24,r28
 318 009a 813A      		cpi r24,lo8(-95)
 319 009c 00F4      		brsh .L11
 744:./tmk_core/common/action.c **** 
 320               		.loc 1 744 9 is_stmt 1 view .LVU81
 744:./tmk_core/common/action.c **** 
 321               		.loc 1 744 13 is_stmt 0 view .LVU82
 322 009e 8C2F      		mov r24,r28
 323 00a0 0E94 0000 		call command_proc
 324               	.LVL27:
 744:./tmk_core/common/action.c **** 
 325               		.loc 1 744 12 view .LVU83
 326 00a4 8111      		cpse r24,__zero_reg__
 327 00a6 00C0      		rjmp .L4
 762:./tmk_core/common/action.c ****             send_keyboard_report();
 328               		.loc 1 762 13 is_stmt 1 view .LVU84
 329 00a8 8C2F      		mov r24,r28
 330 00aa 0E94 0000 		call add_key
 331               	.LVL28:
 763:./tmk_core/common/action.c ****         }
 332               		.loc 1 763 13 view .LVU85
 333 00ae 00C0      		rjmp .L40
 334               	.L11:
 766:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 335               		.loc 1 766 10 view .LVU86
 766:./tmk_core/common/action.c ****         add_mods(MOD_BIT(code));
 336               		.loc 1 766 13 is_stmt 0 view .LVU87
 337 00b0 80E2      		ldi r24,lo8(32)
 338 00b2 8C0F      		add r24,r28
 339 00b4 8830      		cpi r24,lo8(8)
 340 00b6 00F4      		brsh .L12
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 341               		.loc 1 767 9 is_stmt 1 view .LVU88
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 342               		.loc 1 767 18 is_stmt 0 view .LVU89
 343 00b8 C770      		andi r28,lo8(7)
 344               	.LVL29:
 767:./tmk_core/common/action.c ****         send_keyboard_report();
 345               		.loc 1 767 9 view .LVU90
 346 00ba 81E0      		ldi r24,lo8(1)
 347 00bc 00C0      		rjmp 2f
 348               		1:
 349 00be 880F      		lsl r24
 350               		2:
 351 00c0 CA95      		dec r28
 352 00c2 02F4      		brpl 1b
 353 00c4 0E94 0000 		call add_mods
 354               	.LVL30:
 768:./tmk_core/common/action.c ****     }
 355               		.loc 1 768 9 is_stmt 1 view .LVU91
 356 00c8 00C0      		rjmp .L40
 357               	.LVL31:
 358               	.L12:
 770:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 359               		.loc 1 770 10 view .LVU92
 770:./tmk_core/common/action.c ****         host_system_send(KEYCODE2SYSTEM(code));
 360               		.loc 1 770 13 is_stmt 0 view .LVU93
 361 00ca 8BE5      		ldi r24,lo8(91)
 362 00cc 8C0F      		add r24,r28
 363 00ce 8330      		cpi r24,lo8(3)
 364 00d0 00F4      		brsh .L13
 771:./tmk_core/common/action.c ****     }
 365               		.loc 1 771 9 is_stmt 1 view .LVU94
 366 00d2 81E8      		ldi r24,lo8(-127)
 367 00d4 90E0      		ldi r25,0
 368 00d6 C53A      		cpi r28,lo8(-91)
 369 00d8 01F0      		breq .L14
 771:./tmk_core/common/action.c ****     }
 370               		.loc 1 771 26 is_stmt 0 discriminator 1 view .LVU95
 371 00da 83E8      		ldi r24,lo8(-125)
 372 00dc 90E0      		ldi r25,0
 373 00de C63A      		cpi r28,lo8(-90)
 374 00e0 01F4      		brne .L14
 771:./tmk_core/common/action.c ****     }
 375               		.loc 1 771 26 view .LVU96
 376 00e2 82E8      		ldi r24,lo8(-126)
 377 00e4 90E0      		ldi r25,0
 378               	.L14:
 379               	/* epilogue start */
 380               		.loc 1 776 1 discriminator 12 view .LVU97
 381 00e6 CF91      		pop r28
 382               	.LVL32:
 771:./tmk_core/common/action.c ****     }
 383               		.loc 1 771 9 discriminator 12 view .LVU98
 384 00e8 0C94 0000 		jmp host_system_send
 385               	.LVL33:
 386               	.L13:
 773:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 387               		.loc 1 773 10 is_stmt 1 view .LVU99
 773:./tmk_core/common/action.c ****         host_consumer_send(KEYCODE2CONSUMER(code));
 388               		.loc 1 773 13 is_stmt 0 view .LVU100
 389 00ec 88E5      		ldi r24,lo8(88)
 390 00ee 8C0F      		add r24,r28
 391 00f0 8531      		cpi r24,lo8(21)
 392 00f2 00F0      		brlo .+2
 393 00f4 00C0      		rjmp .L4
 774:./tmk_core/common/action.c ****     }
 394               		.loc 1 774 9 is_stmt 1 view .LVU101
 395 00f6 82EE      		ldi r24,lo8(-30)
 396 00f8 90E0      		ldi r25,0
 397 00fa C83A      		cpi r28,lo8(-88)
 398 00fc 01F4      		brne .+2
 399 00fe 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 400               		.loc 1 774 28 is_stmt 0 discriminator 1 view .LVU102
 401 0100 89EE      		ldi r24,lo8(-23)
 402 0102 90E0      		ldi r25,0
 403 0104 C93A      		cpi r28,lo8(-87)
 404 0106 01F4      		brne .+2
 405 0108 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 406               		.loc 1 774 28 discriminator 3 view .LVU103
 407 010a 8AEE      		ldi r24,lo8(-22)
 408 010c 90E0      		ldi r25,0
 409 010e CA3A      		cpi r28,lo8(-86)
 410 0110 01F4      		brne .+2
 411 0112 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 412               		.loc 1 774 28 discriminator 5 view .LVU104
 413 0114 85EB      		ldi r24,lo8(-75)
 414 0116 90E0      		ldi r25,0
 415 0118 CB3A      		cpi r28,lo8(-85)
 416 011a 01F4      		brne .+2
 417 011c 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 418               		.loc 1 774 28 discriminator 7 view .LVU105
 419 011e 86EB      		ldi r24,lo8(-74)
 420 0120 90E0      		ldi r25,0
 421 0122 CC3A      		cpi r28,lo8(-84)
 422 0124 01F4      		brne .+2
 423 0126 00C0      		rjmp .L15
 774:./tmk_core/common/action.c ****     }
 424               		.loc 1 774 28 discriminator 9 view .LVU106
 425 0128 83EB      		ldi r24,lo8(-77)
 426 012a 90E0      		ldi r25,0
 427 012c CB3B      		cpi r28,lo8(-69)
 428 012e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 429               		.loc 1 774 28 discriminator 11 view .LVU107
 430 0130 84EB      		ldi r24,lo8(-76)
 431 0132 90E0      		ldi r25,0
 432 0134 CC3B      		cpi r28,lo8(-68)
 433 0136 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 434               		.loc 1 774 28 discriminator 13 view .LVU108
 435 0138 87EB      		ldi r24,lo8(-73)
 436 013a 90E0      		ldi r25,0
 437 013c CD3A      		cpi r28,lo8(-83)
 438 013e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 439               		.loc 1 774 28 discriminator 15 view .LVU109
 440 0140 8CEC      		ldi r24,lo8(-52)
 441 0142 90E0      		ldi r25,0
 442 0144 C03B      		cpi r28,lo8(-80)
 443 0146 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 444               		.loc 1 774 28 discriminator 17 view .LVU110
 445 0148 8DEC      		ldi r24,lo8(-51)
 446 014a 90E0      		ldi r25,0
 447 014c CE3A      		cpi r28,lo8(-82)
 448 014e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 449               		.loc 1 774 28 discriminator 19 view .LVU111
 450 0150 83E8      		ldi r24,lo8(-125)
 451 0152 91E0      		ldi r25,lo8(1)
 452 0154 CF3A      		cpi r28,lo8(-81)
 453 0156 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 454               		.loc 1 774 28 discriminator 21 view .LVU112
 455 0158 8AE8      		ldi r24,lo8(-118)
 456 015a 91E0      		ldi r25,lo8(1)
 457 015c C13B      		cpi r28,lo8(-79)
 458 015e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 459               		.loc 1 774 28 discriminator 23 view .LVU113
 460 0160 82E9      		ldi r24,lo8(-110)
 461 0162 91E0      		ldi r25,lo8(1)
 462 0164 C23B      		cpi r28,lo8(-78)
 463 0166 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 464               		.loc 1 774 28 discriminator 25 view .LVU114
 465 0168 84E9      		ldi r24,lo8(-108)
 466 016a 91E0      		ldi r25,lo8(1)
 467 016c C33B      		cpi r28,lo8(-77)
 468 016e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 469               		.loc 1 774 28 discriminator 27 view .LVU115
 470 0170 81E2      		ldi r24,lo8(33)
 471 0172 92E0      		ldi r25,lo8(2)
 472 0174 C43B      		cpi r28,lo8(-76)
 473 0176 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 474               		.loc 1 774 28 discriminator 29 view .LVU116
 475 0178 83E2      		ldi r24,lo8(35)
 476 017a 92E0      		ldi r25,lo8(2)
 477 017c C53B      		cpi r28,lo8(-75)
 478 017e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 479               		.loc 1 774 28 discriminator 31 view .LVU117
 480 0180 84E2      		ldi r24,lo8(36)
 481 0182 92E0      		ldi r25,lo8(2)
 482 0184 C63B      		cpi r28,lo8(-74)
 483 0186 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 484               		.loc 1 774 28 discriminator 33 view .LVU118
 485 0188 85E2      		ldi r24,lo8(37)
 486 018a 92E0      		ldi r25,lo8(2)
 487 018c C73B      		cpi r28,lo8(-73)
 488 018e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 489               		.loc 1 774 28 discriminator 35 view .LVU119
 490 0190 86E2      		ldi r24,lo8(38)
 491 0192 92E0      		ldi r25,lo8(2)
 492 0194 C83B      		cpi r28,lo8(-72)
 493 0196 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 494               		.loc 1 774 28 discriminator 37 view .LVU120
 495 0198 87E2      		ldi r24,lo8(39)
 496 019a 92E0      		ldi r25,lo8(2)
 497 019c C93B      		cpi r28,lo8(-71)
 498 019e 01F0      		breq .L15
 774:./tmk_core/common/action.c ****     }
 499               		.loc 1 774 28 discriminator 39 view .LVU121
 500 01a0 90E0      		ldi r25,0
 501 01a2 80E0      		ldi r24,0
 502 01a4 CA3B      		cpi r28,lo8(-70)
 503 01a6 01F4      		brne .L15
 774:./tmk_core/common/action.c ****     }
 504               		.loc 1 774 28 view .LVU122
 505 01a8 8AE2      		ldi r24,lo8(42)
 506 01aa 92E0      		ldi r25,lo8(2)
 507               	.L15:
 508               	/* epilogue start */
 509               		.loc 1 776 1 discriminator 84 view .LVU123
 510 01ac CF91      		pop r28
 511               	.LVL34:
 774:./tmk_core/common/action.c ****     }
 512               		.loc 1 774 9 discriminator 84 view .LVU124
 513 01ae 0C94 0000 		jmp host_consumer_send
 514               	.LVL35:
 515               	.L4:
 516               	/* epilogue start */
 517               		.loc 1 776 1 view .LVU125
 518 01b2 CF91      		pop r28
 519               	.LVL36:
 520               		.loc 1 776 1 view .LVU126
 521 01b4 0895      		ret
 522               		.cfi_endproc
 523               	.LFE19:
 525               		.section	.text.unregister_code,"ax",@progbits
 526               	.global	unregister_code
 528               	unregister_code:
 529               	.LVL37:
 530               	.LFB20:
 777:./tmk_core/common/action.c **** 
 778:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 779:./tmk_core/common/action.c ****  *
 780:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 781:./tmk_core/common/action.c ****  */
 782:./tmk_core/common/action.c **** void unregister_code(uint8_t code)
 783:./tmk_core/common/action.c **** {
 531               		.loc 1 783 1 is_stmt 1 view -0
 532               		.cfi_startproc
 533               	/* prologue: function */
 534               	/* frame size = 0 */
 535               	/* stack size = 0 */
 536               	.L__stack_usage = 0
 784:./tmk_core/common/action.c ****     if (code == KC_NO) {
 537               		.loc 1 784 5 view .LVU128
 538               		.loc 1 784 8 is_stmt 0 view .LVU129
 539 0000 8823      		tst r24
 540 0002 01F4      		brne .+2
 541 0004 00C0      		rjmp .L41
 785:./tmk_core/common/action.c ****         return;
 786:./tmk_core/common/action.c ****     }
 787:./tmk_core/common/action.c **** 
 788:./tmk_core/common/action.c **** #ifdef LOCKING_SUPPORT_ENABLE
 789:./tmk_core/common/action.c ****     else if (KC_LOCKING_CAPS == code) {
 542               		.loc 1 789 10 is_stmt 1 view .LVU130
 543               		.loc 1 789 13 is_stmt 0 view .LVU131
 544 0006 8238      		cpi r24,lo8(-126)
 545 0008 01F4      		brne .L44
 790:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 791:./tmk_core/common/action.c ****         // Resync: ignore if caps lock already is off
 792:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_CAPS_LOCK))) return;
 546               		.loc 1 792 9 is_stmt 1 view .LVU132
 547               		.loc 1 792 15 is_stmt 0 view .LVU133
 548 000a 0E94 0000 		call host_keyboard_leds
 549               	.LVL38:
 550               		.loc 1 792 12 view .LVU134
 551 000e 81FF      		sbrs r24,1
 552 0010 00C0      		rjmp .L41
 793:./tmk_core/common/action.c **** #endif
 794:./tmk_core/common/action.c ****         add_key(KC_CAPSLOCK);
 553               		.loc 1 794 9 is_stmt 1 view .LVU135
 554 0012 89E3      		ldi r24,lo8(57)
 555 0014 0E94 0000 		call add_key
 556               	.LVL39:
 795:./tmk_core/common/action.c ****         send_keyboard_report();
 557               		.loc 1 795 9 view .LVU136
 558 0018 0E94 0000 		call send_keyboard_report
 559               	.LVL40:
 796:./tmk_core/common/action.c ****         del_key(KC_CAPSLOCK);
 560               		.loc 1 796 9 view .LVU137
 561 001c 89E3      		ldi r24,lo8(57)
 562               	.L60:
 797:./tmk_core/common/action.c ****         send_keyboard_report();
 798:./tmk_core/common/action.c ****     }
 799:./tmk_core/common/action.c **** 
 800:./tmk_core/common/action.c ****     else if (KC_LOCKING_NUM == code) {
 801:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 802:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_NUM_LOCK))) return;
 803:./tmk_core/common/action.c **** #endif
 804:./tmk_core/common/action.c ****         add_key(KC_NUMLOCK);
 805:./tmk_core/common/action.c ****         send_keyboard_report();
 806:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 563               		.loc 1 806 9 is_stmt 0 view .LVU138
 564 001e 0E94 0000 		call del_key
 565               	.LVL41:
 566               	.L61:
 807:./tmk_core/common/action.c ****         send_keyboard_report();
 567               		.loc 1 807 9 is_stmt 1 view .LVU139
 568 0022 0C94 0000 		jmp send_keyboard_report
 569               	.LVL42:
 570               	.L44:
 800:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 571               		.loc 1 800 10 view .LVU140
 800:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 572               		.loc 1 800 13 is_stmt 0 view .LVU141
 573 0026 8338      		cpi r24,lo8(-125)
 574 0028 01F4      		brne .L46
 802:./tmk_core/common/action.c **** #endif
 575               		.loc 1 802 9 is_stmt 1 view .LVU142
 802:./tmk_core/common/action.c **** #endif
 576               		.loc 1 802 15 is_stmt 0 view .LVU143
 577 002a 0E94 0000 		call host_keyboard_leds
 578               	.LVL43:
 802:./tmk_core/common/action.c **** #endif
 579               		.loc 1 802 12 view .LVU144
 580 002e 80FF      		sbrs r24,0
 581 0030 00C0      		rjmp .L41
 804:./tmk_core/common/action.c ****         send_keyboard_report();
 582               		.loc 1 804 9 is_stmt 1 view .LVU145
 583 0032 83E5      		ldi r24,lo8(83)
 584 0034 0E94 0000 		call add_key
 585               	.LVL44:
 805:./tmk_core/common/action.c ****         del_key(KC_NUMLOCK);
 586               		.loc 1 805 9 view .LVU146
 587 0038 0E94 0000 		call send_keyboard_report
 588               	.LVL45:
 806:./tmk_core/common/action.c ****         send_keyboard_report();
 589               		.loc 1 806 9 view .LVU147
 590 003c 83E5      		ldi r24,lo8(83)
 591 003e 00C0      		rjmp .L60
 592               	.LVL46:
 593               	.L46:
 808:./tmk_core/common/action.c ****     }
 809:./tmk_core/common/action.c **** 
 810:./tmk_core/common/action.c ****     else if (KC_LOCKING_SCROLL == code) {
 594               		.loc 1 810 10 view .LVU148
 595               		.loc 1 810 13 is_stmt 0 view .LVU149
 596 0040 8438      		cpi r24,lo8(-124)
 597 0042 01F4      		brne .L47
 811:./tmk_core/common/action.c **** #ifdef LOCKING_RESYNC_ENABLE
 812:./tmk_core/common/action.c ****         if (!(host_keyboard_leds() & (1<<USB_LED_SCROLL_LOCK))) return;
 598               		.loc 1 812 9 is_stmt 1 view .LVU150
 599               		.loc 1 812 15 is_stmt 0 view .LVU151
 600 0044 0E94 0000 		call host_keyboard_leds
 601               	.LVL47:
 602               		.loc 1 812 12 view .LVU152
 603 0048 82FF      		sbrs r24,2
 604 004a 00C0      		rjmp .L41
 813:./tmk_core/common/action.c **** #endif
 814:./tmk_core/common/action.c ****         add_key(KC_SCROLLLOCK);
 605               		.loc 1 814 9 is_stmt 1 view .LVU153
 606 004c 87E4      		ldi r24,lo8(71)
 607 004e 0E94 0000 		call add_key
 608               	.LVL48:
 815:./tmk_core/common/action.c ****         send_keyboard_report();
 609               		.loc 1 815 9 view .LVU154
 610 0052 0E94 0000 		call send_keyboard_report
 611               	.LVL49:
 816:./tmk_core/common/action.c ****         del_key(KC_SCROLLLOCK);
 612               		.loc 1 816 9 view .LVU155
 613 0056 87E4      		ldi r24,lo8(71)
 614 0058 00C0      		rjmp .L60
 615               	.LVL50:
 616               	.L47:
 817:./tmk_core/common/action.c ****         send_keyboard_report();
 818:./tmk_core/common/action.c ****     }
 819:./tmk_core/common/action.c **** #endif
 820:./tmk_core/common/action.c **** 
 821:./tmk_core/common/action.c ****     else if IS_KEY(code) {
 617               		.loc 1 821 10 view .LVU156
 618               		.loc 1 821 13 is_stmt 0 view .LVU157
 619 005a 9CEF      		ldi r25,lo8(-4)
 620 005c 980F      		add r25,r24
 621 005e 913A      		cpi r25,lo8(-95)
 622 0060 00F0      		brlo .L60
 822:./tmk_core/common/action.c ****         del_key(code);
 823:./tmk_core/common/action.c ****         send_keyboard_report();
 824:./tmk_core/common/action.c ****     }
 825:./tmk_core/common/action.c ****     else if IS_MOD(code) {
 623               		.loc 1 825 10 is_stmt 1 view .LVU158
 624               		.loc 1 825 13 is_stmt 0 view .LVU159
 625 0062 90E2      		ldi r25,lo8(32)
 626 0064 980F      		add r25,r24
 627 0066 9830      		cpi r25,lo8(8)
 628 0068 00F4      		brsh .L49
 826:./tmk_core/common/action.c ****         del_mods(MOD_BIT(code));
 629               		.loc 1 826 9 is_stmt 1 view .LVU160
 630               		.loc 1 826 18 is_stmt 0 view .LVU161
 631 006a 8770      		andi r24,lo8(7)
 632               	.LVL51:
 633               		.loc 1 826 9 view .LVU162
 634 006c 91E0      		ldi r25,lo8(1)
 635 006e 00C0      		rjmp 2f
 636               		1:
 637 0070 990F      		lsl r25
 638               		2:
 639 0072 8A95      		dec r24
 640 0074 02F4      		brpl 1b
 641 0076 892F      		mov r24,r25
 642 0078 0E94 0000 		call del_mods
 643               	.LVL52:
 827:./tmk_core/common/action.c ****         send_keyboard_report();
 644               		.loc 1 827 9 is_stmt 1 view .LVU163
 645 007c 00C0      		rjmp .L61
 646               	.LVL53:
 647               	.L49:
 828:./tmk_core/common/action.c ****     }
 829:./tmk_core/common/action.c ****     else if IS_SYSTEM(code) {
 648               		.loc 1 829 10 view .LVU164
 649               		.loc 1 829 13 is_stmt 0 view .LVU165
 650 007e 9BE5      		ldi r25,lo8(91)
 651 0080 980F      		add r25,r24
 652 0082 9330      		cpi r25,lo8(3)
 653 0084 00F4      		brsh .L50
 830:./tmk_core/common/action.c ****         host_system_send(0);
 654               		.loc 1 830 9 is_stmt 1 view .LVU166
 655 0086 90E0      		ldi r25,0
 656 0088 80E0      		ldi r24,0
 657               	.LVL54:
 658               		.loc 1 830 9 is_stmt 0 view .LVU167
 659 008a 0C94 0000 		jmp host_system_send
 660               	.LVL55:
 661               	.L50:
 831:./tmk_core/common/action.c ****     }
 832:./tmk_core/common/action.c ****     else if IS_CONSUMER(code) {
 662               		.loc 1 832 10 is_stmt 1 view .LVU168
 663               		.loc 1 832 13 is_stmt 0 view .LVU169
 664 008e 885A      		subi r24,lo8(-(88))
 665               	.LVL56:
 666               		.loc 1 832 13 view .LVU170
 667 0090 8531      		cpi r24,lo8(21)
 668 0092 00F4      		brsh .L41
 833:./tmk_core/common/action.c ****         host_consumer_send(0);
 669               		.loc 1 833 9 is_stmt 1 view .LVU171
 670 0094 90E0      		ldi r25,0
 671 0096 80E0      		ldi r24,0
 672               	.LVL57:
 673               		.loc 1 833 9 is_stmt 0 view .LVU172
 674 0098 0C94 0000 		jmp host_consumer_send
 675               	.LVL58:
 676               	.L41:
 677               	/* epilogue start */
 834:./tmk_core/common/action.c ****     }
 835:./tmk_core/common/action.c **** }
 678               		.loc 1 835 1 view .LVU173
 679 009c 0895      		ret
 680               		.cfi_endproc
 681               	.LFE20:
 683               		.section	.text.register_mods,"ax",@progbits
 684               	.global	register_mods
 686               	register_mods:
 687               	.LVL59:
 688               	.LFB21:
 836:./tmk_core/common/action.c **** 
 837:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 838:./tmk_core/common/action.c ****  *
 839:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 840:./tmk_core/common/action.c ****  */
 841:./tmk_core/common/action.c **** void register_mods(uint8_t mods)
 842:./tmk_core/common/action.c **** {
 689               		.loc 1 842 1 is_stmt 1 view -0
 690               		.cfi_startproc
 691               	/* prologue: function */
 692               	/* frame size = 0 */
 693               	/* stack size = 0 */
 694               	.L__stack_usage = 0
 843:./tmk_core/common/action.c ****     if (mods) {
 695               		.loc 1 843 5 view .LVU175
 696               		.loc 1 843 8 is_stmt 0 view .LVU176
 697 0000 8823      		tst r24
 698 0002 01F0      		breq .L62
 844:./tmk_core/common/action.c ****         add_mods(mods);
 699               		.loc 1 844 9 is_stmt 1 view .LVU177
 700 0004 0E94 0000 		call add_mods
 701               	.LVL60:
 845:./tmk_core/common/action.c ****         send_keyboard_report();
 702               		.loc 1 845 9 view .LVU178
 703 0008 0C94 0000 		jmp send_keyboard_report
 704               	.LVL61:
 705               	.L62:
 706               	/* epilogue start */
 846:./tmk_core/common/action.c ****     }
 847:./tmk_core/common/action.c **** }
 707               		.loc 1 847 1 is_stmt 0 view .LVU179
 708 000c 0895      		ret
 709               		.cfi_endproc
 710               	.LFE21:
 712               		.section	.text.unregister_mods,"ax",@progbits
 713               	.global	unregister_mods
 715               	unregister_mods:
 716               	.LVL62:
 717               	.LFB22:
 848:./tmk_core/common/action.c **** 
 849:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 850:./tmk_core/common/action.c ****  *
 851:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 852:./tmk_core/common/action.c ****  */
 853:./tmk_core/common/action.c **** void unregister_mods(uint8_t mods)
 854:./tmk_core/common/action.c **** {
 718               		.loc 1 854 1 is_stmt 1 view -0
 719               		.cfi_startproc
 720               	/* prologue: function */
 721               	/* frame size = 0 */
 722               	/* stack size = 0 */
 723               	.L__stack_usage = 0
 855:./tmk_core/common/action.c ****     if (mods) {
 724               		.loc 1 855 5 view .LVU181
 725               		.loc 1 855 8 is_stmt 0 view .LVU182
 726 0000 8823      		tst r24
 727 0002 01F0      		breq .L64
 856:./tmk_core/common/action.c ****         del_mods(mods);
 728               		.loc 1 856 9 is_stmt 1 view .LVU183
 729 0004 0E94 0000 		call del_mods
 730               	.LVL63:
 857:./tmk_core/common/action.c ****         send_keyboard_report();
 731               		.loc 1 857 9 view .LVU184
 732 0008 0C94 0000 		jmp send_keyboard_report
 733               	.LVL64:
 734               	.L64:
 735               	/* epilogue start */
 858:./tmk_core/common/action.c ****     }
 859:./tmk_core/common/action.c **** }
 736               		.loc 1 859 1 is_stmt 0 view .LVU185
 737 000c 0895      		ret
 738               		.cfi_endproc
 739               	.LFE22:
 741               		.section	.text.process_action,"ax",@progbits
 742               	.global	process_action
 744               	process_action:
 745               	.LVL65:
 746               	.LFB18:
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 747               		.loc 1 195 1 is_stmt 1 view -0
 748               		.cfi_startproc
 195:./tmk_core/common/action.c ****     keyevent_t event = record->event;
 749               		.loc 1 195 1 is_stmt 0 view .LVU187
 750 0000 8F92      		push r8
 751               	.LCFI5:
 752               		.cfi_def_cfa_offset 3
 753               		.cfi_offset 8, -2
 754 0002 9F92      		push r9
 755               	.LCFI6:
 756               		.cfi_def_cfa_offset 4
 757               		.cfi_offset 9, -3
 758 0004 AF92      		push r10
 759               	.LCFI7:
 760               		.cfi_def_cfa_offset 5
 761               		.cfi_offset 10, -4
 762 0006 BF92      		push r11
 763               	.LCFI8:
 764               		.cfi_def_cfa_offset 6
 765               		.cfi_offset 11, -5
 766 0008 DF92      		push r13
 767               	.LCFI9:
 768               		.cfi_def_cfa_offset 7
 769               		.cfi_offset 13, -6
 770 000a EF92      		push r14
 771               	.LCFI10:
 772               		.cfi_def_cfa_offset 8
 773               		.cfi_offset 14, -7
 774 000c FF92      		push r15
 775               	.LCFI11:
 776               		.cfi_def_cfa_offset 9
 777               		.cfi_offset 15, -8
 778 000e 0F93      		push r16
 779               	.LCFI12:
 780               		.cfi_def_cfa_offset 10
 781               		.cfi_offset 16, -9
 782 0010 1F93      		push r17
 783               	.LCFI13:
 784               		.cfi_def_cfa_offset 11
 785               		.cfi_offset 17, -10
 786 0012 CF93      		push r28
 787               	.LCFI14:
 788               		.cfi_def_cfa_offset 12
 789               		.cfi_offset 28, -11
 790 0014 DF93      		push r29
 791               	.LCFI15:
 792               		.cfi_def_cfa_offset 13
 793               		.cfi_offset 29, -12
 794 0016 00D0      		rcall .
 795 0018 00D0      		rcall .
 796 001a 0F92      		push __tmp_reg__
 797               	.LCFI16:
 798               		.cfi_def_cfa_offset 18
 799 001c CDB7      		in r28,__SP_L__
 800 001e DEB7      		in r29,__SP_H__
 801               	.LCFI17:
 802               		.cfi_def_cfa_register 28
 803               	/* prologue: function */
 804               	/* frame size = 5 */
 805               	/* stack size = 16 */
 806               	.L__stack_usage = 16
 807 0020 7C01      		movw r14,r24
 808 0022 6D83      		std Y+5,r22
 809 0024 7983      		std Y+1,r23
 196:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 810               		.loc 1 196 5 is_stmt 1 view .LVU188
 811               	.LVL66:
 198:./tmk_core/common/action.c **** #endif
 812               		.loc 1 198 5 view .LVU189
 198:./tmk_core/common/action.c **** #endif
 813               		.loc 1 198 36 is_stmt 0 view .LVU190
 814 0026 FC01      		movw r30,r24
 815 0028 0581      		ldd r16,Z+5
 816 002a 0295      		swap r16
 817 002c 0F70      		andi r16,lo8(15)
 818               	.LVL67:
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 819               		.loc 1 201 5 is_stmt 1 view .LVU191
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 820               		.loc 1 201 14 is_stmt 0 view .LVU192
 821 002e 1281      		ldd r17,Z+2
 201:./tmk_core/common/action.c ****         // clear the potential weak mods left by previously pressed keys
 822               		.loc 1 201 8 view .LVU193
 823 0030 1111      		cpse r17,__zero_reg__
 203:./tmk_core/common/action.c ****     }
 824               		.loc 1 203 9 is_stmt 1 view .LVU194
 825 0032 0E94 0000 		call clear_weak_mods
 826               	.LVL68:
 827               	.L67:
 207:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 828               		.loc 1 207 5 view .LVU195
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 829               		.loc 1 209 5 view .LVU196
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 830               		.loc 1 209 9 is_stmt 0 view .LVU197
 831 0036 0E94 0000 		call is_oneshot_layer_active
 832               	.LVL69:
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 833               		.loc 1 209 9 view .LVU198
 834 003a D82E      		mov r13,r24
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 835               		.loc 1 209 8 view .LVU199
 836 003c 8823      		tst r24
 837 003e 01F0      		breq .L68
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 838               		.loc 1 209 35 discriminator 1 view .LVU200
 839 0040 1123      		tst r17
 840 0042 01F0      		breq .L152
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 841               		.loc 1 209 55 discriminator 2 view .LVU201
 842 0044 8D81      		ldd r24,Y+5
 843 0046 805E      		subi r24,lo8(-(32))
 209:./tmk_core/common/action.c ****         clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 844               		.loc 1 209 52 discriminator 2 view .LVU202
 845 0048 8830      		cpi r24,lo8(8)
 846 004a 00F0      		brlo .L152
 210:./tmk_core/common/action.c ****         do_release_oneshot = !is_oneshot_layer_active();
 847               		.loc 1 210 9 is_stmt 1 view .LVU203
 848 004c 82E0      		ldi r24,lo8(2)
 849 004e 0E94 0000 		call clear_oneshot_layer_state
 850               	.LVL70:
 211:./tmk_core/common/action.c ****     }
 851               		.loc 1 211 9 view .LVU204
 211:./tmk_core/common/action.c ****     }
 852               		.loc 1 211 31 is_stmt 0 view .LVU205
 853 0052 0E94 0000 		call is_oneshot_layer_active
 854               	.LVL71:
 211:./tmk_core/common/action.c ****     }
 855               		.loc 1 211 9 view .LVU206
 856 0056 91E0      		ldi r25,lo8(1)
 857 0058 D82E      		mov r13,r24
 858 005a D926      		eor r13,r25
 859               	.LVL72:
 860               	.L68:
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 861               		.loc 1 215 5 is_stmt 1 view .LVU207
 215:./tmk_core/common/action.c ****         /* Key and Mods */
 862               		.loc 1 215 24 is_stmt 0 view .LVU208
 863 005c B980      		ldd r11,Y+1
 864 005e B294      		swap r11
 865 0060 9FE0      		ldi r25,lo8(15)
 866 0062 B922      		and r11,r25
 867 0064 EB2D      		mov r30,r11
 868 0066 F0E0      		ldi r31,0
 869 0068 E050      		subi r30,lo8(-(gs(.L71)))
 870 006a F040      		sbci r31,hi8(-(gs(.L71)))
 871 006c 0C94 0000 		jmp __tablejump2__
 872               		.section	.jumptables.gcc.process_action,"a",@progbits
 873               		.p2align	1
 874               	.L71:
 875 0000 0000      		.word gs(.L78)
 876 0002 0000      		.word gs(.L78)
 877 0004 0000      		.word gs(.L77)
 878 0006 0000      		.word gs(.L77)
 879 0008 0000      		.word gs(.L76)
 880 000a 0000      		.word gs(.L75)
 881 000c 0000      		.word gs(.L69)
 882 000e 0000      		.word gs(.L69)
 883 0010 0000      		.word gs(.L74)
 884 0012 0000      		.word gs(.L69)
 885 0014 0000      		.word gs(.L73)
 886 0016 0000      		.word gs(.L73)
 887 0018 0000      		.word gs(.L72)
 888 001a 0000      		.word gs(.L69)
 889 001c 0000      		.word gs(.L69)
 890 001e 0000      		.word gs(.L70)
 891               		.section	.text.process_action
 892               	.LVL73:
 893               	.L152:
 207:./tmk_core/common/action.c ****     // notice we only clear the one shot layer if the pressed key is not a modifier.
 894               		.loc 1 207 10 view .LVU209
 895 0070 D12C      		mov r13,__zero_reg__
 896 0072 00C0      		rjmp .L68
 897               	.LVL74:
 898               	.L78:
 899               	.LBB20:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 900               		.loc 1 220 17 is_stmt 1 view .LVU210
 901 0074 0981      		ldd r16,Y+1
 902               	.LVL75:
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 903               		.loc 1 220 17 is_stmt 0 view .LVU211
 904 0076 0F70      		andi r16,lo8(15)
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 905               		.loc 1 220 48 view .LVU212
 906 0078 F981      		ldd r31,Y+1
 907 007a F07F      		andi r31,lo8(-16)
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 908               		.loc 1 220 25 view .LVU213
 909 007c 01F0      		breq .L79
 220:./tmk_core/common/action.c ****                                                                 action.key.mods<<4;
 910               		.loc 1 220 25 discriminator 2 view .LVU214
 911 007e 0295      		swap r16
 912 0080 007F      		andi r16,lo8(-16)
 913               	.L79:
 914               	.LVL76:
 222:./tmk_core/common/action.c ****                     if (mods) {
 915               		.loc 1 222 17 is_stmt 1 discriminator 4 view .LVU215
 222:./tmk_core/common/action.c ****                     if (mods) {
 916               		.loc 1 222 20 is_stmt 0 discriminator 4 view .LVU216
 917 0082 1123      		tst r17
 918 0084 01F0      		breq .L80
 223:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 919               		.loc 1 223 21 is_stmt 1 view .LVU217
 223:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 920               		.loc 1 223 24 is_stmt 0 view .LVU218
 921 0086 0023      		tst r16
 922 0088 01F0      		breq .L102
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 923               		.loc 1 224 25 is_stmt 1 view .LVU219
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 924               		.loc 1 224 29 is_stmt 0 view .LVU220
 925 008a 8D81      		ldd r24,Y+5
 926 008c 805E      		subi r24,lo8(-(32))
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 927               		.loc 1 224 28 view .LVU221
 928 008e 8830      		cpi r24,lo8(8)
 929 0090 00F0      		brlo .L82
 224:./tmk_core/common/action.c ****                             // e.g. LSFT(KC_LGUI): we don't want the LSFT to be weak as it would ma
 930               		.loc 1 224 53 discriminator 1 view .LVU222
 931 0092 2D81      		ldd r18,Y+5
 932 0094 2111      		cpse r18,__zero_reg__
 933 0096 00C0      		rjmp .L83
 934               	.L82:
 228:./tmk_core/common/action.c ****                         } else {
 935               		.loc 1 228 29 is_stmt 1 view .LVU223
 936 0098 802F      		mov r24,r16
 937 009a 0E94 0000 		call add_mods
 938               	.LVL77:
 939               	.L84:
 232:./tmk_core/common/action.c ****                     }
 940               		.loc 1 232 25 view .LVU224
 941 009e 0E94 0000 		call send_keyboard_report
 942               	.LVL78:
 234:./tmk_core/common/action.c ****                 } else {
 943               		.loc 1 234 21 view .LVU225
 944               	.L102:
 234:./tmk_core/common/action.c ****                 } else {
 945               		.loc 1 234 21 is_stmt 0 view .LVU226
 946               	.LBE20:
 947               	.LBB21:
 320:./tmk_core/common/action.c ****                                     register_code(action.key.code);
 948               		.loc 1 320 77 is_stmt 1 view .LVU227
 321:./tmk_core/common/action.c ****                                 }
 949               		.loc 1 321 37 view .LVU228
 950 00a2 8D81      		ldd r24,Y+5
 951 00a4 0E94 0000 		call register_code
 952               	.LVL79:
 953 00a8 00C0      		rjmp .L85
 954               	.LVL80:
 955               	.L83:
 321:./tmk_core/common/action.c ****                                 }
 956               		.loc 1 321 37 is_stmt 0 view .LVU229
 957               	.LBE21:
 958               	.LBB22:
 230:./tmk_core/common/action.c ****                         }
 959               		.loc 1 230 29 is_stmt 1 view .LVU230
 960 00aa 802F      		mov r24,r16
 961 00ac 0E94 0000 		call add_weak_mods
 962               	.LVL81:
 963 00b0 00C0      		rjmp .L84
 964               	.L80:
 236:./tmk_core/common/action.c ****                     if (mods) {
 965               		.loc 1 236 21 view .LVU231
 966 00b2 8D81      		ldd r24,Y+5
 967 00b4 0E94 0000 		call unregister_code
 968               	.LVL82:
 237:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 969               		.loc 1 237 21 view .LVU232
 237:./tmk_core/common/action.c ****                         if (IS_MOD(action.key.code) || action.key.code == KC_NO) {
 970               		.loc 1 237 24 is_stmt 0 view .LVU233
 971 00b8 0023      		tst r16
 972 00ba 01F0      		breq .L85
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 973               		.loc 1 238 25 is_stmt 1 view .LVU234
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 974               		.loc 1 238 29 is_stmt 0 view .LVU235
 975 00bc 8D81      		ldd r24,Y+5
 976 00be 805E      		subi r24,lo8(-(32))
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 977               		.loc 1 238 28 view .LVU236
 978 00c0 8830      		cpi r24,lo8(8)
 979 00c2 00F0      		brlo .L87
 238:./tmk_core/common/action.c ****                             del_mods(mods);
 980               		.loc 1 238 53 discriminator 1 view .LVU237
 981 00c4 3D81      		ldd r19,Y+5
 982 00c6 3111      		cpse r19,__zero_reg__
 983 00c8 00C0      		rjmp .L88
 984               	.L87:
 239:./tmk_core/common/action.c ****                         } else {
 985               		.loc 1 239 29 is_stmt 1 view .LVU238
 986 00ca 802F      		mov r24,r16
 987 00cc 0E94 0000 		call del_mods
 988               	.LVL83:
 989               	.L89:
 243:./tmk_core/common/action.c ****                     }
 990               		.loc 1 243 25 view .LVU239
 991 00d0 0E94 0000 		call send_keyboard_report
 992               	.LVL84:
 993               	.L85:
 243:./tmk_core/common/action.c ****                     }
 994               		.loc 1 243 25 is_stmt 0 view .LVU240
 995               	.LBE22:
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 996               		.loc 1 684 5 is_stmt 1 view .LVU241
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 997               		.loc 1 684 8 is_stmt 0 view .LVU242
 998 00d4 DD20      		tst r13
 999 00d6 01F4      		brne .+2
 1000 00d8 00C0      		rjmp .L66
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1001               		.loc 1 684 33 discriminator 1 view .LVU243
 1002 00da 0E94 0000 		call get_oneshot_layer_state
 1003               	.LVL85:
 684:./tmk_core/common/action.c ****         record->event.pressed = false;
 1004               		.loc 1 684 28 discriminator 1 view .LVU244
 1005 00de 80FD      		sbrc r24,0
 1006 00e0 00C0      		rjmp .L66
 685:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1007               		.loc 1 685 9 is_stmt 1 view .LVU245
 685:./tmk_core/common/action.c ****         layer_on(get_oneshot_layer());
 1008               		.loc 1 685 31 is_stmt 0 view .LVU246
 1009 00e2 F701      		movw r30,r14
 1010 00e4 1282      		std Z+2,__zero_reg__
 686:./tmk_core/common/action.c ****         process_record(record);
 1011               		.loc 1 686 9 is_stmt 1 view .LVU247
 1012 00e6 0E94 0000 		call get_oneshot_layer
 1013               	.LVL86:
 1014 00ea 0E94 0000 		call layer_on
 1015               	.LVL87:
 687:./tmk_core/common/action.c ****         layer_off(get_oneshot_layer());
 1016               		.loc 1 687 9 view .LVU248
 1017 00ee C701      		movw r24,r14
 1018 00f0 0E94 0000 		call process_record
 1019               	.LVL88:
 688:./tmk_core/common/action.c ****     }
 1020               		.loc 1 688 9 view .LVU249
 1021 00f4 0E94 0000 		call get_oneshot_layer
 1022               	.LVL89:
 1023               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1024               		.loc 1 691 1 is_stmt 0 view .LVU250
 1025 00f8 0F90      		pop __tmp_reg__
 1026 00fa 0F90      		pop __tmp_reg__
 1027 00fc 0F90      		pop __tmp_reg__
 1028 00fe 0F90      		pop __tmp_reg__
 1029 0100 0F90      		pop __tmp_reg__
 1030 0102 DF91      		pop r29
 1031 0104 CF91      		pop r28
 1032 0106 1F91      		pop r17
 1033               	.LVL90:
 691:./tmk_core/common/action.c **** 
 1034               		.loc 1 691 1 view .LVU251
 1035 0108 0F91      		pop r16
 1036 010a FF90      		pop r15
 1037 010c EF90      		pop r14
 1038               	.LVL91:
 691:./tmk_core/common/action.c **** 
 1039               		.loc 1 691 1 view .LVU252
 1040 010e DF90      		pop r13
 1041               	.LVL92:
 691:./tmk_core/common/action.c **** 
 1042               		.loc 1 691 1 view .LVU253
 1043 0110 BF90      		pop r11
 1044 0112 AF90      		pop r10
 1045 0114 9F90      		pop r9
 1046 0116 8F90      		pop r8
 688:./tmk_core/common/action.c ****     }
 1047               		.loc 1 688 9 view .LVU254
 1048 0118 0C94 0000 		jmp layer_off
 1049               	.LVL93:
 1050               	.L88:
 1051               	.LBB23:
 241:./tmk_core/common/action.c ****                         }
 1052               		.loc 1 241 29 is_stmt 1 view .LVU255
 1053 011c 802F      		mov r24,r16
 1054 011e 0E94 0000 		call del_weak_mods
 1055               	.LVL94:
 1056 0122 00C0      		rjmp .L89
 1057               	.LVL95:
 1058               	.L77:
 241:./tmk_core/common/action.c ****                         }
 1059               		.loc 1 241 29 is_stmt 0 view .LVU256
 1060               	.LBE23:
 1061               	.LBB24:
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1062               		.loc 1 252 17 is_stmt 1 view .LVU257
 1063 0124 4981      		ldd r20,Y+1
 1064 0126 4F70      		andi r20,lo8(15)
 1065 0128 B42E      		mov r11,r20
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1066               		.loc 1 252 48 is_stmt 0 view .LVU258
 1067 012a 5981      		ldd r21,Y+1
 1068 012c 507F      		andi r21,lo8(-16)
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1069               		.loc 1 252 25 view .LVU259
 1070 012e 5032      		cpi r21,lo8(32)
 1071 0130 01F0      		breq .L90
 252:./tmk_core/common/action.c ****                                                                     action.key.mods<<4;
 1072               		.loc 1 252 25 discriminator 2 view .LVU260
 1073 0132 B294      		swap r11
 1074 0134 80EF      		ldi r24,lo8(-16)
 1075 0136 B822      		and r11,r24
 1076               	.L90:
 1077               	.LVL96:
 254:./tmk_core/common/action.c ****     #ifndef NO_ACTION_ONESHOT
 1078               		.loc 1 254 17 is_stmt 1 discriminator 4 view .LVU261
 1079 0138 8D81      		ldd r24,Y+5
 1080 013a 8823      		tst r24
 1081 013c 01F0      		breq .L91
 1082 013e 8130      		cpi r24,lo8(1)
 1083 0140 01F0      		breq .L92
 309:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1084               		.loc 1 309 25 view .LVU262
 309:./tmk_core/common/action.c ****                             if (tap_count > 0) {
 1085               		.loc 1 309 28 is_stmt 0 view .LVU263
 1086 0142 1123      		tst r17
 1087 0144 01F0      		breq .L100
 310:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1088               		.loc 1 310 29 is_stmt 1 view .LVU264
 310:./tmk_core/common/action.c **** #ifndef IGNORE_MOD_TAP_INTERRUPT
 1089               		.loc 1 310 32 is_stmt 0 view .LVU265
 1090 0146 0023      		tst r16
 1091 0148 01F0      		breq .L192
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1092               		.loc 1 312 33 is_stmt 1 view .LVU266
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1093               		.loc 1 312 37 is_stmt 0 view .LVU267
 1094 014a F701      		movw r30,r14
 1095 014c 8581      		ldd r24,Z+5
 312:./tmk_core/common/action.c ****                                     dprint("mods_tap: tap: cancel: add_mods\n");
 1096               		.loc 1 312 36 view .LVU268
 1097 014e 80FF      		sbrs r24,0
 1098 0150 00C0      		rjmp .L102
 313:./tmk_core/common/action.c ****                                     // ad hoc: set 0 to cancel tap
 1099               		.loc 1 313 80 is_stmt 1 view .LVU269
 315:./tmk_core/common/action.c ****                                     register_mods(mods);
 1100               		.loc 1 315 37 view .LVU270
 315:./tmk_core/common/action.c ****                                     register_mods(mods);
 1101               		.loc 1 315 55 is_stmt 0 view .LVU271
 1102 0152 8F70      		andi r24,lo8(15)
 1103 0154 8583      		std Z+5,r24
 1104 0156 00C0      		rjmp .L192
 1105               	.L91:
 258:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1106               		.loc 1 258 25 is_stmt 1 view .LVU272
 258:./tmk_core/common/action.c ****                             if (tap_count == 0) {
 1107               		.loc 1 258 28 is_stmt 0 view .LVU273
 1108 0158 1123      		tst r17
 1109 015a 01F0      		breq .L94
 259:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1110               		.loc 1 259 29 is_stmt 1 view .LVU274
 259:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: 0\n");
 1111               		.loc 1 259 32 is_stmt 0 view .LVU275
 1112 015c 0111      		cpse r16,__zero_reg__
 1113 015e 00C0      		rjmp .L95
 1114               	.L96:
 273:./tmk_core/common/action.c ****                             }
 1115               		.loc 1 273 33 is_stmt 1 view .LVU276
 273:./tmk_core/common/action.c ****                             }
 1116               		.loc 1 273 54 is_stmt 0 view .LVU277
 1117 0160 0E94 0000 		call get_oneshot_mods
 1118               	.LVL97:
 273:./tmk_core/common/action.c ****                             }
 1119               		.loc 1 273 33 view .LVU278
 1120 0164 8B29      		or r24,r11
 1121               	.L191:
 316:./tmk_core/common/action.c ****                                 } else
 1122               		.loc 1 316 37 view .LVU279
 1123 0166 0E94 0000 		call register_mods
 1124               	.LVL98:
 1125 016a 00C0      		rjmp .L85
 1126               	.L95:
 262:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1127               		.loc 1 262 36 is_stmt 1 view .LVU280
 262:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Oneshot: start\n");
 1128               		.loc 1 262 39 is_stmt 0 view .LVU281
 1129 016c 0130      		cpi r16,lo8(1)
 1130 016e 01F4      		brne .L96
 263:./tmk_core/common/action.c ****                                 set_oneshot_mods(mods | get_oneshot_mods());
 1131               		.loc 1 263 69 is_stmt 1 view .LVU282
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1132               		.loc 1 264 33 view .LVU283
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1133               		.loc 1 264 57 is_stmt 0 view .LVU284
 1134 0170 0E94 0000 		call get_oneshot_mods
 1135               	.LVL99:
 264:./tmk_core/common/action.c ****                     #if defined(ONESHOT_TAP_TOGGLE) && ONESHOT_TAP_TOGGLE > 1
 1136               		.loc 1 264 33 view .LVU285
 1137 0174 8B29      		or r24,r11
 1138 0176 0E94 0000 		call set_oneshot_mods
 1139               	.LVL100:
 1140 017a 00C0      		rjmp .L85
 1141               	.L94:
 276:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1142               		.loc 1 276 29 is_stmt 1 view .LVU286
 276:./tmk_core/common/action.c ****                                 clear_oneshot_mods();
 1143               		.loc 1 276 32 is_stmt 0 view .LVU287
 1144 017c 0111      		cpse r16,__zero_reg__
 1145 017e 00C0      		rjmp .L97
 1146               	.L193:
 291:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1147               		.loc 1 291 33 is_stmt 1 view .LVU288
 1148 0180 0E94 0000 		call clear_oneshot_mods
 1149               	.LVL101:
 292:./tmk_core/common/action.c ****                             }
 1150               		.loc 1 292 33 view .LVU289
 1151               	.L103:
 332:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1152               		.loc 1 332 71 view .LVU290
 333:./tmk_core/common/action.c ****                             }
 1153               		.loc 1 333 33 view .LVU291
 1154 0184 8B2D      		mov r24,r11
 1155 0186 0E94 0000 		call unregister_mods
 1156               	.LVL102:
 1157 018a 00C0      		rjmp .L85
 1158               	.L97:
 279:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1159               		.loc 1 279 36 view .LVU292
 279:./tmk_core/common/action.c ****                                 // Retain Oneshot mods
 1160               		.loc 1 279 39 is_stmt 0 view .LVU293
 1161 018c 0130      		cpi r16,lo8(1)
 1162 018e 01F4      		brne .+2
 1163 0190 00C0      		rjmp .L85
 1164 0192 00C0      		rjmp .L193
 1165               	.L92:
 298:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1166               		.loc 1 298 25 is_stmt 1 view .LVU294
 298:./tmk_core/common/action.c ****                             if (tap_count <= TAPPING_TOGGLE) {
 1167               		.loc 1 298 28 is_stmt 0 view .LVU295
 1168 0194 1123      		tst r17
 1169 0196 01F0      		breq .L99
 299:./tmk_core/common/action.c ****                                 register_mods(mods);
 1170               		.loc 1 299 29 is_stmt 1 view .LVU296
 299:./tmk_core/common/action.c ****                                 register_mods(mods);
 1171               		.loc 1 299 32 is_stmt 0 view .LVU297
 1172 0198 0630      		cpi r16,lo8(6)
 1173 019a 00F0      		brlo .+2
 1174 019c 00C0      		rjmp .L85
 1175               	.L192:
 316:./tmk_core/common/action.c ****                                 } else
 1176               		.loc 1 316 37 is_stmt 1 view .LVU298
 1177 019e 8B2D      		mov r24,r11
 1178 01a0 00C0      		rjmp .L191
 1179               	.L99:
 303:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1180               		.loc 1 303 29 view .LVU299
 303:./tmk_core/common/action.c ****                                 unregister_mods(mods);
 1181               		.loc 1 303 32 is_stmt 0 view .LVU300
 1182 01a2 0530      		cpi r16,lo8(5)
 1183 01a4 00F0      		brlo .+2
 1184 01a6 00C0      		rjmp .L85
 1185 01a8 00C0      		rjmp .L103
 1186               	.L100:
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1187               		.loc 1 328 29 is_stmt 1 view .LVU301
 328:./tmk_core/common/action.c ****                                 dprint("MODS_TAP: Tap: unregister_code\n");
 1188               		.loc 1 328 32 is_stmt 0 view .LVU302
 1189 01aa 0023      		tst r16
 1190 01ac 01F0      		breq .L103
 329:./tmk_core/common/action.c ****                                 unregister_code(action.key.code);
 1191               		.loc 1 329 75 is_stmt 1 view .LVU303
 330:./tmk_core/common/action.c ****                             } else {
 1192               		.loc 1 330 33 view .LVU304
 1193 01ae 8D81      		ldd r24,Y+5
 1194 01b0 0E94 0000 		call unregister_code
 1195               	.LVL103:
 1196 01b4 00C0      		rjmp .L85
 1197               	.LVL104:
 1198               	.L76:
 330:./tmk_core/common/action.c ****                             } else {
 1199               		.loc 1 330 33 is_stmt 0 view .LVU305
 1200               	.LBE24:
 344:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1201               		.loc 1 344 13 is_stmt 1 view .LVU306
 344:./tmk_core/common/action.c ****                 case PAGE_SYSTEM:
 1202               		.loc 1 344 33 is_stmt 0 view .LVU307
 1203 01b6 8981      		ldd r24,Y+1
 1204 01b8 8695      		lsr r24
 1205 01ba 8695      		lsr r24
 1206 01bc 8370      		andi r24,lo8(3)
 1207 01be 01F0      		breq .L104
 1208 01c0 8130      		cpi r24,lo8(1)
 1209 01c2 01F0      		breq .L105
 1210               	.L106:
 641:./tmk_core/common/action.c ****         case ACT_LAYER:
 1211               		.loc 1 641 5 view .LVU308
 1212 01c4 86E0      		ldi r24,lo8(6)
 1213 01c6 8B0D      		add r24,r11
 1214 01c8 8F70      		andi r24,lo8(15)
 1215 01ca 8230      		cpi r24,lo8(2)
 1216 01cc 00F4      		brsh .+2
 1217 01ce 00C0      		rjmp .L117
 1218 01d0 00C0      		rjmp .L85
 1219               	.L104:
 346:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1220               		.loc 1 346 21 is_stmt 1 view .LVU309
 347:./tmk_core/common/action.c ****                     } else {
 1221               		.loc 1 347 25 is_stmt 0 view .LVU310
 1222 01d2 8D81      		ldd r24,Y+5
 1223 01d4 9981      		ldd r25,Y+1
 1224 01d6 9370      		andi r25,lo8(3)
 346:./tmk_core/common/action.c ****                         host_system_send(action.usage.code);
 1225               		.loc 1 346 24 view .LVU311
 1226 01d8 1111      		cpse r17,__zero_reg__
 1227 01da 00C0      		rjmp .L189
 349:./tmk_core/common/action.c ****                     }
 1228               		.loc 1 349 25 is_stmt 1 view .LVU312
 1229 01dc 90E0      		ldi r25,0
 1230 01de 80E0      		ldi r24,0
 1231               	.L189:
 1232 01e0 0E94 0000 		call host_system_send
 1233               	.LVL105:
 1234 01e4 00C0      		rjmp .L85
 1235               	.L105:
 353:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1236               		.loc 1 353 21 view .LVU313
 354:./tmk_core/common/action.c ****                     } else {
 1237               		.loc 1 354 25 is_stmt 0 view .LVU314
 1238 01e6 8D81      		ldd r24,Y+5
 1239 01e8 9981      		ldd r25,Y+1
 1240 01ea 9370      		andi r25,lo8(3)
 353:./tmk_core/common/action.c ****                         host_consumer_send(action.usage.code);
 1241               		.loc 1 353 24 view .LVU315
 1242 01ec 1111      		cpse r17,__zero_reg__
 1243 01ee 00C0      		rjmp .L188
 356:./tmk_core/common/action.c ****                     }
 1244               		.loc 1 356 25 is_stmt 1 view .LVU316
 1245 01f0 90E0      		ldi r25,0
 1246 01f2 80E0      		ldi r24,0
 1247               	.L188:
 1248 01f4 0E94 0000 		call host_consumer_send
 1249               	.LVL106:
 1250 01f8 00C0      		rjmp .L85
 1251               	.L75:
 365:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1252               		.loc 1 365 13 view .LVU317
 365:./tmk_core/common/action.c ****                 switch (action.key.code) {
 1253               		.loc 1 365 16 is_stmt 0 view .LVU318
 1254 01fa 1123      		tst r17
 1255 01fc 01F0      		breq .L109
 366:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1256               		.loc 1 366 17 is_stmt 1 view .LVU319
 1257 01fe FD81      		ldd r31,Y+5
 1258 0200 F53F      		cpi r31,lo8(-11)
 1259 0202 01F0      		breq .L110
 1260 0204 F63F      		cpi r31,lo8(-10)
 1261 0206 01F0      		breq .L111
 1262 0208 F43F      		cpi r31,lo8(-12)
 1263 020a 01F4      		brne .L112
 368:./tmk_core/common/action.c ****                         break;
 1264               		.loc 1 368 25 view .LVU320
 368:./tmk_core/common/action.c ****                         break;
 1265               		.loc 1 368 36 is_stmt 0 view .LVU321
 1266 020c 8091 0000 		lds r24,tp_buttons
 1267 0210 9091 0000 		lds r25,tp_buttons+1
 1268 0214 8160      		ori r24,1
 1269               	.L181:
 374:./tmk_core/common/action.c ****                         break;
 1270               		.loc 1 374 36 view .LVU322
 1271 0216 9093 0000 		sts tp_buttons+1,r25
 1272 021a 8093 0000 		sts tp_buttons,r24
 375:./tmk_core/common/action.c ****                     default:
 1273               		.loc 1 375 25 is_stmt 1 view .LVU323
 1274               	.L112:
 379:./tmk_core/common/action.c ****                 mousekey_send();
 1275               		.loc 1 379 17 view .LVU324
 1276 021e 8D81      		ldd r24,Y+5
 1277 0220 0E94 0000 		call mousekey_on
 1278               	.LVL107:
 380:./tmk_core/common/action.c ****             } else {
 1279               		.loc 1 380 17 view .LVU325
 1280               	.L190:
 396:./tmk_core/common/action.c ****             }
 1281               		.loc 1 396 17 view .LVU326
 1282 0224 0E94 0000 		call mousekey_send
 1283               	.LVL108:
 1284 0228 00C0      		rjmp .L85
 1285               	.L110:
 371:./tmk_core/common/action.c ****                         break;
 1286               		.loc 1 371 25 view .LVU327
 371:./tmk_core/common/action.c ****                         break;
 1287               		.loc 1 371 36 is_stmt 0 view .LVU328
 1288 022a 8091 0000 		lds r24,tp_buttons
 1289 022e 9091 0000 		lds r25,tp_buttons+1
 1290 0232 8260      		ori r24,2
 1291 0234 00C0      		rjmp .L181
 1292               	.L111:
 374:./tmk_core/common/action.c ****                         break;
 1293               		.loc 1 374 25 is_stmt 1 view .LVU329
 374:./tmk_core/common/action.c ****                         break;
 1294               		.loc 1 374 36 is_stmt 0 view .LVU330
 1295 0236 8091 0000 		lds r24,tp_buttons
 1296 023a 9091 0000 		lds r25,tp_buttons+1
 1297 023e 8460      		ori r24,4
 1298 0240 00C0      		rjmp .L181
 1299               	.L109:
 382:./tmk_core/common/action.c ****                     case KC_MS_BTN1:
 1300               		.loc 1 382 17 is_stmt 1 view .LVU331
 1301 0242 2D81      		ldd r18,Y+5
 1302 0244 253F      		cpi r18,lo8(-11)
 1303 0246 01F0      		breq .L113
 1304 0248 263F      		cpi r18,lo8(-10)
 1305 024a 01F0      		breq .L114
 1306 024c 243F      		cpi r18,lo8(-12)
 1307 024e 01F4      		brne .L115
 384:./tmk_core/common/action.c ****                         break;
 1308               		.loc 1 384 25 view .LVU332
 384:./tmk_core/common/action.c ****                         break;
 1309               		.loc 1 384 36 is_stmt 0 view .LVU333
 1310 0250 8091 0000 		lds r24,tp_buttons
 1311 0254 9091 0000 		lds r25,tp_buttons+1
 1312 0258 8E7F      		andi r24,254
 1313               	.L182:
 390:./tmk_core/common/action.c ****                         break;
 1314               		.loc 1 390 36 view .LVU334
 1315 025a 9093 0000 		sts tp_buttons+1,r25
 1316 025e 8093 0000 		sts tp_buttons,r24
 391:./tmk_core/common/action.c ****                     default:
 1317               		.loc 1 391 25 is_stmt 1 view .LVU335
 1318               	.L115:
 395:./tmk_core/common/action.c ****                 mousekey_send();
 1319               		.loc 1 395 17 view .LVU336
 1320 0262 8D81      		ldd r24,Y+5
 1321 0264 0E94 0000 		call mousekey_off
 1322               	.LVL109:
 1323 0268 00C0      		rjmp .L190
 1324               	.L113:
 387:./tmk_core/common/action.c ****                         break;
 1325               		.loc 1 387 25 view .LVU337
 387:./tmk_core/common/action.c ****                         break;
 1326               		.loc 1 387 36 is_stmt 0 view .LVU338
 1327 026a 8091 0000 		lds r24,tp_buttons
 1328 026e 9091 0000 		lds r25,tp_buttons+1
 1329 0272 8D7F      		andi r24,253
 1330 0274 00C0      		rjmp .L182
 1331               	.L114:
 390:./tmk_core/common/action.c ****                         break;
 1332               		.loc 1 390 25 is_stmt 1 view .LVU339
 390:./tmk_core/common/action.c ****                         break;
 1333               		.loc 1 390 36 is_stmt 0 view .LVU340
 1334 0276 8091 0000 		lds r24,tp_buttons
 1335 027a 9091 0000 		lds r25,tp_buttons+1
 1336 027e 8B7F      		andi r24,251
 1337 0280 00C0      		rjmp .L182
 1338               	.L74:
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1339               		.loc 1 402 13 is_stmt 1 view .LVU341
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1340               		.loc 1 402 39 is_stmt 0 view .LVU342
 1341 0282 8981      		ldd r24,Y+1
 1342 0284 8370      		andi r24,lo8(3)
 402:./tmk_core/common/action.c ****                 /* Default Layer Bitwise Operation */
 1343               		.loc 1 402 16 view .LVU343
 1344 0286 01F0      		breq .+2
 1345 0288 00C0      		rjmp .L116
 404:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1346               		.loc 1 404 17 is_stmt 1 view .LVU344
 404:./tmk_core/common/action.c ****                     uint8_t shift = action.layer_bitop.part*4;
 1347               		.loc 1 404 20 is_stmt 0 view .LVU345
 1348 028a 1111      		cpse r17,__zero_reg__
 1349 028c 00C0      		rjmp .L117
 1350               	.LBB25:
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1351               		.loc 1 405 21 is_stmt 1 view .LVU346
 1352               	.LVL110:
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1353               		.loc 1 406 21 view .LVU347
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1354               		.loc 1 405 55 is_stmt 0 view .LVU348
 1355 028e 2D81      		ldd r18,Y+5
 1356 0290 2295      		swap r18
 1357 0292 2695      		lsr r18
 1358 0294 2770      		andi r18,lo8(7)
 405:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1359               		.loc 1 405 29 view .LVU349
 1360 0296 220F      		lsl r18
 1361 0298 220F      		lsl r18
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1362               		.loc 1 406 66 view .LVU350
 1363 029a 8D81      		ldd r24,Y+5
 1364 029c 8F70      		andi r24,lo8(15)
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1365               		.loc 1 406 38 view .LVU351
 1366 029e 90E0      		ldi r25,0
 1367 02a0 B0E0      		ldi r27,0
 1368 02a2 A0E0      		ldi r26,0
 406:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1369               		.loc 1 406 30 view .LVU352
 1370 02a4 4C01      		movw r8,r24
 1371 02a6 5D01      		movw r10,r26
 1372 02a8 022E      		mov r0,r18
 1373 02aa 00C0      		rjmp 2f
 1374               		1:
 1375 02ac 880C      		lsl r8
 1376 02ae 991C      		rol r9
 1377 02b0 AA1C      		rol r10
 1378 02b2 BB1C      		rol r11
 1379               		2:
 1380 02b4 0A94      		dec r0
 1381 02b6 02F4      		brpl 1b
 1382               	.LVL111:
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1383               		.loc 1 407 21 is_stmt 1 view .LVU353
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1384               		.loc 1 407 91 is_stmt 0 view .LVU354
 1385 02b8 3D81      		ldd r19,Y+5
 1386 02ba 60E0      		ldi r22,0
 1387 02bc 70E0      		ldi r23,0
 1388 02be CB01      		movw r24,r22
 1389 02c0 34FF      		sbrs r19,4
 1390 02c2 00C0      		rjmp .L118
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1391               		.loc 1 407 82 discriminator 1 view .LVU355
 1392 02c4 6FE0      		ldi r22,lo8(15)
 1393 02c6 70E0      		ldi r23,0
 1394 02c8 80E0      		ldi r24,0
 1395 02ca 90E0      		ldi r25,0
 1396 02cc 00C0      		rjmp 2f
 1397               		1:
 1398 02ce 660F      		lsl r22
 1399 02d0 771F      		rol r23
 1400 02d2 881F      		rol r24
 1401 02d4 991F      		rol r25
 1402               		2:
 1403 02d6 2A95      		dec r18
 1404 02d8 02F4      		brpl 1b
 407:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1405               		.loc 1 407 91 discriminator 1 view .LVU356
 1406 02da 6095      		com r22
 1407 02dc 7095      		com r23
 1408 02de 8095      		com r24
 1409 02e0 9095      		com r25
 1410               	.L118:
 1411               	.LVL112:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1412               		.loc 1 408 21 is_stmt 1 discriminator 4 view .LVU357
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1413               		.loc 1 408 47 is_stmt 0 discriminator 4 view .LVU358
 1414 02e2 4981      		ldd r20,Y+1
 1415 02e4 4695      		lsr r20
 1416 02e6 4695      		lsr r20
 1417 02e8 4370      		andi r20,lo8(3)
 1418 02ea 4D83      		std Y+5,r20
 1419               	.LVL113:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1420               		.loc 1 408 47 discriminator 4 view .LVU359
 1421 02ec 4230      		cpi r20,lo8(2)
 1422 02ee 01F0      		breq .L119
 1423 02f0 4330      		cpi r20,lo8(3)
 1424 02f2 01F0      		breq .L120
 1425 02f4 9B01      		movw r18,r22
 1426 02f6 AC01      		movw r20,r24
 1427 02f8 2829      		or r18,r8
 1428 02fa 3929      		or r19,r9
 1429               	.LVL114:
 408:./tmk_core/common/action.c ****                         case OP_BIT_AND: default_layer_and(bits | mask); break;
 1430               		.loc 1 408 47 discriminator 4 view .LVU360
 1431 02fc 4A29      		or r20,r10
 1432 02fe 5B29      		or r21,r11
 1433 0300 2983      		std Y+1,r18
 1434 0302 3A83      		std Y+2,r19
 1435 0304 4B83      		std Y+3,r20
 1436 0306 5C83      		std Y+4,r21
 1437 0308 3D81      		ldd r19,Y+5
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1438               		.loc 1 409 42 view .LVU361
 1439 030a 6981      		ldd r22,Y+1
 1440 030c 7A81      		ldd r23,Y+2
 1441 030e 8B81      		ldd r24,Y+3
 1442 0310 9C81      		ldd r25,Y+4
 1443               	.LVL115:
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1444               		.loc 1 409 42 view .LVU362
 1445 0312 3130      		cpi r19,lo8(1)
 1446 0314 01F0      		breq .L186
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1447               		.loc 1 409 42 is_stmt 1 view .LVU363
 1448 0316 0E94 0000 		call default_layer_and
 1449               	.LVL116:
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1450               		.loc 1 409 74 view .LVU364
 1451               	.L117:
 409:./tmk_core/common/action.c ****                         case OP_BIT_OR:  default_layer_or(bits | mask);  break;
 1452               		.loc 1 409 74 is_stmt 0 view .LVU365
 1453               	.LBE25:
 647:./tmk_core/common/action.c ****             break;
 1454               		.loc 1 647 13 is_stmt 1 view .LVU366
 1455 031a 0E94 0000 		call host_keyboard_leds
 1456               	.LVL117:
 1457 031e 0E94 0000 		call led_set
 1458               	.LVL118:
 648:./tmk_core/common/action.c ****         default:
 1459               		.loc 1 648 13 view .LVU367
 1460 0322 00C0      		rjmp .L85
 1461               	.LVL119:
 1462               	.L119:
 1463               	.LBB26:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1464               		.loc 1 411 42 view .LVU368
 1465 0324 9B01      		movw r18,r22
 1466 0326 AC01      		movw r20,r24
 1467 0328 2829      		or r18,r8
 1468 032a 3929      		or r19,r9
 1469               	.LVL120:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1470               		.loc 1 411 42 is_stmt 0 view .LVU369
 1471 032c 4A29      		or r20,r10
 1472 032e 5B29      		or r21,r11
 1473 0330 2983      		std Y+1,r18
 1474 0332 3A83      		std Y+2,r19
 1475 0334 4B83      		std Y+3,r20
 1476 0336 5C83      		std Y+4,r21
 1477 0338 CA01      		movw r24,r20
 1478 033a B901      		movw r22,r18
 1479               	.LVL121:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1480               		.loc 1 411 42 view .LVU370
 1481 033c 0E94 0000 		call default_layer_xor
 1482               	.LVL122:
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1483               		.loc 1 411 74 is_stmt 1 view .LVU371
 411:./tmk_core/common/action.c ****                         case OP_BIT_SET: default_layer_and(mask); default_layer_or(bits); break;
 1484               		.loc 1 411 25 is_stmt 0 view .LVU372
 1485 0340 00C0      		rjmp .L117
 1486               	.LVL123:
 1487               	.L120:
 412:./tmk_core/common/action.c ****                     }
 1488               		.loc 1 412 42 is_stmt 1 view .LVU373
 1489 0342 0E94 0000 		call default_layer_and
 1490               	.LVL124:
 412:./tmk_core/common/action.c ****                     }
 1491               		.loc 1 412 67 view .LVU374
 1492 0346 C501      		movw r24,r10
 1493 0348 B401      		movw r22,r8
 1494               	.L186:
 1495 034a 0E94 0000 		call default_layer_or
 1496               	.LVL125:
 412:./tmk_core/common/action.c ****                     }
 1497               		.loc 1 412 91 view .LVU375
 412:./tmk_core/common/action.c ****                     }
 1498               		.loc 1 412 25 is_stmt 0 view .LVU376
 1499 034e 00C0      		rjmp .L117
 1500               	.LVL126:
 1501               	.L116:
 412:./tmk_core/common/action.c ****                     }
 1502               		.loc 1 412 25 view .LVU377
 1503               	.LBE26:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1504               		.loc 1 417 17 is_stmt 1 view .LVU378
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1505               		.loc 1 417 21 is_stmt 0 view .LVU379
 1506 0350 8695      		lsr r24
 1507 0352 1123      		tst r17
 1508 0354 01F0      		breq .L123
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1509               		.loc 1 417 21 discriminator 1 view .LVU380
 1510 0356 8981      		ldd r24,Y+1
 1511 0358 8170      		andi r24,lo8(1)
 1512               	.L123:
 417:./tmk_core/common/action.c ****                                     (action.layer_bitop.on & ON_RELEASE)) {
 1513               		.loc 1 417 20 discriminator 4 view .LVU381
 1514 035a 8823      		tst r24
 1515 035c 01F0      		breq .L117
 1516               	.LBB27:
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1517               		.loc 1 419 21 is_stmt 1 view .LVU382
 1518               	.LVL127:
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1519               		.loc 1 420 21 view .LVU383
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1520               		.loc 1 419 55 is_stmt 0 view .LVU384
 1521 035e 2D81      		ldd r18,Y+5
 1522 0360 2295      		swap r18
 1523 0362 2695      		lsr r18
 1524 0364 2770      		andi r18,lo8(7)
 419:./tmk_core/common/action.c ****                     uint32_t bits = ((uint32_t)action.layer_bitop.bits)<<shift;
 1525               		.loc 1 419 29 view .LVU385
 1526 0366 220F      		lsl r18
 1527 0368 220F      		lsl r18
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1528               		.loc 1 420 66 view .LVU386
 1529 036a 8D81      		ldd r24,Y+5
 1530 036c 8F70      		andi r24,lo8(15)
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1531               		.loc 1 420 38 view .LVU387
 1532 036e 90E0      		ldi r25,0
 1533 0370 B0E0      		ldi r27,0
 1534 0372 A0E0      		ldi r26,0
 420:./tmk_core/common/action.c ****                     uint32_t mask = (action.layer_bitop.xbit) ? ~(((uint32_t)0xf)<<shift) : 0;
 1535               		.loc 1 420 30 view .LVU388
 1536 0374 4C01      		movw r8,r24
 1537 0376 5D01      		movw r10,r26
 1538 0378 022E      		mov r0,r18
 1539 037a 00C0      		rjmp 2f
 1540               		1:
 1541 037c 880C      		lsl r8
 1542 037e 991C      		rol r9
 1543 0380 AA1C      		rol r10
 1544 0382 BB1C      		rol r11
 1545               		2:
 1546 0384 0A94      		dec r0
 1547 0386 02F4      		brpl 1b
 1548               	.LVL128:
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1549               		.loc 1 421 21 is_stmt 1 view .LVU389
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1550               		.loc 1 421 91 is_stmt 0 view .LVU390
 1551 0388 3D81      		ldd r19,Y+5
 1552 038a 60E0      		ldi r22,0
 1553 038c 70E0      		ldi r23,0
 1554 038e CB01      		movw r24,r22
 1555 0390 34FF      		sbrs r19,4
 1556 0392 00C0      		rjmp .L124
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1557               		.loc 1 421 82 discriminator 1 view .LVU391
 1558 0394 6FE0      		ldi r22,lo8(15)
 1559 0396 70E0      		ldi r23,0
 1560 0398 80E0      		ldi r24,0
 1561 039a 90E0      		ldi r25,0
 1562 039c 00C0      		rjmp 2f
 1563               		1:
 1564 039e 660F      		lsl r22
 1565 03a0 771F      		rol r23
 1566 03a2 881F      		rol r24
 1567 03a4 991F      		rol r25
 1568               		2:
 1569 03a6 2A95      		dec r18
 1570 03a8 02F4      		brpl 1b
 421:./tmk_core/common/action.c ****                     switch (action.layer_bitop.op) {
 1571               		.loc 1 421 91 discriminator 1 view .LVU392
 1572 03aa 6095      		com r22
 1573 03ac 7095      		com r23
 1574 03ae 8095      		com r24
 1575 03b0 9095      		com r25
 1576               	.L124:
 1577               	.LVL129:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1578               		.loc 1 422 21 is_stmt 1 discriminator 4 view .LVU393
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1579               		.loc 1 422 47 is_stmt 0 discriminator 4 view .LVU394
 1580 03b2 4981      		ldd r20,Y+1
 1581 03b4 4695      		lsr r20
 1582 03b6 4695      		lsr r20
 1583 03b8 4370      		andi r20,lo8(3)
 1584 03ba 4D83      		std Y+5,r20
 1585               	.LVL130:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1586               		.loc 1 422 47 discriminator 4 view .LVU395
 1587 03bc 4230      		cpi r20,lo8(2)
 1588 03be 01F0      		breq .L125
 1589 03c0 4330      		cpi r20,lo8(3)
 1590 03c2 01F0      		breq .L126
 1591 03c4 9B01      		movw r18,r22
 1592 03c6 AC01      		movw r20,r24
 1593 03c8 2829      		or r18,r8
 1594 03ca 3929      		or r19,r9
 1595               	.LVL131:
 422:./tmk_core/common/action.c ****                         case OP_BIT_AND: layer_and(bits | mask); break;
 1596               		.loc 1 422 47 discriminator 4 view .LVU396
 1597 03cc 4A29      		or r20,r10
 1598 03ce 5B29      		or r21,r11
 1599 03d0 2983      		std Y+1,r18
 1600 03d2 3A83      		std Y+2,r19
 1601 03d4 4B83      		std Y+3,r20
 1602 03d6 5C83      		std Y+4,r21
 1603 03d8 3D81      		ldd r19,Y+5
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1604               		.loc 1 423 42 view .LVU397
 1605 03da 6981      		ldd r22,Y+1
 1606 03dc 7A81      		ldd r23,Y+2
 1607 03de 8B81      		ldd r24,Y+3
 1608 03e0 9C81      		ldd r25,Y+4
 1609               	.LVL132:
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1610               		.loc 1 423 42 view .LVU398
 1611 03e2 3130      		cpi r19,lo8(1)
 1612 03e4 01F0      		breq .L187
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1613               		.loc 1 423 42 is_stmt 1 view .LVU399
 1614 03e6 0E94 0000 		call layer_and
 1615               	.LVL133:
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1616               		.loc 1 423 66 view .LVU400
 423:./tmk_core/common/action.c ****                         case OP_BIT_OR:  layer_or(bits | mask);  break;
 1617               		.loc 1 423 25 is_stmt 0 view .LVU401
 1618 03ea 00C0      		rjmp .L117
 1619               	.LVL134:
 1620               	.L125:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1621               		.loc 1 425 42 is_stmt 1 view .LVU402
 1622 03ec 9B01      		movw r18,r22
 1623 03ee AC01      		movw r20,r24
 1624 03f0 2829      		or r18,r8
 1625 03f2 3929      		or r19,r9
 1626               	.LVL135:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1627               		.loc 1 425 42 is_stmt 0 view .LVU403
 1628 03f4 4A29      		or r20,r10
 1629 03f6 5B29      		or r21,r11
 1630 03f8 2983      		std Y+1,r18
 1631 03fa 3A83      		std Y+2,r19
 1632 03fc 4B83      		std Y+3,r20
 1633 03fe 5C83      		std Y+4,r21
 1634 0400 CA01      		movw r24,r20
 1635 0402 B901      		movw r22,r18
 1636               	.LVL136:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1637               		.loc 1 425 42 view .LVU404
 1638 0404 0E94 0000 		call layer_xor
 1639               	.LVL137:
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1640               		.loc 1 425 66 is_stmt 1 view .LVU405
 425:./tmk_core/common/action.c ****                         case OP_BIT_SET: layer_and(mask); layer_or(bits); break;
 1641               		.loc 1 425 25 is_stmt 0 view .LVU406
 1642 0408 00C0      		rjmp .L117
 1643               	.LVL138:
 1644               	.L126:
 426:./tmk_core/common/action.c ****                     }
 1645               		.loc 1 426 42 is_stmt 1 view .LVU407
 1646 040a 0E94 0000 		call layer_and
 1647               	.LVL139:
 426:./tmk_core/common/action.c ****                     }
 1648               		.loc 1 426 59 view .LVU408
 1649 040e C501      		movw r24,r10
 1650 0410 B401      		movw r22,r8
 1651               	.L187:
 1652 0412 0E94 0000 		call layer_or
 1653               	.LVL140:
 426:./tmk_core/common/action.c ****                     }
 1654               		.loc 1 426 75 view .LVU409
 426:./tmk_core/common/action.c ****                     }
 1655               		.loc 1 426 25 is_stmt 0 view .LVU410
 1656 0416 00C0      		rjmp .L117
 1657               	.LVL141:
 1658               	.L73:
 426:./tmk_core/common/action.c ****                     }
 1659               		.loc 1 426 25 view .LVU411
 1660               	.LBE27:
 434:./tmk_core/common/action.c ****                 case 0xe0 ... 0xef:
 1661               		.loc 1 434 13 is_stmt 1 view .LVU412
 1662 0418 3D81      		ldd r19,Y+5
 1663 041a 323F      		cpi r19,lo8(-14)
 1664 041c 01F4      		brne .+2
 1665 041e 00C0      		rjmp .L128
 1666 0420 00F4      		brsh .L129
 1667 0422 303F      		cpi r19,lo8(-16)
 1668 0424 01F0      		breq .L130
 1669 0426 313F      		cpi r19,lo8(-15)
 1670 0428 01F4      		brne .+2
 1671 042a 00C0      		rjmp .L131
 1672 042c 832F      		mov r24,r19
 1673 042e 805E      		subi r24,lo8(-(32))
 1674 0430 8031      		cpi r24,lo8(16)
 1675 0432 00F0      		brlo .L180
 1676               	.L132:
 509:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1677               		.loc 1 509 21 view .LVU413
 509:./tmk_core/common/action.c ****                         if (tap_count > 0) {
 1678               		.loc 1 509 24 is_stmt 0 view .LVU414
 1679 0434 1123      		tst r17
 1680 0436 01F4      		brne .+2
 1681 0438 00C0      		rjmp .L144
 510:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1682               		.loc 1 510 25 is_stmt 1 view .LVU415
 510:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: register_code\n");
 1683               		.loc 1 510 28 is_stmt 0 view .LVU416
 1684 043a 0023      		tst r16
 1685 043c 01F4      		brne .+2
 1686 043e 00C0      		rjmp .L145
 511:./tmk_core/common/action.c ****                             register_code(action.layer_tap.code);
 1687               		.loc 1 511 75 is_stmt 1 view .LVU417
 512:./tmk_core/common/action.c ****                         } else {
 1688               		.loc 1 512 29 view .LVU418
 1689 0440 8D81      		ldd r24,Y+5
 1690 0442 0E94 0000 		call register_code
 1691               	.LVL142:
 1692 0446 00C0      		rjmp .L69
 1693               	.L129:
 1694 0448 4D81      		ldd r20,Y+5
 1695 044a 433F      		cpi r20,lo8(-13)
 1696 044c 01F4      		brne .+2
 1697 044e 00C0      		rjmp .L134
 1698 0450 443F      		cpi r20,lo8(-12)
 1699 0452 01F4      		brne .L132
 495:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1700               		.loc 1 495 21 view .LVU419
 495:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1701               		.loc 1 495 24 is_stmt 0 view .LVU420
 1702 0454 1123      		tst r17
 1703 0456 01F4      		brne .+2
 1704 0458 00C0      		rjmp .L143
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1705               		.loc 1 496 25 is_stmt 1 view .LVU421
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1706               		.loc 1 496 50 is_stmt 0 view .LVU422
 1707 045a 8981      		ldd r24,Y+1
 1708 045c 8F71      		andi r24,lo8(31)
 1709 045e 8983      		std Y+1,r24
 496:./tmk_core/common/action.c ****                         set_oneshot_layer(action.layer_tap.val, ONESHOT_START);
 1710               		.loc 1 496 25 view .LVU423
 1711 0460 0E94 0000 		call layer_on
 1712               	.LVL143:
 497:./tmk_core/common/action.c ****                     } else {
 1713               		.loc 1 497 25 is_stmt 1 view .LVU424
 1714 0464 63E0      		ldi r22,lo8(3)
 1715 0466 8981      		ldd r24,Y+1
 1716 0468 0E94 0000 		call set_oneshot_layer
 1717               	.LVL144:
 1718 046c 00C0      		rjmp .L69
 1719               	.L180:
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1720               		.loc 1 437 21 view .LVU425
 1721 046e 5D81      		ldd r21,Y+5
 1722 0470 5F70      		andi r21,lo8(15)
 1723 0472 5D83      		std Y+5,r21
 1724 0474 8981      		ldd r24,Y+1
 1725 0476 8F71      		andi r24,lo8(31)
 437:./tmk_core/common/action.c ****                         layer_on(action.layer_tap.val);
 1726               		.loc 1 437 24 is_stmt 0 view .LVU426
 1727 0478 1123      		tst r17
 1728 047a 01F0      		breq .L136
 438:./tmk_core/common/action.c ****                         register_mods(action.layer_tap.code & 0x0f);
 1729               		.loc 1 438 25 is_stmt 1 view .LVU427
 1730 047c 0E94 0000 		call layer_on
 1731               	.LVL145:
 439:./tmk_core/common/action.c ****                     } else {
 1732               		.loc 1 439 25 view .LVU428
 1733 0480 8D81      		ldd r24,Y+5
 1734 0482 0E94 0000 		call register_mods
 1735               	.LVL146:
 1736               	.L69:
 641:./tmk_core/common/action.c ****         case ACT_LAYER:
 1737               		.loc 1 641 5 view .LVU429
 1738 0486 38E0      		ldi r19,lo8(8)
 1739 0488 B316      		cp r11,r19
 1740 048a 01F4      		brne .+2
 1741 048c 00C0      		rjmp .L117
 1742 048e 00C0      		rjmp .L106
 1743               	.L136:
 441:./tmk_core/common/action.c ****                         unregister_mods(action.layer_tap.code & 0x0f);
 1744               		.loc 1 441 25 view .LVU430
 1745 0490 0E94 0000 		call layer_off
 1746               	.LVL147:
 442:./tmk_core/common/action.c ****                     }
 1747               		.loc 1 442 25 view .LVU431
 1748 0494 8D81      		ldd r24,Y+5
 1749 0496 0E94 0000 		call unregister_mods
 1750               	.LVL148:
 1751 049a 00C0      		rjmp .L69
 1752               	.L130:
 447:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1753               		.loc 1 447 21 view .LVU432
 447:./tmk_core/common/action.c ****                         if (tap_count < TAPPING_TOGGLE) {
 1754               		.loc 1 447 24 is_stmt 0 view .LVU433
 1755 049c 1123      		tst r17
 1756 049e 01F0      		breq .L137
 448:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1757               		.loc 1 448 25 is_stmt 1 view .LVU434
 448:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1758               		.loc 1 448 28 is_stmt 0 view .LVU435
 1759 04a0 0530      		cpi r16,lo8(5)
 1760 04a2 00F4      		brsh .L69
 1761               	.L138:
 449:./tmk_core/common/action.c ****                         }
 1762               		.loc 1 449 29 is_stmt 1 view .LVU436
 1763 04a4 8981      		ldd r24,Y+1
 1764 04a6 8F71      		andi r24,lo8(31)
 1765 04a8 0E94 0000 		call layer_invert
 1766               	.LVL149:
 1767 04ac 00C0      		rjmp .L69
 1768               	.L137:
 452:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1769               		.loc 1 452 25 view .LVU437
 452:./tmk_core/common/action.c ****                             layer_invert(action.layer_tap.val);
 1770               		.loc 1 452 28 is_stmt 0 view .LVU438
 1771 04ae 0630      		cpi r16,lo8(6)
 1772 04b0 00F4      		brsh .L69
 1773 04b2 00C0      		rjmp .L138
 1774               	.L131:
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1775               		.loc 1 458 21 is_stmt 1 view .LVU439
 1776 04b4 8981      		ldd r24,Y+1
 1777 04b6 8F71      		andi r24,lo8(31)
 458:./tmk_core/common/action.c ****                                     layer_off(action.layer_tap.val);
 1778               		.loc 1 458 68 is_stmt 0 view .LVU440
 1779 04b8 1123      		tst r17
 1780 04ba 01F0      		breq .L184
 1781               	.L185:
 515:./tmk_core/common/action.c ****                         }
 1782               		.loc 1 515 29 view .LVU441
 1783 04bc 0E94 0000 		call layer_on
 1784               	.LVL150:
 1785 04c0 00C0      		rjmp .L69
 1786               	.L128:
 462:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1787               		.loc 1 462 21 is_stmt 1 view .LVU442
 1788 04c2 8981      		ldd r24,Y+1
 1789 04c4 8F71      		andi r24,lo8(31)
 462:./tmk_core/common/action.c ****                                     layer_on(action.layer_tap.val);
 1790               		.loc 1 462 69 is_stmt 0 view .LVU443
 1791 04c6 1123      		tst r17
 1792 04c8 01F0      		breq .L185
 1793               	.L184:
 526:./tmk_core/common/action.c ****                         }
 1794               		.loc 1 526 29 view .LVU444
 1795 04ca 0E94 0000 		call layer_off
 1796               	.LVL151:
 1797 04ce 00C0      		rjmp .L69
 1798               	.L134:
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1799               		.loc 1 466 21 is_stmt 1 view .LVU445
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1800               		.loc 1 466 70 is_stmt 0 view .LVU446
 1801 04d0 1123      		tst r17
 1802 04d2 01F0      		breq .L142
 466:./tmk_core/common/action.c ****                                     layer_clear();
 1803               		.loc 1 466 37 discriminator 1 view .LVU447
 1804 04d4 8981      		ldd r24,Y+1
 1805 04d6 8F71      		andi r24,lo8(31)
 1806 04d8 0E94 0000 		call layer_move
 1807               	.LVL152:
 1808 04dc 00C0      		rjmp .L69
 1809               	.L142:
 467:./tmk_core/common/action.c ****                     break;
 1810               		.loc 1 467 37 view .LVU448
 1811 04de 0E94 0000 		call layer_clear
 1812               	.LVL153:
 1813 04e2 00C0      		rjmp .L69
 1814               	.L143:
 499:./tmk_core/common/action.c ****                         if (tap_count > 1) {
 1815               		.loc 1 499 25 is_stmt 1 view .LVU449
 1816 04e4 81E0      		ldi r24,lo8(1)
 1817 04e6 0E94 0000 		call clear_oneshot_layer_state
 1818               	.LVL154:
 500:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1819               		.loc 1 500 25 view .LVU450
 500:./tmk_core/common/action.c ****                             clear_oneshot_layer_state(ONESHOT_OTHER_KEY_PRESSED);
 1820               		.loc 1 500 28 is_stmt 0 view .LVU451
 1821 04ea 0230      		cpi r16,lo8(2)
 1822 04ec 00F0      		brlo .L69
 501:./tmk_core/common/action.c ****                         }
 1823               		.loc 1 501 29 is_stmt 1 view .LVU452
 1824 04ee 82E0      		ldi r24,lo8(2)
 1825 04f0 0E94 0000 		call clear_oneshot_layer_state
 1826               	.LVL155:
 1827 04f4 00C0      		rjmp .L69
 1828               	.L145:
 514:./tmk_core/common/action.c ****                             layer_on(action.layer_tap.val);
 1829               		.loc 1 514 76 view .LVU453
 515:./tmk_core/common/action.c ****                         }
 1830               		.loc 1 515 29 view .LVU454
 1831 04f6 8981      		ldd r24,Y+1
 1832 04f8 8F71      		andi r24,lo8(31)
 1833 04fa 00C0      		rjmp .L185
 1834               	.L144:
 518:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1835               		.loc 1 518 25 view .LVU455
 518:./tmk_core/common/action.c ****                             dprint("KEYMAP_TAP_KEY: Tap: unregister_code\n");
 1836               		.loc 1 518 28 is_stmt 0 view .LVU456
 1837 04fc 0023      		tst r16
 1838 04fe 01F0      		breq .L146
 519:./tmk_core/common/action.c ****                             if (action.layer_tap.code == KC_CAPS) {
 1839               		.loc 1 519 77 is_stmt 1 view .LVU457
 520:./tmk_core/common/action.c ****                                 wait_ms(80);
 1840               		.loc 1 520 29 view .LVU458
 520:./tmk_core/common/action.c ****                                 wait_ms(80);
 1841               		.loc 1 520 32 is_stmt 0 view .LVU459
 1842 0500 9D81      		ldd r25,Y+5
 1843 0502 9933      		cpi r25,lo8(57)
 1844 0504 01F4      		brne .L147
 521:./tmk_core/common/action.c ****                             }
 1845               		.loc 1 521 33 is_stmt 1 view .LVU460
 1846               	.LVL156:
 1847               	.LBB28:
 1848               	.LBI28:
 166:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** {
 1849               		.loc 2 166 1 view .LVU461
 1850               	.LBB29:
 168:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 1851               		.loc 2 168 2 view .LVU462
 172:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 1852               		.loc 2 172 2 view .LVU463
 173:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 1853               		.loc 2 173 2 view .LVU464
 174:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 
 1854               		.loc 2 174 2 view .LVU465
 184:/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/util/delay.h **** 	#endif
 1855               		.loc 2 184 3 view .LVU466
 1856               		.loc 2 187 2 view .LVU467
 1857 0506 EFEF      		ldi r30,lo8(255999)
 1858 0508 F7EE      		ldi r31,hi8(255999)
 1859 050a 23E0      		ldi r18,hlo8(255999)
 1860 050c E150      	1:	subi r30,1
 1861 050e F040      		sbci r31,0
 1862 0510 2040      		sbci r18,0
 1863 0512 01F4      		brne 1b
 1864 0514 00C0      		rjmp .
 1865 0516 0000      		nop
 1866               	.LVL157:
 1867               	.L147:
 1868               		.loc 2 187 2 is_stmt 0 view .LVU468
 1869               	.LBE29:
 1870               	.LBE28:
 523:./tmk_core/common/action.c ****                         } else {
 1871               		.loc 1 523 29 is_stmt 1 view .LVU469
 1872 0518 8D81      		ldd r24,Y+5
 1873 051a 0E94 0000 		call unregister_code
 1874               	.LVL158:
 1875 051e 00C0      		rjmp .L69
 1876               	.L146:
 525:./tmk_core/common/action.c ****                             layer_off(action.layer_tap.val);
 1877               		.loc 1 525 79 view .LVU470
 526:./tmk_core/common/action.c ****                         }
 1878               		.loc 1 526 29 view .LVU471
 1879 0520 8981      		ldd r24,Y+1
 1880 0522 8F71      		andi r24,lo8(31)
 1881 0524 00C0      		rjmp .L184
 1882               	.L72:
 537:./tmk_core/common/action.c ****             break;
 1883               		.loc 1 537 13 view .LVU472
 537:./tmk_core/common/action.c ****             break;
 1884               		.loc 1 537 83 is_stmt 0 view .LVU473
 1885 0526 4981      		ldd r20,Y+1
 1886 0528 4F70      		andi r20,lo8(15)
 537:./tmk_core/common/action.c ****             break;
 1887               		.loc 1 537 13 view .LVU474
 1888 052a 6D81      		ldd r22,Y+5
 1889 052c C701      		movw r24,r14
 1890 052e 0E94 0000 		call action_get_macro
 1891               	.LVL159:
 1892 0532 0E94 0000 		call action_macro_play
 1893               	.LVL160:
 538:./tmk_core/common/action.c **** #endif
 1894               		.loc 1 538 13 is_stmt 1 view .LVU475
 1895 0536 00C0      		rjmp .L85
 1896               	.L70:
 632:./tmk_core/common/action.c ****             break;
 1897               		.loc 1 632 13 view .LVU476
 632:./tmk_core/common/action.c ****             break;
 1898               		.loc 1 632 64 is_stmt 0 view .LVU477
 1899 0538 4981      		ldd r20,Y+1
 1900 053a 4F70      		andi r20,lo8(15)
 632:./tmk_core/common/action.c ****             break;
 1901               		.loc 1 632 13 view .LVU478
 1902 053c 6D81      		ldd r22,Y+5
 1903 053e C701      		movw r24,r14
 1904 0540 0E94 0000 		call action_function
 1905               	.LVL161:
 633:./tmk_core/common/action.c **** #endif
 1906               		.loc 1 633 13 is_stmt 1 view .LVU479
 1907 0544 00C0      		rjmp .L85
 1908               	.LVL162:
 1909               	.L66:
 1910               	/* epilogue start */
 691:./tmk_core/common/action.c **** 
 1911               		.loc 1 691 1 is_stmt 0 view .LVU480
 1912 0546 0F90      		pop __tmp_reg__
 1913 0548 0F90      		pop __tmp_reg__
 1914 054a 0F90      		pop __tmp_reg__
 1915 054c 0F90      		pop __tmp_reg__
 1916 054e 0F90      		pop __tmp_reg__
 1917 0550 DF91      		pop r29
 1918 0552 CF91      		pop r28
 1919 0554 1F91      		pop r17
 1920               	.LVL163:
 691:./tmk_core/common/action.c **** 
 1921               		.loc 1 691 1 view .LVU481
 1922 0556 0F91      		pop r16
 1923 0558 FF90      		pop r15
 1924 055a EF90      		pop r14
 1925               	.LVL164:
 691:./tmk_core/common/action.c **** 
 1926               		.loc 1 691 1 view .LVU482
 1927 055c DF90      		pop r13
 1928               	.LVL165:
 691:./tmk_core/common/action.c **** 
 1929               		.loc 1 691 1 view .LVU483
 1930 055e BF90      		pop r11
 1931 0560 AF90      		pop r10
 1932 0562 9F90      		pop r9
 1933 0564 8F90      		pop r8
 1934 0566 0895      		ret
 1935               		.cfi_endproc
 1936               	.LFE18:
 1938               		.section	.text.process_record,"ax",@progbits
 1939               	.global	process_record
 1941               	process_record:
 1942               	.LVL166:
 1943               	.LFB17:
 173:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1944               		.loc 1 173 1 is_stmt 1 view -0
 1945               		.cfi_startproc
 173:./tmk_core/common/action.c ****     if (IS_NOEVENT(record->event)) { return; }
 1946               		.loc 1 173 1 is_stmt 0 view .LVU485
 1947 0000 0F93      		push r16
 1948               	.LCFI18:
 1949               		.cfi_def_cfa_offset 3
 1950               		.cfi_offset 16, -2
 1951 0002 1F93      		push r17
 1952               	.LCFI19:
 1953               		.cfi_def_cfa_offset 4
 1954               		.cfi_offset 17, -3
 1955 0004 CF93      		push r28
 1956               	.LCFI20:
 1957               		.cfi_def_cfa_offset 5
 1958               		.cfi_offset 28, -4
 1959 0006 DF93      		push r29
 1960               	.LCFI21:
 1961               		.cfi_def_cfa_offset 6
 1962               		.cfi_offset 29, -5
 1963               	/* prologue: function */
 1964               	/* frame size = 0 */
 1965               	/* stack size = 4 */
 1966               	.L__stack_usage = 4
 1967 0008 EC01      		movw r28,r24
 174:./tmk_core/common/action.c **** 
 1968               		.loc 1 174 5 is_stmt 1 view .LVU486
 1969               	.LBB32:
 1970               	.LBI32:
 1971               		.file 3 "./tmk_core/common/keyboard.h"
   1:./tmk_core/common/keyboard.h **** /*
   2:./tmk_core/common/keyboard.h **** Copyright 2011,2012,2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/keyboard.h **** 
   4:./tmk_core/common/keyboard.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/keyboard.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/keyboard.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/keyboard.h **** (at your option) any later version.
   8:./tmk_core/common/keyboard.h **** 
   9:./tmk_core/common/keyboard.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/keyboard.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/keyboard.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/keyboard.h **** GNU General Public License for more details.
  13:./tmk_core/common/keyboard.h **** 
  14:./tmk_core/common/keyboard.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/keyboard.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/keyboard.h **** */
  17:./tmk_core/common/keyboard.h **** 
  18:./tmk_core/common/keyboard.h **** #ifndef KEYBOARD_H
  19:./tmk_core/common/keyboard.h **** #define KEYBOARD_H
  20:./tmk_core/common/keyboard.h **** 
  21:./tmk_core/common/keyboard.h **** #include <stdbool.h>
  22:./tmk_core/common/keyboard.h **** #include <stdint.h>
  23:./tmk_core/common/keyboard.h **** 
  24:./tmk_core/common/keyboard.h **** 
  25:./tmk_core/common/keyboard.h **** #ifdef __cplusplus
  26:./tmk_core/common/keyboard.h **** extern "C" {
  27:./tmk_core/common/keyboard.h **** #endif
  28:./tmk_core/common/keyboard.h **** 
  29:./tmk_core/common/keyboard.h **** /* key matrix position */
  30:./tmk_core/common/keyboard.h **** typedef struct {
  31:./tmk_core/common/keyboard.h ****     uint8_t col;
  32:./tmk_core/common/keyboard.h ****     uint8_t row;
  33:./tmk_core/common/keyboard.h **** } keypos_t;
  34:./tmk_core/common/keyboard.h **** 
  35:./tmk_core/common/keyboard.h **** /* key event */
  36:./tmk_core/common/keyboard.h **** typedef struct {
  37:./tmk_core/common/keyboard.h ****     keypos_t key;
  38:./tmk_core/common/keyboard.h ****     bool     pressed;
  39:./tmk_core/common/keyboard.h ****     uint16_t time;
  40:./tmk_core/common/keyboard.h **** } keyevent_t;
  41:./tmk_core/common/keyboard.h **** 
  42:./tmk_core/common/keyboard.h **** /* equivalent test of keypos_t */
  43:./tmk_core/common/keyboard.h **** #define KEYEQ(keya, keyb)       ((keya).row == (keyb).row && (keya).col == (keyb).col)
  44:./tmk_core/common/keyboard.h **** 
  45:./tmk_core/common/keyboard.h **** /* Rules for No Event:
  46:./tmk_core/common/keyboard.h ****  * 1) (time == 0) to handle (keyevent_t){} as empty event
  47:./tmk_core/common/keyboard.h ****  * 2) Matrix(255, 255) to make TICK event available
  48:./tmk_core/common/keyboard.h ****  */
  49:./tmk_core/common/keyboard.h **** static inline bool IS_NOEVENT(keyevent_t event) { return event.time == 0 || (event.key.row == 255 &
 1972               		.loc 3 49 20 view .LVU487
 1973               	.LBB33:
 1974               		.loc 3 49 51 view .LVU488
 1975               		.loc 3 49 74 is_stmt 0 view .LVU489
 1976 000a 8B81      		ldd r24,Y+3
 1977 000c 9C81      		ldd r25,Y+4
 1978               	.LVL167:
 1979               		.loc 3 49 74 view .LVU490
 1980 000e 892B      		or r24,r25
 1981 0010 01F0      		breq .L198
 1982 0012 8881      		ld r24,Y
 1983 0014 9981      		ldd r25,Y+1
 1984 0016 8923      		and r24,r25
 1985 0018 8F3F      		cpi r24,lo8(-1)
 1986 001a 01F4      		brne .L205
 1987               	.L198:
 1988               	/* epilogue start */
 1989               	.LBE33:
 1990               	.LBE32:
 188:./tmk_core/common/action.c **** 
 1991               		.loc 1 188 1 view .LVU491
 1992 001c DF91      		pop r29
 1993 001e CF91      		pop r28
 1994               	.LVL168:
 188:./tmk_core/common/action.c **** 
 1995               		.loc 1 188 1 view .LVU492
 1996 0020 1F91      		pop r17
 1997 0022 0F91      		pop r16
 1998 0024 0895      		ret
 1999               	.LVL169:
 2000               	.L205:
 176:./tmk_core/common/action.c ****         return;
 2001               		.loc 1 176 5 is_stmt 1 view .LVU493
 176:./tmk_core/common/action.c ****         return;
 2002               		.loc 1 176 9 is_stmt 0 view .LVU494
 2003 0026 CE01      		movw r24,r28
 2004 0028 0E94 0000 		call process_record_quantum
 2005               	.LVL170:
 176:./tmk_core/common/action.c ****         return;
 2006               		.loc 1 176 7 view .LVU495
 2007 002c 8823      		tst r24
 2008 002e 01F0      		breq .L198
 179:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 2009               		.loc 1 179 5 is_stmt 1 view .LVU496
 179:./tmk_core/common/action.c ****     dprint("ACTION: "); debug_action(action);
 2010               		.loc 1 179 23 is_stmt 0 view .LVU497
 2011 0030 6881      		ld r22,Y
 2012 0032 7981      		ldd r23,Y+1
 2013 0034 8A81      		ldd r24,Y+2
 2014 0036 0E94 0000 		call store_or_get_action
 2015               	.LVL171:
 2016 003a 8C01      		movw r16,r24
 180:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2017               		.loc 1 180 23 is_stmt 1 view .LVU498
 180:./tmk_core/common/action.c **** #ifndef NO_ACTION_LAYER
 2018               		.loc 1 180 25 view .LVU499
 182:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 2019               		.loc 1 182 29 view .LVU500
 182:./tmk_core/common/action.c ****     dprint(" default_layer_state: "); default_layer_debug();
 2020               		.loc 1 182 31 view .LVU501
 2021 003c 0E94 0000 		call layer_debug
 2022               	.LVL172:
 183:./tmk_core/common/action.c **** #endif
 2023               		.loc 1 183 37 view .LVU502
 183:./tmk_core/common/action.c **** #endif
 2024               		.loc 1 183 39 view .LVU503
 2025 0040 0E94 0000 		call default_layer_debug
 2026               	.LVL173:
 185:./tmk_core/common/action.c **** 
 2027               		.loc 1 185 15 view .LVU504
 187:./tmk_core/common/action.c **** }
 2028               		.loc 1 187 5 view .LVU505
 2029 0044 B801      		movw r22,r16
 2030 0046 CE01      		movw r24,r28
 2031               	/* epilogue start */
 188:./tmk_core/common/action.c **** 
 2032               		.loc 1 188 1 is_stmt 0 view .LVU506
 2033 0048 DF91      		pop r29
 2034 004a CF91      		pop r28
 2035               	.LVL174:
 188:./tmk_core/common/action.c **** 
 2036               		.loc 1 188 1 view .LVU507
 2037 004c 1F91      		pop r17
 2038 004e 0F91      		pop r16
 187:./tmk_core/common/action.c **** }
 2039               		.loc 1 187 5 view .LVU508
 2040 0050 0C94 0000 		jmp process_action
 2041               	.LVL175:
 187:./tmk_core/common/action.c **** }
 2042               		.loc 1 187 5 view .LVU509
 2043               		.cfi_endproc
 2044               	.LFE17:
 2046               		.section	.text.process_record_nocache,"ax",@progbits
 2047               	.global	process_record_nocache
 2049               	process_record_nocache:
 2050               	.LVL176:
 2051               	.LFB14:
 134:./tmk_core/common/action.c ****     process_record(record);
 2052               		.loc 1 134 1 is_stmt 1 view -0
 2053               		.cfi_startproc
 2054               	/* prologue: function */
 2055               	/* frame size = 0 */
 2056               	/* stack size = 0 */
 2057               	.L__stack_usage = 0
 135:./tmk_core/common/action.c **** }
 2058               		.loc 1 135 5 view .LVU511
 2059 0000 0C94 0000 		jmp process_record
 2060               	.LVL177:
 135:./tmk_core/common/action.c **** }
 2061               		.loc 1 135 5 is_stmt 0 view .LVU512
 2062               		.cfi_endproc
 2063               	.LFE14:
 2065               		.section	.text.clear_keyboard_but_mods,"ax",@progbits
 2066               	.global	clear_keyboard_but_mods
 2068               	clear_keyboard_but_mods:
 2069               	.LFB24:
 860:./tmk_core/common/action.c **** 
 861:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 862:./tmk_core/common/action.c ****  *
 863:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 864:./tmk_core/common/action.c ****  */
 865:./tmk_core/common/action.c **** void clear_keyboard(void)
 866:./tmk_core/common/action.c **** {
 867:./tmk_core/common/action.c ****     clear_mods();
 868:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 869:./tmk_core/common/action.c **** }
 870:./tmk_core/common/action.c **** 
 871:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 872:./tmk_core/common/action.c ****  *
 873:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 874:./tmk_core/common/action.c ****  */
 875:./tmk_core/common/action.c **** void clear_keyboard_but_mods(void)
 876:./tmk_core/common/action.c **** {
 2070               		.loc 1 876 1 is_stmt 1 view -0
 2071               		.cfi_startproc
 2072               	/* prologue: function */
 2073               	/* frame size = 0 */
 2074               	/* stack size = 0 */
 2075               	.L__stack_usage = 0
 877:./tmk_core/common/action.c ****     clear_weak_mods();
 2076               		.loc 1 877 5 view .LVU514
 2077 0000 0E94 0000 		call clear_weak_mods
 2078               	.LVL178:
 878:./tmk_core/common/action.c ****     clear_macro_mods();
 2079               		.loc 1 878 5 view .LVU515
 2080 0004 0E94 0000 		call clear_macro_mods
 2081               	.LVL179:
 879:./tmk_core/common/action.c ****     clear_keys();
 2082               		.loc 1 879 5 view .LVU516
 2083 0008 0E94 0000 		call clear_keys
 2084               	.LVL180:
 880:./tmk_core/common/action.c ****     send_keyboard_report();
 2085               		.loc 1 880 5 view .LVU517
 2086 000c 0E94 0000 		call send_keyboard_report
 2087               	.LVL181:
 881:./tmk_core/common/action.c **** #ifdef MOUSEKEY_ENABLE
 882:./tmk_core/common/action.c ****     mousekey_clear();
 2088               		.loc 1 882 5 view .LVU518
 2089 0010 0E94 0000 		call mousekey_clear
 2090               	.LVL182:
 883:./tmk_core/common/action.c ****     mousekey_send();
 2091               		.loc 1 883 5 view .LVU519
 2092 0014 0E94 0000 		call mousekey_send
 2093               	.LVL183:
 884:./tmk_core/common/action.c **** #endif
 885:./tmk_core/common/action.c **** #ifdef EXTRAKEY_ENABLE
 886:./tmk_core/common/action.c ****     host_system_send(0);
 2094               		.loc 1 886 5 view .LVU520
 2095 0018 90E0      		ldi r25,0
 2096 001a 80E0      		ldi r24,0
 2097 001c 0E94 0000 		call host_system_send
 2098               	.LVL184:
 887:./tmk_core/common/action.c ****     host_consumer_send(0);
 2099               		.loc 1 887 5 view .LVU521
 2100 0020 90E0      		ldi r25,0
 2101 0022 80E0      		ldi r24,0
 2102 0024 0C94 0000 		jmp host_consumer_send
 2103               	.LVL185:
 2104               		.cfi_endproc
 2105               	.LFE24:
 2107               		.section	.text.clear_keyboard,"ax",@progbits
 2108               	.global	clear_keyboard
 2110               	clear_keyboard:
 2111               	.LFB23:
 866:./tmk_core/common/action.c ****     clear_mods();
 2112               		.loc 1 866 1 view -0
 2113               		.cfi_startproc
 2114               	/* prologue: function */
 2115               	/* frame size = 0 */
 2116               	/* stack size = 0 */
 2117               	.L__stack_usage = 0
 867:./tmk_core/common/action.c ****     clear_keyboard_but_mods();
 2118               		.loc 1 867 5 view .LVU523
 2119 0000 0E94 0000 		call clear_mods
 2120               	.LVL186:
 868:./tmk_core/common/action.c **** }
 2121               		.loc 1 868 5 view .LVU524
 2122 0004 0C94 0000 		jmp clear_keyboard_but_mods
 2123               	.LVL187:
 2124               		.cfi_endproc
 2125               	.LFE23:
 2127               		.section	.text.is_tap_key,"ax",@progbits
 2128               	.global	is_tap_key
 2130               	is_tap_key:
 2131               	.LVL188:
 2132               	.LFB25:
 888:./tmk_core/common/action.c **** #endif
 889:./tmk_core/common/action.c **** }
 890:./tmk_core/common/action.c **** 
 891:./tmk_core/common/action.c **** /** \brief Utilities for actions. (FIXME: Needs better description)
 892:./tmk_core/common/action.c ****  *
 893:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 894:./tmk_core/common/action.c ****  */
 895:./tmk_core/common/action.c **** bool is_tap_key(keypos_t key)
 896:./tmk_core/common/action.c **** {
 2133               		.loc 1 896 1 view -0
 2134               		.cfi_startproc
 2135               	/* prologue: function */
 2136               	/* frame size = 0 */
 2137               	/* stack size = 0 */
 2138               	.L__stack_usage = 0
 897:./tmk_core/common/action.c ****     action_t action = layer_switch_get_action(key);
 2139               		.loc 1 897 5 view .LVU526
 2140               		.loc 1 897 23 is_stmt 0 view .LVU527
 2141 0000 0E94 0000 		call layer_switch_get_action
 2142               	.LVL189:
 2143               		.loc 1 897 23 view .LVU528
 2144 0004 282F      		mov r18,r24
 2145               	.LVL190:
 898:./tmk_core/common/action.c **** 
 899:./tmk_core/common/action.c ****     switch (action.kind.id) {
 2146               		.loc 1 899 5 is_stmt 1 view .LVU529
 2147               		.loc 1 899 24 is_stmt 0 view .LVU530
 2148 0006 892F      		mov r24,r25
 2149 0008 8295      		swap r24
 2150 000a 8F70      		andi r24,lo8(15)
 2151               		.loc 1 899 5 view .LVU531
 2152 000c 903C      		cpi r25,lo8(-64)
 2153 000e 00F4      		brsh .L210
 2154 0010 8A30      		cpi r24,lo8(10)
 2155 0012 00F4      		brsh .L211
 2156 0014 8430      		cpi r24,lo8(4)
 2157 0016 00F4      		brsh .L212
 2158 0018 8230      		cpi r24,lo8(2)
 2159 001a 00F4      		brsh .L211
 2160               	.L237:
 2161 001c 80E0      		ldi r24,0
 2162 001e 0895      		ret
 2163               	.L212:
 2164 0020 8630      		cpi r24,lo8(6)
 2165 0022 01F4      		brne .L237
 900:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 901:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:
 902:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:
 903:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:
 904:./tmk_core/common/action.c ****             switch (action.layer_tap.code) {
 905:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 906:./tmk_core/common/action.c ****                 case OP_TAP_TOGGLE:
 907:./tmk_core/common/action.c ****                 case OP_ONESHOT:
 908:./tmk_core/common/action.c ****                     return true;
 909:./tmk_core/common/action.c ****             }
 910:./tmk_core/common/action.c ****             return false;
 911:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:
 912:./tmk_core/common/action.c ****             switch (action.swap.code) {
 2166               		.loc 1 912 13 is_stmt 1 view .LVU532
 908:./tmk_core/common/action.c ****             }
 2167               		.loc 1 908 28 is_stmt 0 view .LVU533
 2168 0024 81E0      		ldi r24,lo8(1)
 2169 0026 203E      		cpi r18,lo8(-32)
 2170 0028 00F0      		brlo .L213
 2171 002a 213F      		cpi r18,lo8(-15)
 2172 002c 01F4      		brne .L237
 2173 002e 00C0      		rjmp .L213
 2174               	.L210:
 899:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:
 2175               		.loc 1 899 5 view .LVU534
 2176 0030 8C30      		cpi r24,lo8(12)
 2177 0032 01F0      		breq .L215
 2178 0034 8F30      		cpi r24,lo8(15)
 2179 0036 01F4      		brne .L237
 2180               	.L215:
 913:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 914:./tmk_core/common/action.c ****                 case OP_SH_TAP_TOGGLE:
 915:./tmk_core/common/action.c ****                     return true;
 916:./tmk_core/common/action.c ****             }
 917:./tmk_core/common/action.c ****             return false;
 918:./tmk_core/common/action.c ****         case ACT_MACRO:
 919:./tmk_core/common/action.c ****         case ACT_FUNCTION:
 920:./tmk_core/common/action.c ****             if (action.func.opt & FUNC_TAP) { return true; }
 2181               		.loc 1 920 13 is_stmt 1 view .LVU535
 2182               		.loc 1 920 16 is_stmt 0 view .LVU536
 2183 0038 93FB      		bst r25,3
 2184 003a 8827      		clr r24
 2185 003c 80F9      		bld r24,0
 2186 003e 0895      		ret
 2187               	.L211:
 904:./tmk_core/common/action.c ****                 case 0x00 ... 0xdf:
 2188               		.loc 1 904 13 is_stmt 1 view .LVU537
 2189 0040 81E0      		ldi r24,lo8(1)
 2190 0042 203F      		cpi r18,lo8(-16)
 2191 0044 01F0      		breq .L220
 2192 0046 00F4      		brsh .L216
 2193 0048 203E      		cpi r18,lo8(-32)
 2194 004a 00F4      		brsh .L237
 2195               	.L213:
 2196               	.LVL191:
 2197               	/* epilogue start */
 921:./tmk_core/common/action.c ****             return false;
 922:./tmk_core/common/action.c ****     }
 923:./tmk_core/common/action.c ****     return false;
 924:./tmk_core/common/action.c **** }
 2198               		.loc 1 924 1 is_stmt 0 view .LVU538
 2199 004c 0895      		ret
 2200               	.LVL192:
 2201               	.L216:
 2202               		.loc 1 924 1 view .LVU539
 2203 004e 243F      		cpi r18,lo8(-12)
 2204 0050 01F4      		brne .L237
 2205 0052 00C0      		rjmp .L213
 2206               	.L220:
 2207 0054 0895      		ret
 2208               		.cfi_endproc
 2209               	.LFE25:
 2211               		.section	.text.debug_event,"ax",@progbits
 2212               	.global	debug_event
 2214               	debug_event:
 2215               	.LFB26:
 925:./tmk_core/common/action.c **** 
 926:./tmk_core/common/action.c **** 
 927:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 928:./tmk_core/common/action.c ****  *
 929:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 930:./tmk_core/common/action.c ****  */
 931:./tmk_core/common/action.c **** void debug_event(keyevent_t event)
 932:./tmk_core/common/action.c **** {
 2216               		.loc 1 932 1 is_stmt 1 view -0
 2217               		.cfi_startproc
 2218 0000 CF93      		push r28
 2219               	.LCFI22:
 2220               		.cfi_def_cfa_offset 3
 2221               		.cfi_offset 28, -2
 2222 0002 DF93      		push r29
 2223               	.LCFI23:
 2224               		.cfi_def_cfa_offset 4
 2225               		.cfi_offset 29, -3
 2226 0004 00D0      		rcall .
 2227 0006 00D0      		rcall .
 2228 0008 0F92      		push __tmp_reg__
 2229               	.LCFI24:
 2230               		.cfi_def_cfa_offset 9
 2231 000a CDB7      		in r28,__SP_L__
 2232 000c DEB7      		in r29,__SP_H__
 2233               	.LCFI25:
 2234               		.cfi_def_cfa_register 28
 2235               	/* prologue: function */
 2236               	/* frame size = 5 */
 2237               	/* stack size = 7 */
 2238               	.L__stack_usage = 7
 933:./tmk_core/common/action.c ****     dprintf("%04X%c(%u)", (event.key.row<<8 | event.key.col), (event.pressed ? 'd' : 'u'), event.ti
 2239               		.loc 1 933 103 view .LVU541
 2240               	/* epilogue start */
 934:./tmk_core/common/action.c **** }
 2241               		.loc 1 934 1 is_stmt 0 view .LVU542
 2242 000e 0F90      		pop __tmp_reg__
 2243 0010 0F90      		pop __tmp_reg__
 2244 0012 0F90      		pop __tmp_reg__
 2245 0014 0F90      		pop __tmp_reg__
 2246 0016 0F90      		pop __tmp_reg__
 2247 0018 DF91      		pop r29
 2248 001a CF91      		pop r28
 2249 001c 0895      		ret
 2250               		.cfi_endproc
 2251               	.LFE26:
 2253               		.section	.text.debug_record,"ax",@progbits
 2254               	.global	debug_record
 2256               	debug_record:
 2257               	.LFB27:
 935:./tmk_core/common/action.c **** 
 936:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 937:./tmk_core/common/action.c ****  *
 938:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 939:./tmk_core/common/action.c ****  */
 940:./tmk_core/common/action.c **** void debug_record(keyrecord_t record)
 941:./tmk_core/common/action.c **** {
 2258               		.loc 1 941 1 is_stmt 1 view -0
 2259               		.cfi_startproc
 2260 0000 CF93      		push r28
 2261               	.LCFI26:
 2262               		.cfi_def_cfa_offset 3
 2263               		.cfi_offset 28, -2
 2264 0002 DF93      		push r29
 2265               	.LCFI27:
 2266               		.cfi_def_cfa_offset 4
 2267               		.cfi_offset 29, -3
 2268 0004 00D0      		rcall .
 2269 0006 00D0      		rcall .
 2270 0008 00D0      		rcall .
 2271               	.LCFI28:
 2272               		.cfi_def_cfa_offset 10
 2273 000a CDB7      		in r28,__SP_L__
 2274 000c DEB7      		in r29,__SP_H__
 2275               	.LCFI29:
 2276               		.cfi_def_cfa_register 28
 2277               	/* prologue: function */
 2278               	/* frame size = 6 */
 2279               	/* stack size = 8 */
 2280               	.L__stack_usage = 8
 942:./tmk_core/common/action.c ****     debug_event(record.event);
 2281               		.loc 1 942 5 view .LVU544
 943:./tmk_core/common/action.c **** #ifndef NO_ACTION_TAPPING
 944:./tmk_core/common/action.c ****     dprintf(":%u%c", record.tap.count, (record.tap.interrupted ? '-' : ' '));
 2282               		.loc 1 944 77 view .LVU545
 2283               	/* epilogue start */
 945:./tmk_core/common/action.c **** #endif
 946:./tmk_core/common/action.c **** }
 2284               		.loc 1 946 1 is_stmt 0 view .LVU546
 2285 000e 2696      		adiw r28,6
 2286 0010 0FB6      		in __tmp_reg__,__SREG__
 2287 0012 F894      		cli
 2288 0014 DEBF      		out __SP_H__,r29
 2289 0016 0FBE      		out __SREG__,__tmp_reg__
 2290 0018 CDBF      		out __SP_L__,r28
 2291 001a DF91      		pop r29
 2292 001c CF91      		pop r28
 2293 001e 0895      		ret
 2294               		.cfi_endproc
 2295               	.LFE27:
 2297               		.section	.text.debug_action,"ax",@progbits
 2298               	.global	debug_action
 2300               	debug_action:
 2301               	.LVL193:
 2302               	.LFB28:
 947:./tmk_core/common/action.c **** 
 948:./tmk_core/common/action.c **** /** \brief Debug print (FIXME: Needs better description)
 949:./tmk_core/common/action.c ****  *
 950:./tmk_core/common/action.c ****  * FIXME: Needs documentation.
 951:./tmk_core/common/action.c ****  */
 952:./tmk_core/common/action.c **** void debug_action(action_t action)
 953:./tmk_core/common/action.c **** {
 2303               		.loc 1 953 1 is_stmt 1 view -0
 2304               		.cfi_startproc
 2305               	/* prologue: function */
 2306               	/* frame size = 0 */
 2307               	/* stack size = 0 */
 2308               	.L__stack_usage = 0
 954:./tmk_core/common/action.c ****     switch (action.kind.id) {
 2309               		.loc 1 954 5 view .LVU548
 955:./tmk_core/common/action.c ****         case ACT_LMODS:             dprint("ACT_LMODS");             break;
 956:./tmk_core/common/action.c ****         case ACT_RMODS:             dprint("ACT_RMODS");             break;
 957:./tmk_core/common/action.c ****         case ACT_LMODS_TAP:         dprint("ACT_LMODS_TAP");         break;
 958:./tmk_core/common/action.c ****         case ACT_RMODS_TAP:         dprint("ACT_RMODS_TAP");         break;
 959:./tmk_core/common/action.c ****         case ACT_USAGE:             dprint("ACT_USAGE");             break;
 960:./tmk_core/common/action.c ****         case ACT_MOUSEKEY:          dprint("ACT_MOUSEKEY");          break;
 961:./tmk_core/common/action.c ****         case ACT_LAYER:             dprint("ACT_LAYER");             break;
 962:./tmk_core/common/action.c ****         case ACT_LAYER_TAP:         dprint("ACT_LAYER_TAP");         break;
 963:./tmk_core/common/action.c ****         case ACT_LAYER_TAP_EXT:     dprint("ACT_LAYER_TAP_EXT");     break;
 964:./tmk_core/common/action.c ****         case ACT_MACRO:             dprint("ACT_MACRO");             break;
 965:./tmk_core/common/action.c ****         case ACT_COMMAND:           dprint("ACT_COMMAND");           break;
 966:./tmk_core/common/action.c ****         case ACT_FUNCTION:          dprint("ACT_FUNCTION");          break;
 967:./tmk_core/common/action.c ****         case ACT_SWAP_HANDS:        dprint("ACT_SWAP_HANDS");        break;
 968:./tmk_core/common/action.c ****         default:                    dprint("UNKNOWN");               break;
 969:./tmk_core/common/action.c ****     }
 970:./tmk_core/common/action.c ****     dprintf("[%X:%02X]", action.kind.param>>8, action.kind.param&0xff);
 2310               		.loc 1 970 71 view .LVU549
 2311               	/* epilogue start */
 971:./tmk_core/common/action.c **** }
 2312               		.loc 1 971 1 is_stmt 0 view .LVU550
 2313 0000 0895      		ret
 2314               		.cfi_endproc
 2315               	.LFE28:
 2317               		.comm	tp_buttons,2,1
 2318               		.text
 2319               	.Letext0:
 2320               		.file 4 "/usr/local/Cellar/avr-gcc@9/9.3.0_3/avr/include/stdint.h"
 2321               		.file 5 "./tmk_core/common/keycode.h"
 2322               		.file 6 "./tmk_core/common/report.h"
 2323               		.file 7 "./tmk_core/common/host.h"
 2324               		.file 8 "./tmk_core/common/mousekey.h"
 2325               		.file 9 "./tmk_core/common/command.h"
 2326               		.file 10 "./tmk_core/common/action_code.h"
 2327               		.file 11 "./tmk_core/common/action.h"
 2328               		.file 12 "./tmk_core/common/action_layer.h"
 2329               		.file 13 "./tmk_core/common/action_util.h"
 2330               		.file 14 "./tmk_core/common/avr/xprintf.h"
 2331               		.file 15 "./tmk_core/common/debug.h"
 2332               		.file 16 "./tmk_core/common/led.h"
 2333               		.file 17 "./tmk_core/common/action_macro.h"
 2334               		.file 18 "./tmk_core/common/action_tapping.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 action.c
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:4      *ABS*:000000000000003f __SREG__
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:13     .text.action_exec:0000000000000000 action_exec
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:93     .text.process_record_quantum:0000000000000000 process_record_quantum
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:115    .text.process_record_tap_hint:0000000000000000 process_record_tap_hint
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:140    .text.register_code:0000000000000000 register_code
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:528    .text.unregister_code:0000000000000000 unregister_code
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:686    .text.register_mods:0000000000000000 register_mods
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:715    .text.unregister_mods:0000000000000000 unregister_mods
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:744    .text.process_action:0000000000000000 process_action
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:1941   .text.process_record:0000000000000000 process_record
                            *COM*:0000000000000002 tp_buttons
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2049   .text.process_record_nocache:0000000000000000 process_record_nocache
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2068   .text.clear_keyboard_but_mods:0000000000000000 clear_keyboard_but_mods
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2110   .text.clear_keyboard:0000000000000000 clear_keyboard
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2130   .text.is_tap_key:0000000000000000 is_tap_key
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2214   .text.debug_event:0000000000000000 debug_event
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2256   .text.debug_record:0000000000000000 debug_record
/var/folders/_p/hcjbsmwn4x14x6mnhxrqw_c80000gn/T//ccFwP5CG.s:2300   .text.debug_action:0000000000000000 debug_action

UNDEFINED SYMBOLS
action_tapping_process
layer_switch_get_action
host_keyboard_leds
add_key
send_keyboard_report
del_key
command_proc
add_mods
host_system_send
host_consumer_send
del_mods
clear_weak_mods
is_oneshot_layer_active
clear_oneshot_layer_state
__tablejump2__
add_weak_mods
get_oneshot_layer_state
get_oneshot_layer
layer_on
layer_off
del_weak_mods
get_oneshot_mods
set_oneshot_mods
clear_oneshot_mods
mousekey_on
mousekey_send
mousekey_off
default_layer_and
led_set
default_layer_xor
default_layer_or
layer_and
layer_xor
layer_or
set_oneshot_layer
layer_invert
layer_move
layer_clear
action_get_macro
action_macro_play
action_function
store_or_get_action
layer_debug
default_layer_debug
clear_macro_mods
clear_keys
mousekey_clear
clear_mods
__do_clear_bss
