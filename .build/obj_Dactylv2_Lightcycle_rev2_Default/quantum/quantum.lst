   1               		.file	"quantum.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.do_code16,"ax",@progbits
  12               	do_code16:
  13               	.LFB28:
  14               		.file 1 "quantum/quantum.c"
   1:quantum/quantum.c **** /* Copyright 2016-2017 Jack Humbert
   2:quantum/quantum.c ****  *
   3:quantum/quantum.c ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/quantum.c ****  * it under the terms of the GNU General Public License as published by
   5:quantum/quantum.c ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/quantum.c ****  * (at your option) any later version.
   7:quantum/quantum.c ****  *
   8:quantum/quantum.c ****  * This program is distributed in the hope that it will be useful,
   9:quantum/quantum.c ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/quantum.c ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/quantum.c ****  * GNU General Public License for more details.
  12:quantum/quantum.c ****  *
  13:quantum/quantum.c ****  * You should have received a copy of the GNU General Public License
  14:quantum/quantum.c ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/quantum.c ****  */
  16:quantum/quantum.c **** 
  17:quantum/quantum.c **** #include "quantum.h"
  18:quantum/quantum.c **** #ifdef PROTOCOL_LUFA
  19:quantum/quantum.c **** #include "outputselect.h"
  20:quantum/quantum.c **** #endif
  21:quantum/quantum.c **** 
  22:quantum/quantum.c **** #ifndef TAPPING_TERM
  23:quantum/quantum.c **** #define TAPPING_TERM 200
  24:quantum/quantum.c **** #endif
  25:quantum/quantum.c **** 
  26:quantum/quantum.c **** #ifndef BREATHING_PERIOD
  27:quantum/quantum.c **** #define BREATHING_PERIOD 6
  28:quantum/quantum.c **** #endif
  29:quantum/quantum.c **** 
  30:quantum/quantum.c **** #include "backlight.h"
  31:quantum/quantum.c **** extern backlight_config_t backlight_config;
  32:quantum/quantum.c **** 
  33:quantum/quantum.c **** #ifdef FAUXCLICKY_ENABLE
  34:quantum/quantum.c **** #include "fauxclicky.h"
  35:quantum/quantum.c **** #endif
  36:quantum/quantum.c **** 
  37:quantum/quantum.c **** #ifdef API_ENABLE
  38:quantum/quantum.c **** #include "api.h"
  39:quantum/quantum.c **** #endif
  40:quantum/quantum.c **** 
  41:quantum/quantum.c **** #ifdef MIDI_ENABLE
  42:quantum/quantum.c **** #include "process_midi.h"
  43:quantum/quantum.c **** #endif
  44:quantum/quantum.c **** 
  45:quantum/quantum.c **** #ifdef AUDIO_ENABLE
  46:quantum/quantum.c ****   #ifndef GOODBYE_SONG
  47:quantum/quantum.c ****     #define GOODBYE_SONG SONG(GOODBYE_SOUND)
  48:quantum/quantum.c ****   #endif
  49:quantum/quantum.c ****   #ifndef AG_NORM_SONG
  50:quantum/quantum.c ****     #define AG_NORM_SONG SONG(AG_NORM_SOUND)
  51:quantum/quantum.c ****   #endif
  52:quantum/quantum.c ****   #ifndef AG_SWAP_SONG
  53:quantum/quantum.c ****     #define AG_SWAP_SONG SONG(AG_SWAP_SOUND)
  54:quantum/quantum.c ****   #endif
  55:quantum/quantum.c ****   float goodbye_song[][2] = GOODBYE_SONG;
  56:quantum/quantum.c ****   float ag_norm_song[][2] = AG_NORM_SONG;
  57:quantum/quantum.c ****   float ag_swap_song[][2] = AG_SWAP_SONG;
  58:quantum/quantum.c ****   #ifdef DEFAULT_LAYER_SONGS
  59:quantum/quantum.c ****     float default_layer_songs[][16][2] = DEFAULT_LAYER_SONGS;
  60:quantum/quantum.c ****   #endif
  61:quantum/quantum.c **** #endif
  62:quantum/quantum.c **** 
  63:quantum/quantum.c **** static void do_code16 (uint16_t code, void (*f) (uint8_t)) {
  15               		.loc 1 63 0
  16               		.cfi_startproc
  17               	.LVL0:
  18 0000 0F93      		push r16
  19               	.LCFI0:
  20               		.cfi_def_cfa_offset 3
  21               		.cfi_offset 16, -2
  22 0002 1F93      		push r17
  23               	.LCFI1:
  24               		.cfi_def_cfa_offset 4
  25               		.cfi_offset 17, -3
  26 0004 CF93      		push r28
  27               	.LCFI2:
  28               		.cfi_def_cfa_offset 5
  29               		.cfi_offset 28, -4
  30 0006 DF93      		push r29
  31               	.LCFI3:
  32               		.cfi_def_cfa_offset 6
  33               		.cfi_offset 29, -5
  34               	/* prologue: function */
  35               	/* frame size = 0 */
  36               	/* stack size = 4 */
  37               	.L__stack_usage = 4
  64:quantum/quantum.c ****   switch (code) {
  38               		.loc 1 64 0
  39 0008 9C01      		movw r18,r24
  40 000a 3A95      		dec r19
  41 000c 2115      		cp r18,__zero_reg__
  42 000e 3F41      		sbci r19,31
  43 0010 00F4      		brsh .L1
  44 0012 EB01      		movw r28,r22
  45 0014 8C01      		movw r16,r24
  65:quantum/quantum.c ****   case QK_MODS ... QK_MODS_MAX:
  66:quantum/quantum.c ****     break;
  67:quantum/quantum.c ****   default:
  68:quantum/quantum.c ****     return;
  69:quantum/quantum.c ****   }
  70:quantum/quantum.c **** 
  71:quantum/quantum.c ****   if (code & QK_LCTL)
  46               		.loc 1 71 0
  47 0016 90FF      		sbrs r25,0
  48 0018 00C0      		rjmp .L4
  72:quantum/quantum.c ****     f(KC_LCTL);
  49               		.loc 1 72 0
  50 001a 80EE      		ldi r24,lo8(-32)
  51               	.LVL1:
  52 001c FB01      		movw r30,r22
  53 001e 0995      		icall
  54               	.LVL2:
  55               	.L4:
  73:quantum/quantum.c ****   if (code & QK_LSFT)
  56               		.loc 1 73 0
  57 0020 11FF      		sbrs r17,1
  58 0022 00C0      		rjmp .L5
  74:quantum/quantum.c ****     f(KC_LSFT);
  59               		.loc 1 74 0
  60 0024 81EE      		ldi r24,lo8(-31)
  61 0026 FE01      		movw r30,r28
  62 0028 0995      		icall
  63               	.LVL3:
  64               	.L5:
  75:quantum/quantum.c ****   if (code & QK_LALT)
  65               		.loc 1 75 0
  66 002a 12FF      		sbrs r17,2
  67 002c 00C0      		rjmp .L6
  76:quantum/quantum.c ****     f(KC_LALT);
  68               		.loc 1 76 0
  69 002e 82EE      		ldi r24,lo8(-30)
  70 0030 FE01      		movw r30,r28
  71 0032 0995      		icall
  72               	.LVL4:
  73               	.L6:
  77:quantum/quantum.c ****   if (code & QK_LGUI)
  74               		.loc 1 77 0
  75 0034 13FF      		sbrs r17,3
  76 0036 00C0      		rjmp .L7
  78:quantum/quantum.c ****     f(KC_LGUI);
  77               		.loc 1 78 0
  78 0038 83EE      		ldi r24,lo8(-29)
  79 003a FE01      		movw r30,r28
  80 003c 0995      		icall
  81               	.LVL5:
  82               	.L7:
  79:quantum/quantum.c **** 
  80:quantum/quantum.c ****   if (code < QK_RMODS_MIN) return;
  83               		.loc 1 80 0
  84 003e 0115      		cp r16,__zero_reg__
  85 0040 1041      		sbci r17,16
  86 0042 00F0      		brlo .L1
  81:quantum/quantum.c **** 
  82:quantum/quantum.c ****   if (code & QK_RCTL)
  83:quantum/quantum.c ****     f(KC_RCTL);
  87               		.loc 1 83 0
  88 0044 84EE      		ldi r24,lo8(-28)
  89 0046 FE01      		movw r30,r28
  90 0048 0995      		icall
  91               	.LVL6:
  84:quantum/quantum.c ****   if (code & QK_RSFT)
  85:quantum/quantum.c ****     f(KC_RSFT);
  92               		.loc 1 85 0
  93 004a 85EE      		ldi r24,lo8(-27)
  94 004c FE01      		movw r30,r28
  95 004e 0995      		icall
  96               	.LVL7:
  86:quantum/quantum.c ****   if (code & QK_RALT)
  87:quantum/quantum.c ****     f(KC_RALT);
  97               		.loc 1 87 0
  98 0050 86EE      		ldi r24,lo8(-26)
  99 0052 FE01      		movw r30,r28
 100 0054 0995      		icall
 101               	.LVL8:
  88:quantum/quantum.c ****   if (code & QK_RGUI)
  89:quantum/quantum.c ****     f(KC_RGUI);
 102               		.loc 1 89 0
 103 0056 87EE      		ldi r24,lo8(-25)
 104 0058 FE01      		movw r30,r28
 105               	/* epilogue start */
  90:quantum/quantum.c **** }
 106               		.loc 1 90 0
 107 005a DF91      		pop r29
 108 005c CF91      		pop r28
 109               	.LVL9:
 110 005e 1F91      		pop r17
 111 0060 0F91      		pop r16
 112               	.LVL10:
  89:quantum/quantum.c **** }
 113               		.loc 1 89 0
 114 0062 0994      		ijmp
 115               	.LVL11:
 116               	.L1:
 117               	/* epilogue start */
 118               		.loc 1 90 0
 119 0064 DF91      		pop r29
 120 0066 CF91      		pop r28
 121 0068 1F91      		pop r17
 122 006a 0F91      		pop r16
 123 006c 0895      		ret
 124               		.cfi_endproc
 125               	.LFE28:
 127               		.section	.text.qk_register_weak_mods,"ax",@progbits
 129               	qk_register_weak_mods:
 130               	.LFB29:
  91:quantum/quantum.c **** 
  92:quantum/quantum.c **** static inline void qk_register_weak_mods(uint8_t kc) {
 131               		.loc 1 92 0
 132               		.cfi_startproc
 133               	.LVL12:
 134               	/* prologue: function */
 135               	/* frame size = 0 */
 136               	/* stack size = 0 */
 137               	.L__stack_usage = 0
  93:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 138               		.loc 1 93 0
 139 0000 8770      		andi r24,lo8(7)
 140               	.LVL13:
 141 0002 91E0      		ldi r25,lo8(1)
 142 0004 00C0      		rjmp 2f
 143               		1:
 144 0006 990F      		lsl r25
 145               		2:
 146 0008 8A95      		dec r24
 147 000a 02F4      		brpl 1b
 148 000c 892F      		mov r24,r25
 149 000e 0E94 0000 		call add_weak_mods
 150               	.LVL14:
  94:quantum/quantum.c ****     send_keyboard_report();
 151               		.loc 1 94 0
 152 0012 0C94 0000 		jmp send_keyboard_report
 153               	.LVL15:
 154               		.cfi_endproc
 155               	.LFE29:
 157               		.section	.text.qk_register_mods,"ax",@progbits
 159               	qk_register_mods:
 160               	.LFB31:
  95:quantum/quantum.c **** }
  96:quantum/quantum.c **** 
  97:quantum/quantum.c **** static inline void qk_unregister_weak_mods(uint8_t kc) {
  98:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
  99:quantum/quantum.c ****     send_keyboard_report();
 100:quantum/quantum.c **** }
 101:quantum/quantum.c **** 
 102:quantum/quantum.c **** static inline void qk_register_mods(uint8_t kc) {
 161               		.loc 1 102 0
 162               		.cfi_startproc
 163               	.LVL16:
 164               	/* prologue: function */
 165               	/* frame size = 0 */
 166               	/* stack size = 0 */
 167               	.L__stack_usage = 0
 103:quantum/quantum.c ****     add_weak_mods(MOD_BIT(kc));
 168               		.loc 1 103 0
 169 0000 8770      		andi r24,lo8(7)
 170               	.LVL17:
 171 0002 91E0      		ldi r25,lo8(1)
 172 0004 00C0      		rjmp 2f
 173               		1:
 174 0006 990F      		lsl r25
 175               		2:
 176 0008 8A95      		dec r24
 177 000a 02F4      		brpl 1b
 178 000c 892F      		mov r24,r25
 179 000e 0E94 0000 		call add_weak_mods
 180               	.LVL18:
 104:quantum/quantum.c ****     send_keyboard_report();
 181               		.loc 1 104 0
 182 0012 0C94 0000 		jmp send_keyboard_report
 183               	.LVL19:
 184               		.cfi_endproc
 185               	.LFE31:
 187               		.section	.text.qk_unregister_weak_mods,"ax",@progbits
 189               	qk_unregister_weak_mods:
 190               	.LFB30:
  97:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 191               		.loc 1 97 0
 192               		.cfi_startproc
 193               	.LVL20:
 194               	/* prologue: function */
 195               	/* frame size = 0 */
 196               	/* stack size = 0 */
 197               	.L__stack_usage = 0
  98:quantum/quantum.c ****     send_keyboard_report();
 198               		.loc 1 98 0
 199 0000 8770      		andi r24,lo8(7)
 200               	.LVL21:
 201 0002 91E0      		ldi r25,lo8(1)
 202 0004 00C0      		rjmp 2f
 203               		1:
 204 0006 990F      		lsl r25
 205               		2:
 206 0008 8A95      		dec r24
 207 000a 02F4      		brpl 1b
 208 000c 892F      		mov r24,r25
 209 000e 0E94 0000 		call del_weak_mods
 210               	.LVL22:
  99:quantum/quantum.c **** }
 211               		.loc 1 99 0
 212 0012 0C94 0000 		jmp send_keyboard_report
 213               	.LVL23:
 214               		.cfi_endproc
 215               	.LFE30:
 217               		.section	.text.qk_unregister_mods,"ax",@progbits
 219               	qk_unregister_mods:
 220               	.LFB32:
 105:quantum/quantum.c **** }
 106:quantum/quantum.c **** 
 107:quantum/quantum.c **** static inline void qk_unregister_mods(uint8_t kc) {
 221               		.loc 1 107 0
 222               		.cfi_startproc
 223               	.LVL24:
 224               	/* prologue: function */
 225               	/* frame size = 0 */
 226               	/* stack size = 0 */
 227               	.L__stack_usage = 0
 108:quantum/quantum.c ****     del_weak_mods(MOD_BIT(kc));
 228               		.loc 1 108 0
 229 0000 8770      		andi r24,lo8(7)
 230               	.LVL25:
 231 0002 91E0      		ldi r25,lo8(1)
 232 0004 00C0      		rjmp 2f
 233               		1:
 234 0006 990F      		lsl r25
 235               		2:
 236 0008 8A95      		dec r24
 237 000a 02F4      		brpl 1b
 238 000c 892F      		mov r24,r25
 239 000e 0E94 0000 		call del_weak_mods
 240               	.LVL26:
 109:quantum/quantum.c ****     send_keyboard_report();
 241               		.loc 1 109 0
 242 0012 0C94 0000 		jmp send_keyboard_report
 243               	.LVL27:
 244               		.cfi_endproc
 245               	.LFE32:
 247               		.section	.text.rgblight_toggle,"ax",@progbits
 248               		.weak	rgblight_toggle
 250               	rgblight_toggle:
 251               	.LFB10:
 252               		.file 2 "quantum/rgb.h"
   1:quantum/rgb.h **** /* Copyright 2017 Jack Humbert
   2:quantum/rgb.h ****  *
   3:quantum/rgb.h ****  * This program is free software: you can redistribute it and/or modify
   4:quantum/rgb.h ****  * it under the terms of the GNU General Public License as published by
   5:quantum/rgb.h ****  * the Free Software Foundation, either version 2 of the License, or
   6:quantum/rgb.h ****  * (at your option) any later version.
   7:quantum/rgb.h ****  *
   8:quantum/rgb.h ****  * This program is distributed in the hope that it will be useful,
   9:quantum/rgb.h ****  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  10:quantum/rgb.h ****  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  11:quantum/rgb.h ****  * GNU General Public License for more details.
  12:quantum/rgb.h ****  *
  13:quantum/rgb.h ****  * You should have received a copy of the GNU General Public License
  14:quantum/rgb.h ****  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  15:quantum/rgb.h ****  */
  16:quantum/rgb.h **** 
  17:quantum/rgb.h **** #ifndef RGB_H
  18:quantum/rgb.h **** #define RGB_H
  19:quantum/rgb.h **** 
  20:quantum/rgb.h **** __attribute__((weak))
  21:quantum/rgb.h **** void rgblight_toggle(void) {};
 253               		.loc 2 21 0
 254               		.cfi_startproc
 255               	/* prologue: function */
 256               	/* frame size = 0 */
 257               	/* stack size = 0 */
 258               	.L__stack_usage = 0
 259 0000 0895      		ret
 260               		.cfi_endproc
 261               	.LFE10:
 263               		.section	.text.rgblight_step,"ax",@progbits
 264               		.weak	rgblight_step
 266               	rgblight_step:
 267               	.LFB11:
  22:quantum/rgb.h **** 
  23:quantum/rgb.h **** __attribute__((weak))
  24:quantum/rgb.h **** void rgblight_step(void) {};
 268               		.loc 2 24 0
 269               		.cfi_startproc
 270               	/* prologue: function */
 271               	/* frame size = 0 */
 272               	/* stack size = 0 */
 273               	.L__stack_usage = 0
 274 0000 0895      		ret
 275               		.cfi_endproc
 276               	.LFE11:
 278               		.section	.text.rgblight_step_reverse,"ax",@progbits
 279               		.weak	rgblight_step_reverse
 281               	rgblight_step_reverse:
 282               	.LFB12:
  25:quantum/rgb.h **** 
  26:quantum/rgb.h **** __attribute__((weak))
  27:quantum/rgb.h **** void rgblight_step_reverse(void) {};
 283               		.loc 2 27 0
 284               		.cfi_startproc
 285               	/* prologue: function */
 286               	/* frame size = 0 */
 287               	/* stack size = 0 */
 288               	.L__stack_usage = 0
 289 0000 0895      		ret
 290               		.cfi_endproc
 291               	.LFE12:
 293               		.section	.text.rgblight_increase_hue,"ax",@progbits
 294               		.weak	rgblight_increase_hue
 296               	rgblight_increase_hue:
 297               	.LFB13:
  28:quantum/rgb.h **** 
  29:quantum/rgb.h **** __attribute__((weak))
  30:quantum/rgb.h **** void rgblight_increase_hue(void) {};
 298               		.loc 2 30 0
 299               		.cfi_startproc
 300               	/* prologue: function */
 301               	/* frame size = 0 */
 302               	/* stack size = 0 */
 303               	.L__stack_usage = 0
 304 0000 0895      		ret
 305               		.cfi_endproc
 306               	.LFE13:
 308               		.section	.text.rgblight_decrease_hue,"ax",@progbits
 309               		.weak	rgblight_decrease_hue
 311               	rgblight_decrease_hue:
 312               	.LFB14:
  31:quantum/rgb.h **** 
  32:quantum/rgb.h **** __attribute__((weak))
  33:quantum/rgb.h **** void rgblight_decrease_hue(void) {};
 313               		.loc 2 33 0
 314               		.cfi_startproc
 315               	/* prologue: function */
 316               	/* frame size = 0 */
 317               	/* stack size = 0 */
 318               	.L__stack_usage = 0
 319 0000 0895      		ret
 320               		.cfi_endproc
 321               	.LFE14:
 323               		.section	.text.rgblight_increase_sat,"ax",@progbits
 324               		.weak	rgblight_increase_sat
 326               	rgblight_increase_sat:
 327               	.LFB15:
  34:quantum/rgb.h **** 
  35:quantum/rgb.h **** __attribute__((weak))
  36:quantum/rgb.h **** void rgblight_increase_sat(void) {};
 328               		.loc 2 36 0
 329               		.cfi_startproc
 330               	/* prologue: function */
 331               	/* frame size = 0 */
 332               	/* stack size = 0 */
 333               	.L__stack_usage = 0
 334 0000 0895      		ret
 335               		.cfi_endproc
 336               	.LFE15:
 338               		.section	.text.rgblight_decrease_sat,"ax",@progbits
 339               		.weak	rgblight_decrease_sat
 341               	rgblight_decrease_sat:
 342               	.LFB16:
  37:quantum/rgb.h **** 
  38:quantum/rgb.h **** __attribute__((weak))
  39:quantum/rgb.h **** void rgblight_decrease_sat(void) {};
 343               		.loc 2 39 0
 344               		.cfi_startproc
 345               	/* prologue: function */
 346               	/* frame size = 0 */
 347               	/* stack size = 0 */
 348               	.L__stack_usage = 0
 349 0000 0895      		ret
 350               		.cfi_endproc
 351               	.LFE16:
 353               		.section	.text.rgblight_increase_val,"ax",@progbits
 354               		.weak	rgblight_increase_val
 356               	rgblight_increase_val:
 357               	.LFB17:
  40:quantum/rgb.h **** 
  41:quantum/rgb.h **** __attribute__((weak))
  42:quantum/rgb.h **** void rgblight_increase_val(void) {};
 358               		.loc 2 42 0
 359               		.cfi_startproc
 360               	/* prologue: function */
 361               	/* frame size = 0 */
 362               	/* stack size = 0 */
 363               	.L__stack_usage = 0
 364 0000 0895      		ret
 365               		.cfi_endproc
 366               	.LFE17:
 368               		.section	.text.rgblight_decrease_val,"ax",@progbits
 369               		.weak	rgblight_decrease_val
 371               	rgblight_decrease_val:
 372               	.LFB18:
  43:quantum/rgb.h **** 
  44:quantum/rgb.h **** __attribute__((weak))
  45:quantum/rgb.h **** void rgblight_decrease_val(void) {};
 373               		.loc 2 45 0
 374               		.cfi_startproc
 375               	/* prologue: function */
 376               	/* frame size = 0 */
 377               	/* stack size = 0 */
 378               	.L__stack_usage = 0
 379 0000 0895      		ret
 380               		.cfi_endproc
 381               	.LFE18:
 383               		.section	.text.rgblight_increase_speed,"ax",@progbits
 384               		.weak	rgblight_increase_speed
 386               	rgblight_increase_speed:
 387               	.LFB19:
  46:quantum/rgb.h **** 
  47:quantum/rgb.h **** __attribute__((weak))
  48:quantum/rgb.h **** void rgblight_increase_speed(void) {};
 388               		.loc 2 48 0
 389               		.cfi_startproc
 390               	/* prologue: function */
 391               	/* frame size = 0 */
 392               	/* stack size = 0 */
 393               	.L__stack_usage = 0
 394 0000 0895      		ret
 395               		.cfi_endproc
 396               	.LFE19:
 398               		.section	.text.rgblight_decrease_speed,"ax",@progbits
 399               		.weak	rgblight_decrease_speed
 401               	rgblight_decrease_speed:
 402               	.LFB20:
  49:quantum/rgb.h **** 
  50:quantum/rgb.h **** __attribute__((weak))
  51:quantum/rgb.h **** void rgblight_decrease_speed(void) {};
 403               		.loc 2 51 0
 404               		.cfi_startproc
 405               	/* prologue: function */
 406               	/* frame size = 0 */
 407               	/* stack size = 0 */
 408               	.L__stack_usage = 0
 409 0000 0895      		ret
 410               		.cfi_endproc
 411               	.LFE20:
 413               		.section	.text.register_code16,"ax",@progbits
 414               	.global	register_code16
 416               	register_code16:
 417               	.LFB33:
 110:quantum/quantum.c **** }
 111:quantum/quantum.c **** 
 112:quantum/quantum.c **** void register_code16 (uint16_t code) {
 418               		.loc 1 112 0
 419               		.cfi_startproc
 420               	.LVL28:
 421               		.loc 1 112 0
 422 0000 CF93      		push r28
 423               	.LCFI4:
 424               		.cfi_def_cfa_offset 3
 425               		.cfi_offset 28, -2
 426 0002 DF93      		push r29
 427               	.LCFI5:
 428               		.cfi_def_cfa_offset 4
 429               		.cfi_offset 29, -3
 430               	/* prologue: function */
 431               	/* frame size = 0 */
 432               	/* stack size = 2 */
 433               	.L__stack_usage = 2
 434 0004 EC01      		movw r28,r24
 113:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 435               		.loc 1 113 0
 436 0006 805E      		subi r24,-32
 437 0008 9109      		sbc r25,__zero_reg__
 438               	.LVL29:
 439 000a 0897      		sbiw r24,8
 440 000c 00F0      		brlo .L39
 441               		.loc 1 113 0 is_stmt 0 discriminator 1
 442 000e 2097      		sbiw r28,0
 443 0010 01F4      		brne .L40
 444               	.L39:
 114:quantum/quantum.c ****       do_code16 (code, qk_register_mods);
 445               		.loc 1 114 0 is_stmt 1
 446 0012 60E0      		ldi r22,lo8(gs(qk_register_mods))
 447 0014 70E0      		ldi r23,hi8(gs(qk_register_mods))
 448 0016 00C0      		rjmp .L42
 449               	.L40:
 115:quantum/quantum.c ****   } else {
 116:quantum/quantum.c ****       do_code16 (code, qk_register_weak_mods);
 450               		.loc 1 116 0
 451 0018 60E0      		ldi r22,lo8(gs(qk_register_weak_mods))
 452 001a 70E0      		ldi r23,hi8(gs(qk_register_weak_mods))
 453               	.L42:
 454 001c CE01      		movw r24,r28
 455 001e 0E94 0000 		call do_code16
 456               	.LVL30:
 117:quantum/quantum.c ****   }
 118:quantum/quantum.c ****   register_code (code);
 457               		.loc 1 118 0
 458 0022 8C2F      		mov r24,r28
 459               	/* epilogue start */
 119:quantum/quantum.c **** }
 460               		.loc 1 119 0
 461 0024 DF91      		pop r29
 462 0026 CF91      		pop r28
 463               	.LVL31:
 118:quantum/quantum.c **** }
 464               		.loc 1 118 0
 465 0028 0C94 0000 		jmp register_code
 466               	.LVL32:
 467               		.cfi_endproc
 468               	.LFE33:
 470               		.section	.text.unregister_code16,"ax",@progbits
 471               	.global	unregister_code16
 473               	unregister_code16:
 474               	.LFB34:
 120:quantum/quantum.c **** 
 121:quantum/quantum.c **** void unregister_code16 (uint16_t code) {
 475               		.loc 1 121 0
 476               		.cfi_startproc
 477               	.LVL33:
 478 0000 CF93      		push r28
 479               	.LCFI6:
 480               		.cfi_def_cfa_offset 3
 481               		.cfi_offset 28, -2
 482 0002 DF93      		push r29
 483               	.LCFI7:
 484               		.cfi_def_cfa_offset 4
 485               		.cfi_offset 29, -3
 486               	/* prologue: function */
 487               	/* frame size = 0 */
 488               	/* stack size = 2 */
 489               	.L__stack_usage = 2
 490 0004 EC01      		movw r28,r24
 122:quantum/quantum.c ****   unregister_code (code);
 491               		.loc 1 122 0
 492 0006 0E94 0000 		call unregister_code
 493               	.LVL34:
 123:quantum/quantum.c ****   if (IS_MOD(code) || code == KC_NO) {
 494               		.loc 1 123 0
 495 000a CE01      		movw r24,r28
 496 000c 805E      		subi r24,-32
 497 000e 9109      		sbc r25,__zero_reg__
 498 0010 0897      		sbiw r24,8
 499 0012 00F0      		brlo .L44
 500               		.loc 1 123 0 is_stmt 0 discriminator 1
 501 0014 2097      		sbiw r28,0
 502 0016 01F4      		brne .L45
 503               	.L44:
 124:quantum/quantum.c ****       do_code16 (code, qk_unregister_mods);
 504               		.loc 1 124 0 is_stmt 1
 505 0018 60E0      		ldi r22,lo8(gs(qk_unregister_mods))
 506 001a 70E0      		ldi r23,hi8(gs(qk_unregister_mods))
 507 001c 00C0      		rjmp .L46
 508               	.L45:
 125:quantum/quantum.c ****   } else {
 126:quantum/quantum.c ****       do_code16 (code, qk_unregister_weak_mods);
 509               		.loc 1 126 0
 510 001e 60E0      		ldi r22,lo8(gs(qk_unregister_weak_mods))
 511 0020 70E0      		ldi r23,hi8(gs(qk_unregister_weak_mods))
 512               	.L46:
 513 0022 CE01      		movw r24,r28
 514               	/* epilogue start */
 127:quantum/quantum.c ****   }
 128:quantum/quantum.c **** }
 515               		.loc 1 128 0
 516 0024 DF91      		pop r29
 517 0026 CF91      		pop r28
 518               	.LVL35:
 126:quantum/quantum.c ****   }
 519               		.loc 1 126 0
 520 0028 0C94 0000 		jmp do_code16
 521               	.LVL36:
 522               		.cfi_endproc
 523               	.LFE34:
 525               		.section	.text.process_action_kb,"ax",@progbits
 526               		.weak	process_action_kb
 528               	process_action_kb:
 529               	.LFB35:
 129:quantum/quantum.c **** 
 130:quantum/quantum.c **** __attribute__ ((weak))
 131:quantum/quantum.c **** bool process_action_kb(keyrecord_t *record) {
 530               		.loc 1 131 0
 531               		.cfi_startproc
 532               	.LVL37:
 533               	/* prologue: function */
 534               	/* frame size = 0 */
 535               	/* stack size = 0 */
 536               	.L__stack_usage = 0
 132:quantum/quantum.c ****   return true;
 133:quantum/quantum.c **** }
 537               		.loc 1 133 0
 538 0000 81E0      		ldi r24,lo8(1)
 539               	.LVL38:
 540 0002 0895      		ret
 541               		.cfi_endproc
 542               	.LFE35:
 544               		.section	.text.process_record_user,"ax",@progbits
 545               		.weak	process_record_user
 547               	process_record_user:
 548               	.LFB37:
 134:quantum/quantum.c **** 
 135:quantum/quantum.c **** __attribute__ ((weak))
 136:quantum/quantum.c **** bool process_record_kb(uint16_t keycode, keyrecord_t *record) {
 137:quantum/quantum.c ****   return process_record_user(keycode, record);
 138:quantum/quantum.c **** }
 139:quantum/quantum.c **** 
 140:quantum/quantum.c **** __attribute__ ((weak))
 141:quantum/quantum.c **** bool process_record_user(uint16_t keycode, keyrecord_t *record) {
 549               		.loc 1 141 0
 550               		.cfi_startproc
 551               	.LVL39:
 552               	/* prologue: function */
 553               	/* frame size = 0 */
 554               	/* stack size = 0 */
 555               	.L__stack_usage = 0
 142:quantum/quantum.c ****   return true;
 143:quantum/quantum.c **** }
 556               		.loc 1 143 0
 557 0000 81E0      		ldi r24,lo8(1)
 558               	.LVL40:
 559 0002 0895      		ret
 560               		.cfi_endproc
 561               	.LFE37:
 563               		.section	.text.process_record_kb,"ax",@progbits
 564               		.weak	process_record_kb
 566               	process_record_kb:
 567               	.LFB36:
 136:quantum/quantum.c ****   return process_record_user(keycode, record);
 568               		.loc 1 136 0
 569               		.cfi_startproc
 570               	.LVL41:
 571               	/* prologue: function */
 572               	/* frame size = 0 */
 573               	/* stack size = 0 */
 574               	.L__stack_usage = 0
 137:quantum/quantum.c **** }
 575               		.loc 1 137 0
 576 0000 0C94 0000 		jmp process_record_user
 577               	.LVL42:
 578               		.cfi_endproc
 579               	.LFE36:
 581               		.section	.text.reset_keyboard,"ax",@progbits
 582               	.global	reset_keyboard
 584               	reset_keyboard:
 585               	.LFB38:
 144:quantum/quantum.c **** 
 145:quantum/quantum.c **** void reset_keyboard(void) {
 586               		.loc 1 145 0
 587               		.cfi_startproc
 588               	/* prologue: function */
 589               	/* frame size = 0 */
 590               	/* stack size = 0 */
 591               	.L__stack_usage = 0
 146:quantum/quantum.c ****   clear_keyboard();
 592               		.loc 1 146 0
 593 0000 0E94 0000 		call clear_keyboard
 594               	.LVL43:
 595               	.LBB28:
 596               	.LBB29:
 597               		.file 3 "c:\\msys32\\home\\683654\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\\delay.h"
   1:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 598               		.loc 3 187 0
 599 0004 2FEF      		ldi r18,lo8(799999)
 600 0006 84E3      		ldi r24,hi8(799999)
 601 0008 9CE0      		ldi r25,hlo8(799999)
 602 000a 2150      	1:	subi r18,1
 603 000c 8040      		sbci r24,0
 604 000e 9040      		sbci r25,0
 605 0010 01F4      		brne 1b
 606 0012 00C0      		rjmp .
 607 0014 0000      		nop
 608               	.LBE29:
 609               	.LBE28:
 147:quantum/quantum.c **** #if defined(MIDI_ENABLE) && defined(MIDI_BASIC)
 148:quantum/quantum.c ****   process_midi_all_notes_off();
 149:quantum/quantum.c **** #endif
 150:quantum/quantum.c **** #if defined(AUDIO_ENABLE) && !defined(NO_MUSIC_MODE)
 151:quantum/quantum.c ****   music_all_notes_off();
 152:quantum/quantum.c ****   uint16_t timer_start = timer_read();
 153:quantum/quantum.c ****   PLAY_SONG(goodbye_song);
 154:quantum/quantum.c ****   shutdown_user();
 155:quantum/quantum.c ****   while(timer_elapsed(timer_start) < 250)
 156:quantum/quantum.c ****     wait_ms(1);
 157:quantum/quantum.c ****   stop_all_notes();
 158:quantum/quantum.c **** #else
 159:quantum/quantum.c ****   wait_ms(250);
 160:quantum/quantum.c **** #endif
 161:quantum/quantum.c **** // this is also done later in bootloader.c - not sure if it's neccesary here
 162:quantum/quantum.c **** #ifdef BOOTLOADER_CATERINA
 163:quantum/quantum.c ****   *(uint16_t *)0x0800 = 0x7777; // these two are a-star-specific
 610               		.loc 1 163 0
 611 0016 87E7      		ldi r24,lo8(119)
 612 0018 97E7      		ldi r25,lo8(119)
 613 001a 9093 0108 		sts 2048+1,r25
 614 001e 8093 0008 		sts 2048,r24
 164:quantum/quantum.c **** #endif
 165:quantum/quantum.c ****   bootloader_jump();
 615               		.loc 1 165 0
 616 0022 0C94 0000 		jmp bootloader_jump
 617               	.LVL44:
 618               		.cfi_endproc
 619               	.LFE38:
 621               		.section	.text.process_record_quantum,"ax",@progbits
 622               	.global	process_record_quantum
 624               	process_record_quantum:
 625               	.LFB39:
 166:quantum/quantum.c **** }
 167:quantum/quantum.c **** 
 168:quantum/quantum.c **** // Shift / paren setup
 169:quantum/quantum.c **** 
 170:quantum/quantum.c **** #ifndef LSPO_KEY
 171:quantum/quantum.c ****   #define LSPO_KEY KC_9
 172:quantum/quantum.c **** #endif
 173:quantum/quantum.c **** #ifndef RSPC_KEY
 174:quantum/quantum.c ****   #define RSPC_KEY KC_0
 175:quantum/quantum.c **** #endif
 176:quantum/quantum.c **** 
 177:quantum/quantum.c **** // Shift / Enter setup
 178:quantum/quantum.c **** #ifndef SFTENT_KEY
 179:quantum/quantum.c ****   #define SFTENT_KEY KC_ENT
 180:quantum/quantum.c **** #endif
 181:quantum/quantum.c **** 
 182:quantum/quantum.c **** static bool shift_interrupted[2] = {0, 0};
 183:quantum/quantum.c **** static uint16_t scs_timer[2] = {0, 0};
 184:quantum/quantum.c **** 
 185:quantum/quantum.c **** /* true if the last press of GRAVE_ESC was shifted (i.e. GUI or SHIFT were pressed), false otherwis
 186:quantum/quantum.c ****  * Used to ensure that the correct keycode is released if the key is released.
 187:quantum/quantum.c ****  */
 188:quantum/quantum.c **** static bool grave_esc_was_shifted = false;
 189:quantum/quantum.c **** 
 190:quantum/quantum.c **** bool process_record_quantum(keyrecord_t *record) {
 626               		.loc 1 190 0
 627               		.cfi_startproc
 628               	.LVL45:
 629 0000 0F93      		push r16
 630               	.LCFI8:
 631               		.cfi_def_cfa_offset 3
 632               		.cfi_offset 16, -2
 633 0002 1F93      		push r17
 634               	.LCFI9:
 635               		.cfi_def_cfa_offset 4
 636               		.cfi_offset 17, -3
 637 0004 CF93      		push r28
 638               	.LCFI10:
 639               		.cfi_def_cfa_offset 5
 640               		.cfi_offset 28, -4
 641 0006 DF93      		push r29
 642               	.LCFI11:
 643               		.cfi_def_cfa_offset 6
 644               		.cfi_offset 29, -5
 645               	/* prologue: function */
 646               	/* frame size = 0 */
 647               	/* stack size = 4 */
 648               	.L__stack_usage = 4
 649 0008 8C01      		movw r16,r24
 191:quantum/quantum.c **** 
 192:quantum/quantum.c ****   /* This gets the keycode from the key pressed */
 193:quantum/quantum.c ****   keypos_t key = record->event.key;
 650               		.loc 1 193 0
 651 000a FC01      		movw r30,r24
 652 000c C081      		ld r28,Z
 653 000e D181      		ldd r29,Z+1
 654               	.LVL46:
 194:quantum/quantum.c ****   uint16_t keycode;
 195:quantum/quantum.c **** 
 196:quantum/quantum.c ****   #if !defined(NO_ACTION_LAYER) && defined(PREVENT_STUCK_MODIFIERS)
 197:quantum/quantum.c ****     /* TODO: Use store_or_get_action() or a similar function. */
 198:quantum/quantum.c ****     if (!disable_action_cache) {
 199:quantum/quantum.c ****       uint8_t layer;
 200:quantum/quantum.c **** 
 201:quantum/quantum.c ****       if (record->event.pressed) {
 202:quantum/quantum.c ****         layer = layer_switch_get_layer(key);
 203:quantum/quantum.c ****         update_source_layers_cache(key, layer);
 204:quantum/quantum.c ****       } else {
 205:quantum/quantum.c ****         layer = read_source_layers_cache(key);
 206:quantum/quantum.c ****       }
 207:quantum/quantum.c ****       keycode = keymap_key_to_keycode(layer, key);
 208:quantum/quantum.c ****     } else
 209:quantum/quantum.c ****   #endif
 210:quantum/quantum.c ****     keycode = keymap_key_to_keycode(layer_switch_get_layer(key), key);
 655               		.loc 1 210 0
 656 0010 CE01      		movw r24,r28
 657               	.LVL47:
 658 0012 0E94 0000 		call layer_switch_get_layer
 659               	.LVL48:
 660 0016 BE01      		movw r22,r28
 661 0018 0E94 0000 		call keymap_key_to_keycode
 662               	.LVL49:
 663 001c EC01      		movw r28,r24
 664               	.LVL50:
 211:quantum/quantum.c **** 
 212:quantum/quantum.c ****     // This is how you use actions here
 213:quantum/quantum.c ****     // if (keycode == KC_LEAD) {
 214:quantum/quantum.c ****     //   action_t action;
 215:quantum/quantum.c ****     //   action.code = ACTION_DEFAULT_LAYER_SET(0);
 216:quantum/quantum.c ****     //   process_action(record, action);
 217:quantum/quantum.c ****     //   return false;
 218:quantum/quantum.c ****     // }
 219:quantum/quantum.c **** 
 220:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 221:quantum/quantum.c ****     preprocess_tap_dance(keycode, record);
 665               		.loc 1 221 0
 666 001e B801      		movw r22,r16
 667 0020 0E94 0000 		call preprocess_tap_dance
 668               	.LVL51:
 222:quantum/quantum.c ****   #endif
 223:quantum/quantum.c **** 
 224:quantum/quantum.c ****   if (!(
 225:quantum/quantum.c ****   #if defined(KEY_LOCK_ENABLE)
 226:quantum/quantum.c ****     // Must run first to be able to mask key_up events.
 227:quantum/quantum.c ****     process_key_lock(&keycode, record) &&
 228:quantum/quantum.c ****   #endif
 229:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(AUDIO_CLICKY)
 230:quantum/quantum.c ****       process_clicky(keycode, record) &&
 231:quantum/quantum.c ****   #endif //AUDIO_CLICKY
 232:quantum/quantum.c ****     process_record_kb(keycode, record) &&
 669               		.loc 1 232 0
 670 0024 B801      		movw r22,r16
 671 0026 CE01      		movw r24,r28
 672 0028 0E94 0000 		call process_record_kb
 673               	.LVL52:
 233:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 234:quantum/quantum.c ****     process_rgb_matrix(keycode, record) &&
 235:quantum/quantum.c ****   #endif
 236:quantum/quantum.c ****   #if defined(MIDI_ENABLE) && defined(MIDI_ADVANCED)
 237:quantum/quantum.c ****     process_midi(keycode, record) &&
 238:quantum/quantum.c ****   #endif
 239:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 240:quantum/quantum.c ****     process_audio(keycode, record) &&
 241:quantum/quantum.c ****   #endif
 242:quantum/quantum.c ****   #ifdef STENO_ENABLE
 243:quantum/quantum.c ****     process_steno(keycode, record) &&
 244:quantum/quantum.c ****   #endif
 245:quantum/quantum.c ****   #if ( defined(AUDIO_ENABLE) || (defined(MIDI_ENABLE) && defined(MIDI_BASIC))) && !defined(NO_MUSI
 246:quantum/quantum.c ****     process_music(keycode, record) &&
 247:quantum/quantum.c ****   #endif
 248:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 249:quantum/quantum.c ****     process_tap_dance(keycode, record) &&
 674               		.loc 1 249 0
 675 002c 8823      		tst r24
 676 002e 01F4      		brne .+2
 677 0030 00C0      		rjmp .L113
 678               		.loc 1 249 0 is_stmt 0 discriminator 2
 679 0032 B801      		movw r22,r16
 680 0034 CE01      		movw r24,r28
 681 0036 0E94 0000 		call process_tap_dance
 682               	.LVL53:
 232:quantum/quantum.c ****   #if defined(RGB_MATRIX_ENABLE) && defined(RGB_MATRIX_KEYPRESSES)
 683               		.loc 1 232 0 is_stmt 1 discriminator 2
 684 003a 8823      		tst r24
 685 003c 01F4      		brne .+2
 686 003e 00C0      		rjmp .L113
 250:quantum/quantum.c ****   #endif
 251:quantum/quantum.c ****   #ifndef DISABLE_LEADER
 252:quantum/quantum.c ****     process_leader(keycode, record) &&
 687               		.loc 1 252 0 discriminator 3
 688 0040 B801      		movw r22,r16
 689 0042 CE01      		movw r24,r28
 690 0044 0E94 0000 		call process_leader
 691               	.LVL54:
 249:quantum/quantum.c ****   #endif
 692               		.loc 1 249 0 discriminator 3
 693 0048 8823      		tst r24
 694 004a 01F4      		brne .+2
 695 004c 00C0      		rjmp .L113
 253:quantum/quantum.c ****   #endif
 254:quantum/quantum.c ****   #ifndef DISABLE_CHORDING
 255:quantum/quantum.c ****     process_chording(keycode, record) &&
 256:quantum/quantum.c ****   #endif
 257:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 258:quantum/quantum.c ****     process_combo(keycode, record) &&
 259:quantum/quantum.c ****   #endif
 260:quantum/quantum.c ****   #ifdef UNICODE_ENABLE
 261:quantum/quantum.c ****     process_unicode(keycode, record) &&
 262:quantum/quantum.c ****   #endif
 263:quantum/quantum.c ****   #ifdef UCIS_ENABLE
 264:quantum/quantum.c ****     process_ucis(keycode, record) &&
 265:quantum/quantum.c ****   #endif
 266:quantum/quantum.c ****   #ifdef PRINTING_ENABLE
 267:quantum/quantum.c ****     process_printer(keycode, record) &&
 268:quantum/quantum.c ****   #endif
 269:quantum/quantum.c ****   #ifdef AUTO_SHIFT_ENABLE
 270:quantum/quantum.c ****     process_auto_shift(keycode, record) &&
 271:quantum/quantum.c ****   #endif
 272:quantum/quantum.c ****   #ifdef UNICODEMAP_ENABLE
 273:quantum/quantum.c ****     process_unicode_map(keycode, record) &&
 274:quantum/quantum.c ****   #endif
 275:quantum/quantum.c ****   #ifdef TERMINAL_ENABLE
 276:quantum/quantum.c ****     process_terminal(keycode, record) &&
 277:quantum/quantum.c ****   #endif
 278:quantum/quantum.c ****       true)) {
 279:quantum/quantum.c ****     return false;
 280:quantum/quantum.c ****   }
 281:quantum/quantum.c **** 
 282:quantum/quantum.c ****   // Shift / paren setup
 283:quantum/quantum.c **** 
 284:quantum/quantum.c ****   switch(keycode) {
 696               		.loc 1 284 0
 697 004e C531      		cpi r28,21
 698 0050 FCE5      		ldi r31,92
 699 0052 DF07      		cpc r29,r31
 700 0054 01F4      		brne .L134
 701               	.LBB30:
 285:quantum/quantum.c ****     case RESET:
 286:quantum/quantum.c ****       if (record->event.pressed) {
 287:quantum/quantum.c ****         reset_keyboard();
 288:quantum/quantum.c ****       }
 289:quantum/quantum.c ****     return false;
 290:quantum/quantum.c ****     case DEBUG:
 291:quantum/quantum.c ****       if (record->event.pressed) {
 292:quantum/quantum.c ****           debug_enable = true;
 293:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 294:quantum/quantum.c ****       }
 295:quantum/quantum.c ****     return false;
 296:quantum/quantum.c ****   #ifdef FAUXCLICKY_ENABLE
 297:quantum/quantum.c ****   case FC_TOG:
 298:quantum/quantum.c ****     if (record->event.pressed) {
 299:quantum/quantum.c ****       FAUXCLICKY_TOGGLE;
 300:quantum/quantum.c ****     }
 301:quantum/quantum.c ****     return false;
 302:quantum/quantum.c ****   case FC_ON:
 303:quantum/quantum.c ****     if (record->event.pressed) {
 304:quantum/quantum.c ****       FAUXCLICKY_ON;
 305:quantum/quantum.c ****     }
 306:quantum/quantum.c ****     return false;
 307:quantum/quantum.c ****   case FC_OFF:
 308:quantum/quantum.c ****     if (record->event.pressed) {
 309:quantum/quantum.c ****       FAUXCLICKY_OFF;
 310:quantum/quantum.c ****     }
 311:quantum/quantum.c ****     return false;
 312:quantum/quantum.c ****   #endif
 313:quantum/quantum.c ****   #if defined(RGBLIGHT_ENABLE) || defined(RGB_MATRIX_ENABLE)
 314:quantum/quantum.c ****   case RGB_TOG:
 315:quantum/quantum.c ****     if (record->event.pressed) {
 316:quantum/quantum.c ****       rgblight_toggle();
 317:quantum/quantum.c ****     }
 318:quantum/quantum.c ****     return false;
 319:quantum/quantum.c ****   case RGB_MODE_FORWARD:
 320:quantum/quantum.c ****     if (record->event.pressed) {
 321:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 322:quantum/quantum.c ****       if(shifted) {
 323:quantum/quantum.c ****         rgblight_step_reverse();
 324:quantum/quantum.c ****       }
 325:quantum/quantum.c ****       else {
 326:quantum/quantum.c ****         rgblight_step();
 327:quantum/quantum.c ****       }
 328:quantum/quantum.c ****     }
 329:quantum/quantum.c ****     return false;
 330:quantum/quantum.c ****   case RGB_MODE_REVERSE:
 331:quantum/quantum.c ****     if (record->event.pressed) {
 332:quantum/quantum.c ****       uint8_t shifted = get_mods() & (MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT));
 333:quantum/quantum.c ****       if(shifted) {
 334:quantum/quantum.c ****         rgblight_step();
 335:quantum/quantum.c ****       }
 336:quantum/quantum.c ****       else {
 337:quantum/quantum.c ****         rgblight_step_reverse();
 338:quantum/quantum.c ****       }
 339:quantum/quantum.c ****     }
 340:quantum/quantum.c ****     return false;
 341:quantum/quantum.c ****   case RGB_HUI:
 342:quantum/quantum.c ****     if (record->event.pressed) {
 343:quantum/quantum.c ****       rgblight_increase_hue();
 344:quantum/quantum.c ****     }
 345:quantum/quantum.c ****     return false;
 346:quantum/quantum.c ****   case RGB_HUD:
 347:quantum/quantum.c ****     if (record->event.pressed) {
 348:quantum/quantum.c ****       rgblight_decrease_hue();
 349:quantum/quantum.c ****     }
 350:quantum/quantum.c ****     return false;
 351:quantum/quantum.c ****   case RGB_SAI:
 352:quantum/quantum.c ****     if (record->event.pressed) {
 353:quantum/quantum.c ****       rgblight_increase_sat();
 354:quantum/quantum.c ****     }
 355:quantum/quantum.c ****     return false;
 356:quantum/quantum.c ****   case RGB_SAD:
 357:quantum/quantum.c ****     if (record->event.pressed) {
 358:quantum/quantum.c ****       rgblight_decrease_sat();
 359:quantum/quantum.c ****     }
 360:quantum/quantum.c ****     return false;
 361:quantum/quantum.c ****   case RGB_VAI:
 362:quantum/quantum.c ****     if (record->event.pressed) {
 363:quantum/quantum.c ****       rgblight_increase_val();
 364:quantum/quantum.c ****     }
 365:quantum/quantum.c ****     return false;
 366:quantum/quantum.c ****   case RGB_VAD:
 367:quantum/quantum.c ****     if (record->event.pressed) {
 368:quantum/quantum.c ****       rgblight_decrease_val();
 369:quantum/quantum.c ****     }
 370:quantum/quantum.c ****     return false;
 371:quantum/quantum.c ****   case RGB_SPI:
 372:quantum/quantum.c ****     if (record->event.pressed) {
 373:quantum/quantum.c ****       rgblight_increase_speed();
 374:quantum/quantum.c ****     }
 375:quantum/quantum.c ****     return false;
 376:quantum/quantum.c ****   case RGB_SPD:
 377:quantum/quantum.c ****     if (record->event.pressed) {
 378:quantum/quantum.c ****       rgblight_decrease_speed();
 379:quantum/quantum.c ****     }
 380:quantum/quantum.c ****     return false;
 381:quantum/quantum.c ****   case RGB_MODE_PLAIN:
 382:quantum/quantum.c ****     if (record->event.pressed) {
 383:quantum/quantum.c ****       rgblight_mode(1);
 384:quantum/quantum.c ****     }
 385:quantum/quantum.c ****     return false;
 386:quantum/quantum.c ****   case RGB_MODE_BREATHE:
 387:quantum/quantum.c ****     if (record->event.pressed) {
 388:quantum/quantum.c ****       if ((2 <= rgblight_get_mode()) && (rgblight_get_mode() < 5)) {
 389:quantum/quantum.c ****         rgblight_step();
 390:quantum/quantum.c ****       } else {
 391:quantum/quantum.c ****         rgblight_mode(2);
 392:quantum/quantum.c ****       }
 393:quantum/quantum.c ****     }
 394:quantum/quantum.c ****     return false;
 395:quantum/quantum.c ****   case RGB_MODE_RAINBOW:
 396:quantum/quantum.c ****     if (record->event.pressed) {
 397:quantum/quantum.c ****       if ((6 <= rgblight_get_mode()) && (rgblight_get_mode() < 8)) {
 398:quantum/quantum.c ****         rgblight_step();
 399:quantum/quantum.c ****       } else {
 400:quantum/quantum.c ****         rgblight_mode(6);
 401:quantum/quantum.c ****       }
 402:quantum/quantum.c ****     }
 403:quantum/quantum.c ****     return false;
 404:quantum/quantum.c ****   case RGB_MODE_SWIRL:
 405:quantum/quantum.c ****     if (record->event.pressed) {
 406:quantum/quantum.c ****       if ((9 <= rgblight_get_mode()) && (rgblight_get_mode() < 14)) {
 407:quantum/quantum.c ****         rgblight_step();
 408:quantum/quantum.c ****       } else {
 409:quantum/quantum.c ****         rgblight_mode(9);
 410:quantum/quantum.c ****       }
 411:quantum/quantum.c ****     }
 412:quantum/quantum.c ****     return false;
 413:quantum/quantum.c ****   case RGB_MODE_SNAKE:
 414:quantum/quantum.c ****     if (record->event.pressed) {
 415:quantum/quantum.c ****       if ((15 <= rgblight_get_mode()) && (rgblight_get_mode() < 20)) {
 416:quantum/quantum.c ****         rgblight_step();
 417:quantum/quantum.c ****       } else {
 418:quantum/quantum.c ****         rgblight_mode(15);
 419:quantum/quantum.c ****       }
 420:quantum/quantum.c ****     }
 421:quantum/quantum.c ****     return false;
 422:quantum/quantum.c ****   case RGB_MODE_KNIGHT:
 423:quantum/quantum.c ****     if (record->event.pressed) {
 424:quantum/quantum.c ****       if ((21 <= rgblight_get_mode()) && (rgblight_get_mode() < 23)) {
 425:quantum/quantum.c ****         rgblight_step();
 426:quantum/quantum.c ****       } else {
 427:quantum/quantum.c ****         rgblight_mode(21);
 428:quantum/quantum.c ****       }
 429:quantum/quantum.c ****     }
 430:quantum/quantum.c ****     return false;
 431:quantum/quantum.c ****   case RGB_MODE_XMAS:
 432:quantum/quantum.c ****     if (record->event.pressed) {
 433:quantum/quantum.c ****       rgblight_mode(24);
 434:quantum/quantum.c ****     }
 435:quantum/quantum.c ****     return false;
 436:quantum/quantum.c ****   case RGB_MODE_GRADIENT:
 437:quantum/quantum.c ****     if (record->event.pressed) {
 438:quantum/quantum.c ****       if ((25 <= rgblight_get_mode()) && (rgblight_get_mode() < 34)) {
 439:quantum/quantum.c ****         rgblight_step();
 440:quantum/quantum.c ****       } else {
 441:quantum/quantum.c ****         rgblight_mode(25);
 442:quantum/quantum.c ****       }
 443:quantum/quantum.c ****     }
 444:quantum/quantum.c ****     return false;
 445:quantum/quantum.c ****   #endif
 446:quantum/quantum.c ****     #ifdef PROTOCOL_LUFA
 447:quantum/quantum.c ****     case OUT_AUTO:
 448:quantum/quantum.c ****       if (record->event.pressed) {
 449:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 450:quantum/quantum.c ****       }
 451:quantum/quantum.c ****       return false;
 452:quantum/quantum.c ****     case OUT_USB:
 453:quantum/quantum.c ****       if (record->event.pressed) {
 454:quantum/quantum.c ****         set_output(OUTPUT_USB);
 455:quantum/quantum.c ****       }
 456:quantum/quantum.c ****       return false;
 457:quantum/quantum.c ****     #ifdef BLUETOOTH_ENABLE
 458:quantum/quantum.c ****     case OUT_BT:
 459:quantum/quantum.c ****       if (record->event.pressed) {
 460:quantum/quantum.c ****         set_output(OUTPUT_BLUETOOTH);
 461:quantum/quantum.c ****       }
 462:quantum/quantum.c ****       return false;
 463:quantum/quantum.c ****     #endif
 464:quantum/quantum.c ****     #endif
 465:quantum/quantum.c ****     case MAGIC_SWAP_CONTROL_CAPSLOCK ... MAGIC_TOGGLE_NKRO:
 466:quantum/quantum.c ****       if (record->event.pressed) {
 467:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 468:quantum/quantum.c ****         if (!eeconfig_is_enabled()) {
 469:quantum/quantum.c ****             eeconfig_init();
 470:quantum/quantum.c ****         }
 471:quantum/quantum.c ****         /* keymap config */
 472:quantum/quantum.c ****         keymap_config.raw = eeconfig_read_keymap();
 473:quantum/quantum.c ****         switch (keycode)
 474:quantum/quantum.c ****         {
 475:quantum/quantum.c ****           case MAGIC_SWAP_CONTROL_CAPSLOCK:
 476:quantum/quantum.c ****             keymap_config.swap_control_capslock = true;
 477:quantum/quantum.c ****             break;
 478:quantum/quantum.c ****           case MAGIC_CAPSLOCK_TO_CONTROL:
 479:quantum/quantum.c ****             keymap_config.capslock_to_control = true;
 480:quantum/quantum.c ****             break;
 481:quantum/quantum.c ****           case MAGIC_SWAP_LALT_LGUI:
 482:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 483:quantum/quantum.c ****             break;
 484:quantum/quantum.c ****           case MAGIC_SWAP_RALT_RGUI:
 485:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 486:quantum/quantum.c ****             break;
 487:quantum/quantum.c ****           case MAGIC_NO_GUI:
 488:quantum/quantum.c ****             keymap_config.no_gui = true;
 489:quantum/quantum.c ****             break;
 490:quantum/quantum.c ****           case MAGIC_SWAP_GRAVE_ESC:
 491:quantum/quantum.c ****             keymap_config.swap_grave_esc = true;
 492:quantum/quantum.c ****             break;
 493:quantum/quantum.c ****           case MAGIC_SWAP_BACKSLASH_BACKSPACE:
 494:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = true;
 495:quantum/quantum.c ****             break;
 496:quantum/quantum.c ****           case MAGIC_HOST_NKRO:
 497:quantum/quantum.c ****             keymap_config.nkro = true;
 498:quantum/quantum.c ****             break;
 499:quantum/quantum.c ****           case MAGIC_SWAP_ALT_GUI:
 500:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = true;
 501:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = true;
 502:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 503:quantum/quantum.c ****               PLAY_SONG(ag_swap_song);
 504:quantum/quantum.c ****             #endif
 505:quantum/quantum.c ****             break;
 506:quantum/quantum.c ****           case MAGIC_UNSWAP_CONTROL_CAPSLOCK:
 507:quantum/quantum.c ****             keymap_config.swap_control_capslock = false;
 508:quantum/quantum.c ****             break;
 509:quantum/quantum.c ****           case MAGIC_UNCAPSLOCK_TO_CONTROL:
 510:quantum/quantum.c ****             keymap_config.capslock_to_control = false;
 511:quantum/quantum.c ****             break;
 512:quantum/quantum.c ****           case MAGIC_UNSWAP_LALT_LGUI:
 513:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 514:quantum/quantum.c ****             break;
 515:quantum/quantum.c ****           case MAGIC_UNSWAP_RALT_RGUI:
 516:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 517:quantum/quantum.c ****             break;
 518:quantum/quantum.c ****           case MAGIC_UNNO_GUI:
 519:quantum/quantum.c ****             keymap_config.no_gui = false;
 520:quantum/quantum.c ****             break;
 521:quantum/quantum.c ****           case MAGIC_UNSWAP_GRAVE_ESC:
 522:quantum/quantum.c ****             keymap_config.swap_grave_esc = false;
 523:quantum/quantum.c ****             break;
 524:quantum/quantum.c ****           case MAGIC_UNSWAP_BACKSLASH_BACKSPACE:
 525:quantum/quantum.c ****             keymap_config.swap_backslash_backspace = false;
 526:quantum/quantum.c ****             break;
 527:quantum/quantum.c ****           case MAGIC_UNHOST_NKRO:
 528:quantum/quantum.c ****             keymap_config.nkro = false;
 529:quantum/quantum.c ****             break;
 530:quantum/quantum.c ****           case MAGIC_UNSWAP_ALT_GUI:
 531:quantum/quantum.c ****             keymap_config.swap_lalt_lgui = false;
 532:quantum/quantum.c ****             keymap_config.swap_ralt_rgui = false;
 533:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 534:quantum/quantum.c ****               PLAY_SONG(ag_norm_song);
 535:quantum/quantum.c ****             #endif
 536:quantum/quantum.c ****             break;
 537:quantum/quantum.c ****           case MAGIC_TOGGLE_NKRO:
 538:quantum/quantum.c ****             keymap_config.nkro = !keymap_config.nkro;
 539:quantum/quantum.c ****             break;
 540:quantum/quantum.c ****           default:
 541:quantum/quantum.c ****             break;
 542:quantum/quantum.c ****         }
 543:quantum/quantum.c ****         eeconfig_update_keymap(keymap_config.raw);
 544:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 545:quantum/quantum.c **** 
 546:quantum/quantum.c ****         return false;
 547:quantum/quantum.c ****       }
 548:quantum/quantum.c ****       break;
 549:quantum/quantum.c ****     case KC_LSPO: {
 550:quantum/quantum.c ****       if (record->event.pressed) {
 551:quantum/quantum.c ****         shift_interrupted[0] = false;
 552:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 553:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 554:quantum/quantum.c ****       }
 555:quantum/quantum.c ****       else {
 556:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 557:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_RSFT)) {
 558:quantum/quantum.c ****             shift_interrupted[0] = true;
 559:quantum/quantum.c ****             shift_interrupted[1] = true;
 560:quantum/quantum.c ****           }
 561:quantum/quantum.c ****         #endif
 562:quantum/quantum.c ****         if (!shift_interrupted[0] && timer_elapsed(scs_timer[0]) < TAPPING_TERM) {
 563:quantum/quantum.c ****           register_code(LSPO_KEY);
 564:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 565:quantum/quantum.c ****         }
 566:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_LSFT));
 567:quantum/quantum.c ****       }
 568:quantum/quantum.c ****       return false;
 569:quantum/quantum.c ****     }
 570:quantum/quantum.c **** 
 571:quantum/quantum.c ****     case KC_RSPC: {
 572:quantum/quantum.c ****       if (record->event.pressed) {
 573:quantum/quantum.c ****         shift_interrupted[1] = false;
 574:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 575:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 576:quantum/quantum.c ****       }
 577:quantum/quantum.c ****       else {
 578:quantum/quantum.c ****         #ifdef DISABLE_SPACE_CADET_ROLLOVER
 579:quantum/quantum.c ****           if (get_mods() & MOD_BIT(KC_LSFT)) {
 580:quantum/quantum.c ****             shift_interrupted[0] = true;
 581:quantum/quantum.c ****             shift_interrupted[1] = true;
 582:quantum/quantum.c ****           }
 583:quantum/quantum.c ****         #endif
 584:quantum/quantum.c ****         if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 585:quantum/quantum.c ****           register_code(RSPC_KEY);
 586:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 587:quantum/quantum.c ****         }
 588:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 589:quantum/quantum.c ****       }
 590:quantum/quantum.c ****       return false;
 591:quantum/quantum.c ****     }
 592:quantum/quantum.c **** 
 593:quantum/quantum.c ****     case KC_SFTENT: {
 594:quantum/quantum.c ****       if (record->event.pressed) {
 595:quantum/quantum.c ****         shift_interrupted[1] = false;
 596:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 597:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 598:quantum/quantum.c ****       }
 599:quantum/quantum.c ****       else if (!shift_interrupted[1] && timer_elapsed(scs_timer[1]) < TAPPING_TERM) {
 600:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 601:quantum/quantum.c ****         register_code(SFTENT_KEY);
 602:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 603:quantum/quantum.c ****       }
 604:quantum/quantum.c ****       else {
 605:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 606:quantum/quantum.c ****       }
 607:quantum/quantum.c ****       return false;
 608:quantum/quantum.c ****     }
 609:quantum/quantum.c **** 
 610:quantum/quantum.c ****     case GRAVE_ESC: {
 611:quantum/quantum.c ****       uint8_t shifted = get_mods() & ((MOD_BIT(KC_LSHIFT)|MOD_BIT(KC_RSHIFT)
 702               		.loc 1 611 0
 703 0056 0E94 0000 		call get_mods
 704               	.LVL55:
 705 005a 282F      		mov r18,r24
 706               	.LVL56:
 612:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 613:quantum/quantum.c **** 
 614:quantum/quantum.c **** #ifdef GRAVE_ESC_ALT_OVERRIDE
 615:quantum/quantum.c ****       // if ALT is pressed, ESC is always sent
 616:quantum/quantum.c ****       // this is handy for the cmd+opt+esc shortcut on macOS, among other things.
 617:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LALT) | MOD_BIT(KC_RALT))) {
 618:quantum/quantum.c ****         shifted = 0;
 619:quantum/quantum.c ****       }
 620:quantum/quantum.c **** #endif
 621:quantum/quantum.c **** 
 622:quantum/quantum.c **** #ifdef GRAVE_ESC_CTRL_OVERRIDE
 623:quantum/quantum.c ****       // if CTRL is pressed, ESC is always sent
 624:quantum/quantum.c ****       // this is handy for the ctrl+shift+esc shortcut on windows, among other things.
 625:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LCTL) | MOD_BIT(KC_RCTL))) {
 626:quantum/quantum.c ****         shifted = 0;
 627:quantum/quantum.c ****       }
 628:quantum/quantum.c **** #endif
 629:quantum/quantum.c **** 
 630:quantum/quantum.c **** #ifdef GRAVE_ESC_GUI_OVERRIDE
 631:quantum/quantum.c ****       // if GUI is pressed, ESC is always sent
 632:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LGUI) | MOD_BIT(KC_RGUI))) {
 633:quantum/quantum.c ****         shifted = 0;
 634:quantum/quantum.c ****       }
 635:quantum/quantum.c **** #endif
 636:quantum/quantum.c **** 
 637:quantum/quantum.c **** #ifdef GRAVE_ESC_SHIFT_OVERRIDE
 638:quantum/quantum.c ****       // if SHIFT is pressed, ESC is always sent
 639:quantum/quantum.c ****       if (get_mods() & (MOD_BIT(KC_LSHIFT) | MOD_BIT(KC_RSHIFT))) {
 640:quantum/quantum.c ****         shifted = 0;
 641:quantum/quantum.c ****       }
 642:quantum/quantum.c **** #endif
 643:quantum/quantum.c **** 
 644:quantum/quantum.c ****       if (record->event.pressed) {
 707               		.loc 1 644 0
 708 005c F801      		movw r30,r16
 709 005e 8281      		ldd r24,Z+2
 710 0060 4091 0000 		lds r20,keyboard_report
 711 0064 5091 0000 		lds r21,keyboard_report+1
 712 0068 8823      		tst r24
 713 006a 01F0      		breq .L96
 611:quantum/quantum.c ****                                       |MOD_BIT(KC_LGUI)|MOD_BIT(KC_RGUI)));
 714               		.loc 1 611 0
 715 006c 2A7A      		andi r18,lo8(-86)
 716               	.LVL57:
 645:quantum/quantum.c ****         grave_esc_was_shifted = shifted;
 717               		.loc 1 645 0
 718 006e 91E0      		ldi r25,lo8(1)
 719 0070 01F4      		brne .L97
 720 0072 90E0      		ldi r25,0
 721               	.L97:
 722 0074 9093 0000 		sts grave_esc_was_shifted,r25
 646:quantum/quantum.c ****         add_key(shifted ? KC_GRAVE : KC_ESCAPE);
 723               		.loc 1 646 0
 724 0078 9111      		cpse r25,__zero_reg__
 725 007a 00C0      		rjmp .L104
 726 007c 69E2      		ldi r22,lo8(41)
 727 007e 00C0      		rjmp .L98
 728               	.L104:
 729 0080 65E3      		ldi r22,lo8(53)
 730               	.L98:
 731               	.LVL58:
 732               	.LBB31:
 733               	.LBB32:
 734               		.file 4 "./tmk_core/common/action_util.h"
   1:./tmk_core/common/action_util.h **** /*
   2:./tmk_core/common/action_util.h **** Copyright 2013 Jun Wako <wakojun@gmail.com>
   3:./tmk_core/common/action_util.h **** 
   4:./tmk_core/common/action_util.h **** This program is free software: you can redistribute it and/or modify
   5:./tmk_core/common/action_util.h **** it under the terms of the GNU General Public License as published by
   6:./tmk_core/common/action_util.h **** the Free Software Foundation, either version 2 of the License, or
   7:./tmk_core/common/action_util.h **** (at your option) any later version.
   8:./tmk_core/common/action_util.h **** 
   9:./tmk_core/common/action_util.h **** This program is distributed in the hope that it will be useful,
  10:./tmk_core/common/action_util.h **** but WITHOUT ANY WARRANTY; without even the implied warranty of
  11:./tmk_core/common/action_util.h **** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  12:./tmk_core/common/action_util.h **** GNU General Public License for more details.
  13:./tmk_core/common/action_util.h **** 
  14:./tmk_core/common/action_util.h **** You should have received a copy of the GNU General Public License
  15:./tmk_core/common/action_util.h **** along with this program.  If not, see <http://www.gnu.org/licenses/>.
  16:./tmk_core/common/action_util.h **** */
  17:./tmk_core/common/action_util.h **** #ifndef ACTION_UTIL_H
  18:./tmk_core/common/action_util.h **** #define ACTION_UTIL_H
  19:./tmk_core/common/action_util.h **** 
  20:./tmk_core/common/action_util.h **** #include <stdint.h>
  21:./tmk_core/common/action_util.h **** #include "report.h"
  22:./tmk_core/common/action_util.h **** 
  23:./tmk_core/common/action_util.h **** #ifdef __cplusplus
  24:./tmk_core/common/action_util.h **** extern "C" {
  25:./tmk_core/common/action_util.h **** #endif
  26:./tmk_core/common/action_util.h **** 
  27:./tmk_core/common/action_util.h **** extern report_keyboard_t *keyboard_report;
  28:./tmk_core/common/action_util.h **** 
  29:./tmk_core/common/action_util.h **** void send_keyboard_report(void);
  30:./tmk_core/common/action_util.h **** 
  31:./tmk_core/common/action_util.h **** /* key */
  32:./tmk_core/common/action_util.h **** inline void add_key(uint8_t key) {
  33:./tmk_core/common/action_util.h ****   add_key_to_report(keyboard_report, key);
 735               		.loc 4 33 0 discriminator 4
 736 0082 CA01      		movw r24,r20
 737 0084 0E94 0000 		call add_key_to_report
 738               	.LVL59:
 739 0088 00C0      		rjmp .L99
 740               	.LVL60:
 741               	.L96:
 742               	.LBE32:
 743               	.LBE31:
 647:quantum/quantum.c ****       }
 648:quantum/quantum.c ****       else {
 649:quantum/quantum.c ****         del_key(grave_esc_was_shifted ? KC_GRAVE : KC_ESCAPE);
 744               		.loc 1 649 0
 745 008a 8091 0000 		lds r24,grave_esc_was_shifted
 746 008e 8111      		cpse r24,__zero_reg__
 747 0090 00C0      		rjmp .L105
 748 0092 69E2      		ldi r22,lo8(41)
 749 0094 00C0      		rjmp .L100
 750               	.L105:
 751 0096 65E3      		ldi r22,lo8(53)
 752               	.L100:
 753               	.LVL61:
 754               	.LBB33:
 755               	.LBB34:
  34:./tmk_core/common/action_util.h **** }
  35:./tmk_core/common/action_util.h **** 
  36:./tmk_core/common/action_util.h **** inline void del_key(uint8_t key) {
  37:./tmk_core/common/action_util.h ****   del_key_from_report(keyboard_report, key);
 756               		.loc 4 37 0 discriminator 4
 757 0098 CA01      		movw r24,r20
 758 009a 0E94 0000 		call del_key_from_report
 759               	.LVL62:
 760               	.L99:
 761               	.LBE34:
 762               	.LBE33:
 650:quantum/quantum.c ****       }
 651:quantum/quantum.c **** 
 652:quantum/quantum.c ****       send_keyboard_report();
 763               		.loc 1 652 0
 764 009e 0E94 0000 		call send_keyboard_report
 765               	.LVL63:
 653:quantum/quantum.c ****       return false;
 766               		.loc 1 653 0
 767 00a2 00C0      		rjmp .L113
 768               	.L134:
 769               	.LBE30:
 284:quantum/quantum.c ****     case RESET:
 770               		.loc 1 284 0
 771 00a4 C631      		cpi r28,22
 772 00a6 8CE5      		ldi r24,92
 773 00a8 D807      		cpc r29,r24
 774 00aa 00F0      		brlo .+2
 775 00ac 00C0      		rjmp .L102
 776 00ae C130      		cpi r28,1
 777 00b0 ECE5      		ldi r30,92
 778 00b2 DE07      		cpc r29,r30
 779 00b4 01F4      		brne .L135
 291:quantum/quantum.c ****           debug_enable = true;
 780               		.loc 1 291 0
 781 00b6 F801      		movw r30,r16
 782 00b8 8281      		ldd r24,Z+2
 783 00ba 8823      		tst r24
 784 00bc 01F4      		brne .+2
 785 00be 00C0      		rjmp .L113
 292:quantum/quantum.c ****           print("DEBUG: enabled.\n");
 786               		.loc 1 292 0
 787 00c0 8091 0000 		lds r24,debug_config
 788 00c4 8160      		ori r24,lo8(1<<0)
 789 00c6 8093 0000 		sts debug_config,r24
 293:quantum/quantum.c ****       }
 790               		.loc 1 293 0
 791 00ca 80E0      		ldi r24,lo8(__c.3295)
 792 00cc 90E0      		ldi r25,hi8(__c.3295)
 793 00ce 0E94 0000 		call xputs
 794               	.LVL64:
 795 00d2 00C0      		rjmp .L113
 796               	.L135:
 284:quantum/quantum.c ****     case RESET:
 797               		.loc 1 284 0
 798 00d4 C230      		cpi r28,2
 799 00d6 FCE5      		ldi r31,92
 800 00d8 DF07      		cpc r29,r31
 801 00da 00F4      		brsh .+2
 802 00dc 00C0      		rjmp .L136
 466:quantum/quantum.c ****         // MAGIC actions (BOOTMAGIC without the boot)
 803               		.loc 1 466 0
 804 00de F801      		movw r30,r16
 805 00e0 8281      		ldd r24,Z+2
 806 00e2 8823      		tst r24
 807 00e4 01F4      		brne .+2
 808 00e6 00C0      		rjmp .L60
 468:quantum/quantum.c ****             eeconfig_init();
 809               		.loc 1 468 0
 810 00e8 0E94 0000 		call eeconfig_is_enabled
 811               	.LVL65:
 812 00ec 8111      		cpse r24,__zero_reg__
 813 00ee 00C0      		rjmp .L61
 469:quantum/quantum.c ****         }
 814               		.loc 1 469 0
 815 00f0 0E94 0000 		call eeconfig_init
 816               	.LVL66:
 817               	.L61:
 472:quantum/quantum.c ****         switch (keycode)
 818               		.loc 1 472 0
 819 00f4 0E94 0000 		call eeconfig_read_keymap
 820               	.LVL67:
 821 00f8 90E0      		ldi r25,0
 822 00fa 9093 0000 		sts keymap_config+1,r25
 823 00fe 8093 0000 		sts keymap_config,r24
 473:quantum/quantum.c ****         {
 824               		.loc 1 473 0
 825 0102 FE01      		movw r30,r28
 826 0104 E350      		subi r30,3
 827 0106 FC45      		sbci r31,92
 828 0108 E231      		cpi r30,18
 829 010a F105      		cpc r31,__zero_reg__
 830 010c 00F4      		brsh .L62
 831 010e E050      		subi r30,lo8(-(gs(.L64)))
 832 0110 F040      		sbci r31,hi8(-(gs(.L64)))
 538:quantum/quantum.c ****             break;
 833               		.loc 1 538 0
 834 0112 8091 0000 		lds r24,keymap_config
 473:quantum/quantum.c ****         {
 835               		.loc 1 473 0
 836 0116 0C94 0000 		jmp __tablejump2__
 837               		.section	.progmem.gcc_sw_table.process_record_quantum,"a",@progbits
 838               		.p2align	1
 839               	.L64:
 840 0000 0000      		.word gs(.L63)
 841 0002 0000      		.word gs(.L65)
 842 0004 0000      		.word gs(.L133)
 843 0006 0000      		.word gs(.L67)
 844 0008 0000      		.word gs(.L68)
 845 000a 0000      		.word gs(.L69)
 846 000c 0000      		.word gs(.L70)
 847 000e 0000      		.word gs(.L71)
 848 0010 0000      		.word gs(.L72)
 849 0012 0000      		.word gs(.L73)
 850 0014 0000      		.word gs(.L74)
 851 0016 0000      		.word gs(.L132)
 852 0018 0000      		.word gs(.L76)
 853 001a 0000      		.word gs(.L77)
 854 001c 0000      		.word gs(.L78)
 855 001e 0000      		.word gs(.L79)
 856 0020 0000      		.word gs(.L80)
 857 0022 0000      		.word gs(.L81)
 858               		.section	.text.process_record_quantum
 859               	.L62:
 476:quantum/quantum.c ****             break;
 860               		.loc 1 476 0
 861 011a 8091 0000 		lds r24,keymap_config
 862 011e 8160      		ori r24,lo8(1<<0)
 863 0120 00C0      		rjmp .L128
 864               	.L63:
 479:quantum/quantum.c ****             break;
 865               		.loc 1 479 0
 866 0122 8260      		ori r24,lo8(1<<1)
 867 0124 00C0      		rjmp .L128
 868               	.L65:
 482:quantum/quantum.c ****             break;
 869               		.loc 1 482 0
 870 0126 8460      		ori r24,lo8(1<<2)
 871 0128 00C0      		rjmp .L128
 872               	.L67:
 488:quantum/quantum.c ****             break;
 873               		.loc 1 488 0
 874 012a 8061      		ori r24,lo8(1<<4)
 875 012c 00C0      		rjmp .L128
 876               	.L68:
 491:quantum/quantum.c ****             break;
 877               		.loc 1 491 0
 878 012e 8062      		ori r24,lo8(1<<5)
 879 0130 00C0      		rjmp .L128
 880               	.L69:
 494:quantum/quantum.c ****             break;
 881               		.loc 1 494 0
 882 0132 8064      		ori r24,lo8(1<<6)
 883 0134 00C0      		rjmp .L128
 884               	.L70:
 497:quantum/quantum.c ****             break;
 885               		.loc 1 497 0
 886 0136 8068      		ori r24,lo8(1<<7)
 887 0138 00C0      		rjmp .L128
 888               	.L71:
 501:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 889               		.loc 1 501 0
 890 013a 8460      		ori r24,lo8(4)
 891               	.L133:
 892 013c 8860      		ori r24,lo8(1<<3)
 893 013e 00C0      		rjmp .L128
 894               	.L72:
 507:quantum/quantum.c ****             break;
 895               		.loc 1 507 0
 896 0140 8E7F      		andi r24,lo8(~(1<<0))
 897 0142 00C0      		rjmp .L128
 898               	.L73:
 510:quantum/quantum.c ****             break;
 899               		.loc 1 510 0
 900 0144 8D7F      		andi r24,lo8(~(1<<1))
 901 0146 00C0      		rjmp .L128
 902               	.L74:
 513:quantum/quantum.c ****             break;
 903               		.loc 1 513 0
 904 0148 8B7F      		andi r24,lo8(~(1<<2))
 905 014a 00C0      		rjmp .L128
 906               	.L76:
 519:quantum/quantum.c ****             break;
 907               		.loc 1 519 0
 908 014c 8F7E      		andi r24,lo8(~(1<<4))
 909 014e 00C0      		rjmp .L128
 910               	.L77:
 522:quantum/quantum.c ****             break;
 911               		.loc 1 522 0
 912 0150 8F7D      		andi r24,lo8(~(1<<5))
 913 0152 00C0      		rjmp .L128
 914               	.L78:
 525:quantum/quantum.c ****             break;
 915               		.loc 1 525 0
 916 0154 8F7B      		andi r24,lo8(~(1<<6))
 917 0156 00C0      		rjmp .L128
 918               	.L79:
 528:quantum/quantum.c ****             break;
 919               		.loc 1 528 0
 920 0158 8F77      		andi r24,lo8(~(1<<7))
 921 015a 00C0      		rjmp .L128
 922               	.L80:
 532:quantum/quantum.c ****             #ifdef AUDIO_ENABLE
 923               		.loc 1 532 0
 924 015c 8B7F      		andi r24,lo8(-5)
 925               	.L132:
 926 015e 877F      		andi r24,lo8(~(1<<3))
 927 0160 00C0      		rjmp .L128
 928               	.L81:
 538:quantum/quantum.c ****             break;
 929               		.loc 1 538 0
 930 0162 87FB      		bst r24,7
 931 0164 2227      		clr r18
 932 0166 20F9      		bld r18,0
 933 0168 91E0      		ldi r25,lo8(1)
 934 016a 9227      		eor r25,r18
 935 016c 90FB      		bst r25,0
 936 016e 87F9      		bld r24,7
 937               	.L128:
 938 0170 8093 0000 		sts keymap_config,r24
 543:quantum/quantum.c ****         clear_keyboard(); // clear to prevent stuck keys
 939               		.loc 1 543 0
 940 0174 8091 0000 		lds r24,keymap_config
 941 0178 0E94 0000 		call eeconfig_update_keymap
 942               	.LVL68:
 544:quantum/quantum.c **** 
 943               		.loc 1 544 0
 944 017c 0E94 0000 		call clear_keyboard
 945               	.LVL69:
 546:quantum/quantum.c ****       }
 946               		.loc 1 546 0
 947 0180 00C0      		rjmp .L113
 948               	.L136:
 284:quantum/quantum.c ****     case RESET:
 949               		.loc 1 284 0
 950 0182 C115      		cp r28,__zero_reg__
 951 0184 DC45      		sbci r29,92
 952 0186 01F0      		breq .L54
 953               	.L101:
 654:quantum/quantum.c ****     }
 655:quantum/quantum.c **** 
 656:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_BREATHING)
 657:quantum/quantum.c ****     case BL_BRTG: {
 658:quantum/quantum.c ****       if (record->event.pressed)
 659:quantum/quantum.c ****         breathing_toggle();
 660:quantum/quantum.c ****       return false;
 661:quantum/quantum.c ****     }
 662:quantum/quantum.c **** #endif
 663:quantum/quantum.c **** 
 664:quantum/quantum.c ****     default: {
 665:quantum/quantum.c ****       shift_interrupted[0] = true;
 954               		.loc 1 665 0
 955 0188 81E0      		ldi r24,lo8(1)
 956 018a 8093 0000 		sts shift_interrupted,r24
 666:quantum/quantum.c ****       shift_interrupted[1] = true;
 957               		.loc 1 666 0
 958 018e 8093 0000 		sts shift_interrupted+1,r24
 959               	.L60:
 667:quantum/quantum.c ****       break;
 668:quantum/quantum.c ****     }
 669:quantum/quantum.c ****   }
 670:quantum/quantum.c **** 
 671:quantum/quantum.c ****   return process_action_kb(record);
 960               		.loc 1 671 0
 961 0192 C801      		movw r24,r16
 962               	/* epilogue start */
 672:quantum/quantum.c **** }
 963               		.loc 1 672 0
 964 0194 DF91      		pop r29
 965 0196 CF91      		pop r28
 966               	.LVL70:
 967 0198 1F91      		pop r17
 968 019a 0F91      		pop r16
 969               	.LVL71:
 671:quantum/quantum.c **** }
 970               		.loc 1 671 0
 971 019c 0C94 0000 		jmp process_action_kb
 972               	.LVL72:
 973               	.L54:
 286:quantum/quantum.c ****         reset_keyboard();
 974               		.loc 1 286 0
 975 01a0 F801      		movw r30,r16
 976 01a2 8281      		ldd r24,Z+2
 977 01a4 8823      		tst r24
 978 01a6 01F4      		brne .+2
 979 01a8 00C0      		rjmp .L113
 287:quantum/quantum.c ****       }
 980               		.loc 1 287 0
 981 01aa 0E94 0000 		call reset_keyboard
 982               	.LVL73:
 983 01ae 00C0      		rjmp .L113
 984               	.L102:
 284:quantum/quantum.c ****     case RESET:
 985               		.loc 1 284 0
 986 01b0 C53D      		cpi r28,-43
 987 01b2 ECE5      		ldi r30,92
 988 01b4 DE07      		cpc r29,r30
 989 01b6 01F4      		brne .L137
 594:quantum/quantum.c ****         shift_interrupted[1] = false;
 990               		.loc 1 594 0
 991 01b8 F801      		movw r30,r16
 992 01ba 8281      		ldd r24,Z+2
 993 01bc 8823      		tst r24
 994 01be 01F0      		breq .L138
 995               	.L94:
 573:quantum/quantum.c ****         scs_timer[1] = timer_read ();
 996               		.loc 1 573 0
 997 01c0 1092 0000 		sts shift_interrupted+1,__zero_reg__
 574:quantum/quantum.c ****         register_mods(MOD_BIT(KC_RSFT));
 998               		.loc 1 574 0
 999 01c4 0E94 0000 		call timer_read
 1000               	.LVL74:
 1001 01c8 9093 0000 		sts scs_timer+2+1,r25
 1002 01cc 8093 0000 		sts scs_timer+2,r24
 575:quantum/quantum.c ****       }
 1003               		.loc 1 575 0
 1004 01d0 80E2      		ldi r24,lo8(32)
 1005               	.L130:
 1006 01d2 0E94 0000 		call register_mods
 1007               	.LVL75:
 1008 01d6 00C0      		rjmp .L113
 1009               	.L138:
 599:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1010               		.loc 1 599 0
 1011 01d8 8091 0000 		lds r24,shift_interrupted+1
 1012 01dc 8823      		tst r24
 1013 01de 01F0      		breq .L139
 1014               	.L91:
 588:quantum/quantum.c ****       }
 1015               		.loc 1 588 0
 1016 01e0 80E2      		ldi r24,lo8(32)
 1017               	.L131:
 1018 01e2 0E94 0000 		call unregister_mods
 1019               	.LVL76:
 1020 01e6 00C0      		rjmp .L113
 1021               	.L139:
 599:quantum/quantum.c ****         unregister_mods(MOD_BIT(KC_RSFT));
 1022               		.loc 1 599 0 discriminator 1
 1023 01e8 8091 0000 		lds r24,scs_timer+2
 1024 01ec 9091 0000 		lds r25,scs_timer+2+1
 1025 01f0 0E94 0000 		call timer_elapsed
 1026               	.LVL77:
 1027 01f4 8639      		cpi r24,-106
 1028 01f6 9105      		cpc r25,__zero_reg__
 1029 01f8 00F4      		brsh .L91
 600:quantum/quantum.c ****         register_code(SFTENT_KEY);
 1030               		.loc 1 600 0
 1031 01fa 80E2      		ldi r24,lo8(32)
 1032 01fc 0E94 0000 		call unregister_mods
 1033               	.LVL78:
 601:quantum/quantum.c ****         unregister_code(SFTENT_KEY);
 1034               		.loc 1 601 0
 1035 0200 88E2      		ldi r24,lo8(40)
 1036 0202 0E94 0000 		call register_code
 1037               	.LVL79:
 602:quantum/quantum.c ****       }
 1038               		.loc 1 602 0
 1039 0206 88E2      		ldi r24,lo8(40)
 1040 0208 0E94 0000 		call unregister_code
 1041               	.LVL80:
 1042 020c 00C0      		rjmp .L113
 1043               	.L137:
 284:quantum/quantum.c ****     case RESET:
 1044               		.loc 1 284 0
 1045 020e C63D      		cpi r28,-42
 1046 0210 FCE5      		ldi r31,92
 1047 0212 DF07      		cpc r29,r31
 1048 0214 00F0      		brlo .+2
 1049 0216 00C0      		rjmp .L103
 1050 0218 C33D      		cpi r28,-45
 1051 021a 8CE5      		ldi r24,92
 1052 021c D807      		cpc r29,r24
 1053 021e 01F4      		brne .L140
 550:quantum/quantum.c ****         shift_interrupted[0] = false;
 1054               		.loc 1 550 0
 1055 0220 F801      		movw r30,r16
 1056 0222 8281      		ldd r24,Z+2
 1057 0224 8823      		tst r24
 1058 0226 01F0      		breq .L84
 551:quantum/quantum.c ****         scs_timer[0] = timer_read ();
 1059               		.loc 1 551 0
 1060 0228 1092 0000 		sts shift_interrupted,__zero_reg__
 552:quantum/quantum.c ****         register_mods(MOD_BIT(KC_LSFT));
 1061               		.loc 1 552 0
 1062 022c 0E94 0000 		call timer_read
 1063               	.LVL81:
 1064 0230 9093 0000 		sts scs_timer+1,r25
 1065 0234 8093 0000 		sts scs_timer,r24
 553:quantum/quantum.c ****       }
 1066               		.loc 1 553 0
 1067 0238 82E0      		ldi r24,lo8(2)
 1068 023a 00C0      		rjmp .L130
 1069               	.L84:
 562:quantum/quantum.c ****           register_code(LSPO_KEY);
 1070               		.loc 1 562 0
 1071 023c 8091 0000 		lds r24,shift_interrupted
 1072 0240 8111      		cpse r24,__zero_reg__
 1073 0242 00C0      		rjmp .L86
 562:quantum/quantum.c ****           register_code(LSPO_KEY);
 1074               		.loc 1 562 0 is_stmt 0 discriminator 1
 1075 0244 8091 0000 		lds r24,scs_timer
 1076 0248 9091 0000 		lds r25,scs_timer+1
 1077 024c 0E94 0000 		call timer_elapsed
 1078               	.LVL82:
 1079 0250 8639      		cpi r24,-106
 1080 0252 9105      		cpc r25,__zero_reg__
 1081 0254 00F4      		brsh .L86
 563:quantum/quantum.c ****           unregister_code(LSPO_KEY);
 1082               		.loc 1 563 0 is_stmt 1
 1083 0256 86E2      		ldi r24,lo8(38)
 1084 0258 0E94 0000 		call register_code
 1085               	.LVL83:
 564:quantum/quantum.c ****         }
 1086               		.loc 1 564 0
 1087 025c 86E2      		ldi r24,lo8(38)
 1088 025e 0E94 0000 		call unregister_code
 1089               	.LVL84:
 1090               	.L86:
 566:quantum/quantum.c ****       }
 1091               		.loc 1 566 0
 1092 0262 82E0      		ldi r24,lo8(2)
 1093 0264 00C0      		rjmp .L131
 1094               	.L140:
 284:quantum/quantum.c ****     case RESET:
 1095               		.loc 1 284 0
 1096 0266 C43D      		cpi r28,-44
 1097 0268 DC45      		sbci r29,92
 1098 026a 01F0      		breq .+2
 1099 026c 00C0      		rjmp .L101
 572:quantum/quantum.c ****         shift_interrupted[1] = false;
 1100               		.loc 1 572 0
 1101 026e F801      		movw r30,r16
 1102 0270 8281      		ldd r24,Z+2
 1103 0272 8111      		cpse r24,__zero_reg__
 1104 0274 00C0      		rjmp .L94
 584:quantum/quantum.c ****           register_code(RSPC_KEY);
 1105               		.loc 1 584 0
 1106 0276 8091 0000 		lds r24,shift_interrupted+1
 1107 027a 8111      		cpse r24,__zero_reg__
 1108 027c 00C0      		rjmp .L91
 584:quantum/quantum.c ****           register_code(RSPC_KEY);
 1109               		.loc 1 584 0 is_stmt 0 discriminator 1
 1110 027e 8091 0000 		lds r24,scs_timer+2
 1111 0282 9091 0000 		lds r25,scs_timer+2+1
 1112 0286 0E94 0000 		call timer_elapsed
 1113               	.LVL85:
 1114 028a 8639      		cpi r24,-106
 1115 028c 9105      		cpc r25,__zero_reg__
 1116 028e 00F0      		brlo .+2
 1117 0290 00C0      		rjmp .L91
 585:quantum/quantum.c ****           unregister_code(RSPC_KEY);
 1118               		.loc 1 585 0 is_stmt 1
 1119 0292 87E2      		ldi r24,lo8(39)
 1120 0294 0E94 0000 		call register_code
 1121               	.LVL86:
 586:quantum/quantum.c ****         }
 1122               		.loc 1 586 0
 1123 0298 87E2      		ldi r24,lo8(39)
 1124 029a 0E94 0000 		call unregister_code
 1125               	.LVL87:
 1126 029e 00C0      		rjmp .L91
 1127               	.L103:
 284:quantum/quantum.c ****     case RESET:
 1128               		.loc 1 284 0
 1129 02a0 C83D      		cpi r28,-40
 1130 02a2 FCE5      		ldi r31,92
 1131 02a4 DF07      		cpc r29,r31
 1132 02a6 01F4      		brne .L141
 448:quantum/quantum.c ****         set_output(OUTPUT_AUTO);
 1133               		.loc 1 448 0
 1134 02a8 F801      		movw r30,r16
 1135 02aa 8281      		ldd r24,Z+2
 1136 02ac 8823      		tst r24
 1137 02ae 01F0      		breq .L113
 449:quantum/quantum.c ****       }
 1138               		.loc 1 449 0
 1139 02b0 80E0      		ldi r24,0
 1140 02b2 00C0      		rjmp .L129
 1141               	.L141:
 284:quantum/quantum.c ****     case RESET:
 1142               		.loc 1 284 0
 1143 02b4 C93D      		cpi r28,-39
 1144 02b6 DC45      		sbci r29,92
 1145 02b8 01F0      		breq .+2
 1146 02ba 00C0      		rjmp .L101
 453:quantum/quantum.c ****         set_output(OUTPUT_USB);
 1147               		.loc 1 453 0
 1148 02bc F801      		movw r30,r16
 1149 02be 8281      		ldd r24,Z+2
 1150 02c0 8823      		tst r24
 1151 02c2 01F0      		breq .L113
 454:quantum/quantum.c ****       }
 1152               		.loc 1 454 0
 1153 02c4 82E0      		ldi r24,lo8(2)
 1154               	.L129:
 1155 02c6 0E94 0000 		call set_output
 1156               	.LVL88:
 1157               	.L113:
 1158               		.loc 1 672 0
 1159 02ca 80E0      		ldi r24,0
 1160               	/* epilogue start */
 1161 02cc DF91      		pop r29
 1162 02ce CF91      		pop r28
 1163               	.LVL89:
 1164 02d0 1F91      		pop r17
 1165 02d2 0F91      		pop r16
 1166               	.LVL90:
 1167 02d4 0895      		ret
 1168               		.cfi_endproc
 1169               	.LFE39:
 1171               		.section	.text.send_char,"ax",@progbits
 1172               	.global	send_char
 1174               	send_char:
 1175               	.LFB44:
 673:quantum/quantum.c **** 
 674:quantum/quantum.c **** __attribute__ ((weak))
 675:quantum/quantum.c **** const bool ascii_to_shift_lut[0x80] PROGMEM = {
 676:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 677:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 678:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 679:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 680:quantum/quantum.c ****     0, 1, 1, 1, 1, 1, 1, 0,
 681:quantum/quantum.c ****     1, 1, 1, 1, 0, 0, 0, 0,
 682:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 683:quantum/quantum.c ****     0, 0, 1, 0, 1, 0, 1, 1,
 684:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 685:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 686:quantum/quantum.c ****     1, 1, 1, 1, 1, 1, 1, 1,
 687:quantum/quantum.c ****     1, 1, 1, 0, 0, 0, 1, 1,
 688:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 689:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 690:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 691:quantum/quantum.c ****     0, 0, 0, 1, 1, 1, 1, 0
 692:quantum/quantum.c **** };
 693:quantum/quantum.c **** 
 694:quantum/quantum.c **** __attribute__ ((weak))
 695:quantum/quantum.c **** const uint8_t ascii_to_keycode_lut[0x80] PROGMEM = {
 696:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 697:quantum/quantum.c ****     KC_BSPC, KC_TAB, KC_ENT, 0, 0, 0, 0, 0,
 698:quantum/quantum.c ****     0, 0, 0, 0, 0, 0, 0, 0,
 699:quantum/quantum.c ****     0, 0, 0, KC_ESC, 0, 0, 0, 0,
 700:quantum/quantum.c ****     KC_SPC, KC_1, KC_QUOT, KC_3, KC_4, KC_5, KC_7, KC_QUOT,
 701:quantum/quantum.c ****     KC_9, KC_0, KC_8, KC_EQL, KC_COMM, KC_MINS, KC_DOT, KC_SLSH,
 702:quantum/quantum.c ****     KC_0, KC_1, KC_2, KC_3, KC_4, KC_5, KC_6, KC_7,
 703:quantum/quantum.c ****     KC_8, KC_9, KC_SCLN, KC_SCLN, KC_COMM, KC_EQL, KC_DOT, KC_SLSH,
 704:quantum/quantum.c ****     KC_2, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 705:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 706:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 707:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_6, KC_MINS,
 708:quantum/quantum.c ****     KC_GRV, KC_A, KC_B, KC_C, KC_D, KC_E, KC_F, KC_G,
 709:quantum/quantum.c ****     KC_H, KC_I, KC_J, KC_K, KC_L, KC_M, KC_N, KC_O,
 710:quantum/quantum.c ****     KC_P, KC_Q, KC_R, KC_S, KC_T, KC_U, KC_V, KC_W,
 711:quantum/quantum.c ****     KC_X, KC_Y, KC_Z, KC_LBRC, KC_BSLS, KC_RBRC, KC_GRV, KC_DEL
 712:quantum/quantum.c **** };
 713:quantum/quantum.c **** 
 714:quantum/quantum.c **** void send_string(const char *str) {
 715:quantum/quantum.c ****   send_string_with_delay(str, 0);
 716:quantum/quantum.c **** }
 717:quantum/quantum.c **** 
 718:quantum/quantum.c **** void send_string_P(const char *str) {
 719:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 720:quantum/quantum.c **** }
 721:quantum/quantum.c **** 
 722:quantum/quantum.c **** void send_string_with_delay(const char *str, uint8_t interval) {
 723:quantum/quantum.c ****     while (1) {
 724:quantum/quantum.c ****         char ascii_code = *str;
 725:quantum/quantum.c ****         if (!ascii_code) break;
 726:quantum/quantum.c ****         if (ascii_code == 1) {
 727:quantum/quantum.c ****           // tap
 728:quantum/quantum.c ****           uint8_t keycode = *(++str);
 729:quantum/quantum.c ****           register_code(keycode);
 730:quantum/quantum.c ****           unregister_code(keycode);
 731:quantum/quantum.c ****         } else if (ascii_code == 2) {
 732:quantum/quantum.c ****           // down
 733:quantum/quantum.c ****           uint8_t keycode = *(++str);
 734:quantum/quantum.c ****           register_code(keycode);
 735:quantum/quantum.c ****         } else if (ascii_code == 3) {
 736:quantum/quantum.c ****           // up
 737:quantum/quantum.c ****           uint8_t keycode = *(++str);
 738:quantum/quantum.c ****           unregister_code(keycode);
 739:quantum/quantum.c ****         } else {
 740:quantum/quantum.c ****           send_char(ascii_code);
 741:quantum/quantum.c ****         }
 742:quantum/quantum.c ****         ++str;
 743:quantum/quantum.c ****         // interval
 744:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 745:quantum/quantum.c ****     }
 746:quantum/quantum.c **** }
 747:quantum/quantum.c **** 
 748:quantum/quantum.c **** void send_string_with_delay_P(const char *str, uint8_t interval) {
 749:quantum/quantum.c ****     while (1) {
 750:quantum/quantum.c ****         char ascii_code = pgm_read_byte(str);
 751:quantum/quantum.c ****         if (!ascii_code) break;
 752:quantum/quantum.c ****         if (ascii_code == 1) {
 753:quantum/quantum.c ****           // tap
 754:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 755:quantum/quantum.c ****           register_code(keycode);
 756:quantum/quantum.c ****           unregister_code(keycode);
 757:quantum/quantum.c ****         } else if (ascii_code == 2) {
 758:quantum/quantum.c ****           // down
 759:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 760:quantum/quantum.c ****           register_code(keycode);
 761:quantum/quantum.c ****         } else if (ascii_code == 3) {
 762:quantum/quantum.c ****           // up
 763:quantum/quantum.c ****           uint8_t keycode = pgm_read_byte(++str);
 764:quantum/quantum.c ****           unregister_code(keycode);
 765:quantum/quantum.c ****         } else {
 766:quantum/quantum.c ****           send_char(ascii_code);
 767:quantum/quantum.c ****         }
 768:quantum/quantum.c ****         ++str;
 769:quantum/quantum.c ****         // interval
 770:quantum/quantum.c ****         { uint8_t ms = interval; while (ms--) wait_ms(1); }
 771:quantum/quantum.c ****     }
 772:quantum/quantum.c **** }
 773:quantum/quantum.c **** 
 774:quantum/quantum.c **** void send_char(char ascii_code) {
 1176               		.loc 1 774 0
 1177               		.cfi_startproc
 1178               	.LVL91:
 1179 0000 CF93      		push r28
 1180               	.LCFI12:
 1181               		.cfi_def_cfa_offset 3
 1182               		.cfi_offset 28, -2
 1183               	/* prologue: function */
 1184               	/* frame size = 0 */
 1185               	/* stack size = 1 */
 1186               	.L__stack_usage = 1
 1187               	.LBB35:
 775:quantum/quantum.c ****   uint8_t keycode;
 776:quantum/quantum.c ****   keycode = pgm_read_byte(&ascii_to_keycode_lut[(uint8_t)ascii_code]);
 1188               		.loc 1 776 0
 1189 0002 282F      		mov r18,r24
 1190 0004 30E0      		ldi r19,0
 1191               	.LVL92:
 1192 0006 F901      		movw r30,r18
 1193 0008 E050      		subi r30,lo8(-(ascii_to_keycode_lut))
 1194 000a F040      		sbci r31,hi8(-(ascii_to_keycode_lut))
 1195               	.LVL93:
 1196               	/* #APP */
 1197               	 ;  776 "quantum/quantum.c" 1
 1198 000c C491      		lpm r28, Z
 1199               		
 1200               	 ;  0 "" 2
 1201               	.LVL94:
 1202               	/* #NOAPP */
 1203               	.LBE35:
 1204               	.LBB36:
 777:quantum/quantum.c ****   if (pgm_read_byte(&ascii_to_shift_lut[(uint8_t)ascii_code])) {
 1205               		.loc 1 777 0
 1206 000e F901      		movw r30,r18
 1207               	.LVL95:
 1208 0010 E050      		subi r30,lo8(-(ascii_to_shift_lut))
 1209 0012 F040      		sbci r31,hi8(-(ascii_to_shift_lut))
 1210               	.LVL96:
 1211               	/* #APP */
 1212               	 ;  777 "quantum/quantum.c" 1
 1213 0014 2491      		lpm r18, Z
 1214               		
 1215               	 ;  0 "" 2
 1216               	.LVL97:
 1217               	/* #NOAPP */
 1218               	.LBE36:
 1219 0016 2223      		tst r18
 1220 0018 01F0      		breq .L143
 778:quantum/quantum.c ****       register_code(KC_LSFT);
 1221               		.loc 1 778 0
 1222 001a 81EE      		ldi r24,lo8(-31)
 1223               	.LVL98:
 1224 001c 0E94 0000 		call register_code
 1225               	.LVL99:
 779:quantum/quantum.c ****       register_code(keycode);
 1226               		.loc 1 779 0
 1227 0020 8C2F      		mov r24,r28
 1228 0022 0E94 0000 		call register_code
 1229               	.LVL100:
 780:quantum/quantum.c ****       unregister_code(keycode);
 1230               		.loc 1 780 0
 1231 0026 8C2F      		mov r24,r28
 1232 0028 0E94 0000 		call unregister_code
 1233               	.LVL101:
 781:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1234               		.loc 1 781 0
 1235 002c 81EE      		ldi r24,lo8(-31)
 1236 002e 00C0      		rjmp .L144
 1237               	.LVL102:
 1238               	.L143:
 782:quantum/quantum.c ****   } else {
 783:quantum/quantum.c ****       register_code(keycode);
 1239               		.loc 1 783 0
 1240 0030 8C2F      		mov r24,r28
 1241               	.LVL103:
 1242 0032 0E94 0000 		call register_code
 1243               	.LVL104:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1244               		.loc 1 784 0
 1245 0036 8C2F      		mov r24,r28
 1246               	.L144:
 1247               	/* epilogue start */
 785:quantum/quantum.c ****   }
 786:quantum/quantum.c **** }
 1248               		.loc 1 786 0
 1249 0038 CF91      		pop r28
 1250               	.LVL105:
 784:quantum/quantum.c ****       unregister_code(keycode);
 1251               		.loc 1 784 0
 1252 003a 0C94 0000 		jmp unregister_code
 1253               	.LVL106:
 1254               		.cfi_endproc
 1255               	.LFE44:
 1257               		.section	.text.send_string_with_delay,"ax",@progbits
 1258               	.global	send_string_with_delay
 1260               	send_string_with_delay:
 1261               	.LFB42:
 722:quantum/quantum.c ****     while (1) {
 1262               		.loc 1 722 0
 1263               		.cfi_startproc
 1264               	.LVL107:
 1265 0000 FF92      		push r15
 1266               	.LCFI13:
 1267               		.cfi_def_cfa_offset 3
 1268               		.cfi_offset 15, -2
 1269 0002 0F93      		push r16
 1270               	.LCFI14:
 1271               		.cfi_def_cfa_offset 4
 1272               		.cfi_offset 16, -3
 1273 0004 1F93      		push r17
 1274               	.LCFI15:
 1275               		.cfi_def_cfa_offset 5
 1276               		.cfi_offset 17, -4
 1277 0006 CF93      		push r28
 1278               	.LCFI16:
 1279               		.cfi_def_cfa_offset 6
 1280               		.cfi_offset 28, -5
 1281 0008 DF93      		push r29
 1282               	.LCFI17:
 1283               		.cfi_def_cfa_offset 7
 1284               		.cfi_offset 29, -6
 1285               	/* prologue: function */
 1286               	/* frame size = 0 */
 1287               	/* stack size = 5 */
 1288               	.L__stack_usage = 5
 1289 000a EC01      		movw r28,r24
 1290 000c F62E      		mov r15,r22
 1291               	.LVL108:
 1292               	.L153:
 1293               	.LBB37:
 724:quantum/quantum.c ****         if (!ascii_code) break;
 1294               		.loc 1 724 0
 1295 000e 8881      		ld r24,Y
 1296               	.LVL109:
 725:quantum/quantum.c ****         if (ascii_code == 1) {
 1297               		.loc 1 725 0
 1298 0010 8823      		tst r24
 1299 0012 01F0      		breq .L145
 1300 0014 8E01      		movw r16,r28
 1301 0016 0F5F      		subi r16,-1
 1302 0018 1F4F      		sbci r17,-1
 726:quantum/quantum.c ****           // tap
 1303               		.loc 1 726 0
 1304 001a 8130      		cpi r24,lo8(1)
 1305 001c 01F4      		brne .L147
 1306               	.LVL110:
 1307               	.LBB38:
 728:quantum/quantum.c ****           register_code(keycode);
 1308               		.loc 1 728 0
 1309 001e C981      		ldd r28,Y+1
 1310               	.LVL111:
 729:quantum/quantum.c ****           unregister_code(keycode);
 1311               		.loc 1 729 0
 1312 0020 8C2F      		mov r24,r28
 1313               	.LVL112:
 1314 0022 0E94 0000 		call register_code
 1315               	.LVL113:
 730:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1316               		.loc 1 730 0
 1317 0026 8C2F      		mov r24,r28
 1318 0028 00C0      		rjmp .L155
 1319               	.LVL114:
 1320               	.L147:
 1321               	.LBE38:
 731:quantum/quantum.c ****           // down
 1322               		.loc 1 731 0
 1323 002a 8230      		cpi r24,lo8(2)
 1324 002c 01F4      		brne .L149
 1325               	.LVL115:
 1326               	.LBB39:
 734:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1327               		.loc 1 734 0
 1328 002e 8981      		ldd r24,Y+1
 1329               	.LVL116:
 1330 0030 0E94 0000 		call register_code
 1331               	.LVL117:
 1332               	.L154:
 733:quantum/quantum.c ****           register_code(keycode);
 1333               		.loc 1 733 0
 1334 0034 E801      		movw r28,r16
 1335               	.LBE39:
 1336 0036 00C0      		rjmp .L148
 1337               	.LVL118:
 1338               	.L149:
 735:quantum/quantum.c ****           // up
 1339               		.loc 1 735 0
 1340 0038 8330      		cpi r24,lo8(3)
 1341 003a 01F4      		brne .L150
 1342               	.LVL119:
 1343               	.LBB40:
 738:quantum/quantum.c ****         } else {
 1344               		.loc 1 738 0
 1345 003c 8981      		ldd r24,Y+1
 1346               	.LVL120:
 1347               	.L155:
 1348 003e 0E94 0000 		call unregister_code
 1349               	.LVL121:
 1350 0042 00C0      		rjmp .L154
 1351               	.LVL122:
 1352               	.L150:
 1353               	.LBE40:
 740:quantum/quantum.c ****         }
 1354               		.loc 1 740 0
 1355 0044 0E94 0000 		call send_char
 1356               	.LVL123:
 1357               	.L148:
 742:quantum/quantum.c ****         // interval
 1358               		.loc 1 742 0
 1359 0048 2196      		adiw r28,1
 1360               	.LVL124:
 1361               	.LBB41:
 744:quantum/quantum.c ****     }
 1362               		.loc 1 744 0
 1363 004a 8F2D      		mov r24,r15
 1364               	.LVL125:
 1365               	.L151:
 744:quantum/quantum.c ****     }
 1366               		.loc 1 744 0 is_stmt 0 discriminator 1
 1367 004c 8823      		tst r24
 1368 004e 01F0      		breq .L153
 1369               	.LVL126:
 1370               	.LBB42:
 1371               	.LBB43:
 1372               		.loc 3 187 0 is_stmt 1
 1373 0050 EFE9      		ldi r30,lo8(3999)
 1374 0052 FFE0      		ldi r31,hi8(3999)
 1375 0054 3197      	1:	sbiw r30,1
 1376 0056 01F4      		brne 1b
 1377 0058 00C0      		rjmp .
 1378 005a 0000      		nop
 1379 005c 8150      		subi r24,lo8(-(-1))
 1380               	.LVL127:
 1381 005e 00C0      		rjmp .L151
 1382               	.LVL128:
 1383               	.L145:
 1384               	/* epilogue start */
 1385               	.LBE43:
 1386               	.LBE42:
 1387               	.LBE41:
 1388               	.LBE37:
 746:quantum/quantum.c **** 
 1389               		.loc 1 746 0
 1390 0060 DF91      		pop r29
 1391 0062 CF91      		pop r28
 1392               	.LVL129:
 1393 0064 1F91      		pop r17
 1394 0066 0F91      		pop r16
 1395 0068 FF90      		pop r15
 1396               	.LVL130:
 1397 006a 0895      		ret
 1398               		.cfi_endproc
 1399               	.LFE42:
 1401               		.section	.text.send_string,"ax",@progbits
 1402               	.global	send_string
 1404               	send_string:
 1405               	.LFB40:
 714:quantum/quantum.c ****   send_string_with_delay(str, 0);
 1406               		.loc 1 714 0
 1407               		.cfi_startproc
 1408               	.LVL131:
 1409               	/* prologue: function */
 1410               	/* frame size = 0 */
 1411               	/* stack size = 0 */
 1412               	.L__stack_usage = 0
 715:quantum/quantum.c **** }
 1413               		.loc 1 715 0
 1414 0000 60E0      		ldi r22,0
 1415 0002 0C94 0000 		jmp send_string_with_delay
 1416               	.LVL132:
 1417               		.cfi_endproc
 1418               	.LFE40:
 1420               		.section	.text.send_string_with_delay_P,"ax",@progbits
 1421               	.global	send_string_with_delay_P
 1423               	send_string_with_delay_P:
 1424               	.LFB43:
 748:quantum/quantum.c ****     while (1) {
 1425               		.loc 1 748 0
 1426               		.cfi_startproc
 1427               	.LVL133:
 1428 0000 0F93      		push r16
 1429               	.LCFI18:
 1430               		.cfi_def_cfa_offset 3
 1431               		.cfi_offset 16, -2
 1432 0002 1F93      		push r17
 1433               	.LCFI19:
 1434               		.cfi_def_cfa_offset 4
 1435               		.cfi_offset 17, -3
 1436 0004 CF93      		push r28
 1437               	.LCFI20:
 1438               		.cfi_def_cfa_offset 5
 1439               		.cfi_offset 28, -4
 1440 0006 DF93      		push r29
 1441               	.LCFI21:
 1442               		.cfi_def_cfa_offset 6
 1443               		.cfi_offset 29, -5
 1444               	/* prologue: function */
 1445               	/* frame size = 0 */
 1446               	/* stack size = 4 */
 1447               	.L__stack_usage = 4
 1448 0008 EC01      		movw r28,r24
 1449 000a 062F      		mov r16,r22
 1450               	.LVL134:
 1451               	.L165:
 1452               	.LBB44:
 1453               	.LBB45:
 750:quantum/quantum.c ****         if (!ascii_code) break;
 1454               		.loc 1 750 0
 1455 000c FE01      		movw r30,r28
 1456               	/* #APP */
 1457               	 ;  750 "quantum/quantum.c" 1
 1458 000e 8491      		lpm r24, Z
 1459               		
 1460               	 ;  0 "" 2
 1461               	.LVL135:
 1462               	/* #NOAPP */
 1463               	.LBE45:
 751:quantum/quantum.c ****         if (ascii_code == 1) {
 1464               		.loc 1 751 0
 1465 0010 8823      		tst r24
 1466 0012 01F0      		breq .L157
 1467 0014 9E01      		movw r18,r28
 1468 0016 2F5F      		subi r18,-1
 1469 0018 3F4F      		sbci r19,-1
 752:quantum/quantum.c ****           // tap
 1470               		.loc 1 752 0
 1471 001a 8130      		cpi r24,lo8(1)
 1472 001c 01F4      		brne .L159
 1473               	.LBB46:
 1474               	.LBB47:
 754:quantum/quantum.c ****           register_code(keycode);
 1475               		.loc 1 754 0
 1476 001e E901      		movw r28,r18
 1477               	.LVL136:
 1478 0020 F901      		movw r30,r18
 1479               	.LVL137:
 1480               	/* #APP */
 1481               	 ;  754 "quantum/quantum.c" 1
 1482 0022 1491      		lpm r17, Z
 1483               		
 1484               	 ;  0 "" 2
 1485               	.LVL138:
 1486               	/* #NOAPP */
 1487               	.LBE47:
 755:quantum/quantum.c ****           unregister_code(keycode);
 1488               		.loc 1 755 0
 1489 0024 812F      		mov r24,r17
 1490               	.LVL139:
 1491 0026 0E94 0000 		call register_code
 1492               	.LVL140:
 756:quantum/quantum.c ****         } else if (ascii_code == 2) {
 1493               		.loc 1 756 0
 1494 002a 812F      		mov r24,r17
 1495 002c 00C0      		rjmp .L166
 1496               	.LVL141:
 1497               	.L159:
 1498               	.LBE46:
 757:quantum/quantum.c ****           // down
 1499               		.loc 1 757 0
 1500 002e 8230      		cpi r24,lo8(2)
 1501 0030 01F4      		brne .L161
 1502               	.LBB48:
 1503               	.LBB49:
 759:quantum/quantum.c ****           register_code(keycode);
 1504               		.loc 1 759 0
 1505 0032 E901      		movw r28,r18
 1506               	.LVL142:
 1507 0034 F901      		movw r30,r18
 1508               	.LVL143:
 1509               	/* #APP */
 1510               	 ;  759 "quantum/quantum.c" 1
 1511 0036 8491      		lpm r24, Z
 1512               		
 1513               	 ;  0 "" 2
 1514               	.LVL144:
 1515               	/* #NOAPP */
 1516               	.LBE49:
 760:quantum/quantum.c ****         } else if (ascii_code == 3) {
 1517               		.loc 1 760 0
 1518 0038 0E94 0000 		call register_code
 1519               	.LVL145:
 1520               	.LBE48:
 1521 003c 00C0      		rjmp .L160
 1522               	.LVL146:
 1523               	.L161:
 761:quantum/quantum.c ****           // up
 1524               		.loc 1 761 0
 1525 003e 8330      		cpi r24,lo8(3)
 1526 0040 01F4      		brne .L162
 1527               	.LBB50:
 1528               	.LBB51:
 763:quantum/quantum.c ****           unregister_code(keycode);
 1529               		.loc 1 763 0
 1530 0042 E901      		movw r28,r18
 1531               	.LVL147:
 1532 0044 F901      		movw r30,r18
 1533               	.LVL148:
 1534               	/* #APP */
 1535               	 ;  763 "quantum/quantum.c" 1
 1536 0046 8491      		lpm r24, Z
 1537               		
 1538               	 ;  0 "" 2
 1539               	.LVL149:
 1540               	/* #NOAPP */
 1541               	.L166:
 1542               	.LBE51:
 764:quantum/quantum.c ****         } else {
 1543               		.loc 1 764 0
 1544 0048 0E94 0000 		call unregister_code
 1545               	.LVL150:
 1546               	.LBE50:
 1547 004c 00C0      		rjmp .L160
 1548               	.LVL151:
 1549               	.L162:
 766:quantum/quantum.c ****         }
 1550               		.loc 1 766 0
 1551 004e 0E94 0000 		call send_char
 1552               	.LVL152:
 1553               	.L160:
 768:quantum/quantum.c ****         // interval
 1554               		.loc 1 768 0
 1555 0052 2196      		adiw r28,1
 1556               	.LVL153:
 1557               	.LBB52:
 770:quantum/quantum.c ****     }
 1558               		.loc 1 770 0
 1559 0054 802F      		mov r24,r16
 1560               	.LVL154:
 1561               	.L163:
 770:quantum/quantum.c ****     }
 1562               		.loc 1 770 0 is_stmt 0 discriminator 1
 1563 0056 8823      		tst r24
 1564 0058 01F0      		breq .L165
 1565               	.LVL155:
 1566               	.LBB53:
 1567               	.LBB54:
 1568               		.loc 3 187 0 is_stmt 1
 1569 005a EFE9      		ldi r30,lo8(3999)
 1570 005c FFE0      		ldi r31,hi8(3999)
 1571 005e 3197      	1:	sbiw r30,1
 1572 0060 01F4      		brne 1b
 1573 0062 00C0      		rjmp .
 1574 0064 0000      		nop
 1575 0066 8150      		subi r24,lo8(-(-1))
 1576               	.LVL156:
 1577 0068 00C0      		rjmp .L163
 1578               	.LVL157:
 1579               	.L157:
 1580               	/* epilogue start */
 1581               	.LBE54:
 1582               	.LBE53:
 1583               	.LBE52:
 1584               	.LBE44:
 772:quantum/quantum.c **** 
 1585               		.loc 1 772 0
 1586 006a DF91      		pop r29
 1587 006c CF91      		pop r28
 1588               	.LVL158:
 1589 006e 1F91      		pop r17
 1590 0070 0F91      		pop r16
 1591               	.LVL159:
 1592 0072 0895      		ret
 1593               		.cfi_endproc
 1594               	.LFE43:
 1596               		.section	.text.send_string_P,"ax",@progbits
 1597               	.global	send_string_P
 1599               	send_string_P:
 1600               	.LFB41:
 718:quantum/quantum.c ****   send_string_with_delay_P(str, 0);
 1601               		.loc 1 718 0
 1602               		.cfi_startproc
 1603               	.LVL160:
 1604               	/* prologue: function */
 1605               	/* frame size = 0 */
 1606               	/* stack size = 0 */
 1607               	.L__stack_usage = 0
 719:quantum/quantum.c **** }
 1608               		.loc 1 719 0
 1609 0000 60E0      		ldi r22,0
 1610 0002 0C94 0000 		jmp send_string_with_delay_P
 1611               	.LVL161:
 1612               		.cfi_endproc
 1613               	.LFE41:
 1615               		.section	.text.set_single_persistent_default_layer,"ax",@progbits
 1616               	.global	set_single_persistent_default_layer
 1618               	set_single_persistent_default_layer:
 1619               	.LFB45:
 787:quantum/quantum.c **** 
 788:quantum/quantum.c **** void set_single_persistent_default_layer(uint8_t default_layer) {
 1620               		.loc 1 788 0
 1621               		.cfi_startproc
 1622               	.LVL162:
 1623 0000 CF93      		push r28
 1624               	.LCFI22:
 1625               		.cfi_def_cfa_offset 3
 1626               		.cfi_offset 28, -2
 1627 0002 DF93      		push r29
 1628               	.LCFI23:
 1629               		.cfi_def_cfa_offset 4
 1630               		.cfi_offset 29, -3
 1631               	/* prologue: function */
 1632               	/* frame size = 0 */
 1633               	/* stack size = 2 */
 1634               	.L__stack_usage = 2
 789:quantum/quantum.c ****   #if defined(AUDIO_ENABLE) && defined(DEFAULT_LAYER_SONGS)
 790:quantum/quantum.c ****     PLAY_SONG(default_layer_songs[default_layer]);
 791:quantum/quantum.c ****   #endif
 792:quantum/quantum.c ****   eeconfig_update_default_layer(1U<<default_layer);
 1635               		.loc 1 792 0
 1636 0004 61E0      		ldi r22,lo8(1)
 1637 0006 70E0      		ldi r23,0
 1638 0008 EB01      		movw r28,r22
 1639 000a 00C0      		rjmp 2f
 1640               		1:
 1641 000c CC0F      		lsl r28
 1642 000e DD1F      		rol r29
 1643               		2:
 1644 0010 8A95      		dec r24
 1645 0012 02F4      		brpl 1b
 1646 0014 8C2F      		mov r24,r28
 1647               	.LVL163:
 1648 0016 0E94 0000 		call eeconfig_update_default_layer
 1649               	.LVL164:
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1650               		.loc 1 793 0
 1651 001a BE01      		movw r22,r28
 1652 001c 80E0      		ldi r24,0
 1653 001e 90E0      		ldi r25,0
 1654               	/* epilogue start */
 794:quantum/quantum.c **** }
 1655               		.loc 1 794 0
 1656 0020 DF91      		pop r29
 1657 0022 CF91      		pop r28
 793:quantum/quantum.c ****   default_layer_set(1U<<default_layer);
 1658               		.loc 1 793 0
 1659 0024 0C94 0000 		jmp default_layer_set
 1660               	.LVL165:
 1661               		.cfi_endproc
 1662               	.LFE45:
 1664               		.section	.text.update_tri_layer_state,"ax",@progbits
 1665               	.global	update_tri_layer_state
 1667               	update_tri_layer_state:
 1668               	.LFB46:
 795:quantum/quantum.c **** 
 796:quantum/quantum.c **** uint32_t update_tri_layer_state(uint32_t state, uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1669               		.loc 1 796 0
 1670               		.cfi_startproc
 1671               	.LVL166:
 1672 0000 8F92      		push r8
 1673               	.LCFI24:
 1674               		.cfi_def_cfa_offset 3
 1675               		.cfi_offset 8, -2
 1676 0002 9F92      		push r9
 1677               	.LCFI25:
 1678               		.cfi_def_cfa_offset 4
 1679               		.cfi_offset 9, -3
 1680 0004 AF92      		push r10
 1681               	.LCFI26:
 1682               		.cfi_def_cfa_offset 5
 1683               		.cfi_offset 10, -4
 1684 0006 BF92      		push r11
 1685               	.LCFI27:
 1686               		.cfi_def_cfa_offset 6
 1687               		.cfi_offset 11, -5
 1688 0008 CF92      		push r12
 1689               	.LCFI28:
 1690               		.cfi_def_cfa_offset 7
 1691               		.cfi_offset 12, -6
 1692 000a DF92      		push r13
 1693               	.LCFI29:
 1694               		.cfi_def_cfa_offset 8
 1695               		.cfi_offset 13, -7
 1696 000c EF92      		push r14
 1697               	.LCFI30:
 1698               		.cfi_def_cfa_offset 9
 1699               		.cfi_offset 14, -8
 1700 000e FF92      		push r15
 1701               	.LCFI31:
 1702               		.cfi_def_cfa_offset 10
 1703               		.cfi_offset 15, -9
 1704 0010 0F93      		push r16
 1705               	.LCFI32:
 1706               		.cfi_def_cfa_offset 11
 1707               		.cfi_offset 16, -10
 1708 0012 1F93      		push r17
 1709               	.LCFI33:
 1710               		.cfi_def_cfa_offset 12
 1711               		.cfi_offset 17, -11
 1712               	/* prologue: function */
 1713               	/* frame size = 0 */
 1714               	/* stack size = 10 */
 1715               	.L__stack_usage = 10
 1716 0014 6B01      		movw r12,r22
 1717 0016 7C01      		movw r14,r24
 797:quantum/quantum.c ****   uint32_t mask12 = (1UL << layer1) | (1UL << layer2);
 1718               		.loc 1 797 0
 1719 0018 81E0      		ldi r24,lo8(1)
 1720 001a 90E0      		ldi r25,0
 1721 001c A0E0      		ldi r26,0
 1722 001e B0E0      		ldi r27,0
 1723 0020 4C01      		movw r8,r24
 1724 0022 5D01      		movw r10,r26
 1725 0024 00C0      		rjmp 2f
 1726               		1:
 1727 0026 880C      		lsl r8
 1728 0028 991C      		rol r9
 1729 002a AA1C      		rol r10
 1730 002c BB1C      		rol r11
 1731               		2:
 1732 002e 4A95      		dec r20
 1733 0030 02F4      		brpl 1b
 1734 0032 AC01      		movw r20,r24
 1735 0034 BD01      		movw r22,r26
 1736               	.LVL167:
 1737 0036 00C0      		rjmp 2f
 1738               		1:
 1739 0038 440F      		lsl r20
 1740 003a 551F      		rol r21
 1741 003c 661F      		rol r22
 1742 003e 771F      		rol r23
 1743               		2:
 1744 0040 2A95      		dec r18
 1745 0042 02F4      		brpl 1b
 1746 0044 4829      		or r20,r8
 1747 0046 5929      		or r21,r9
 1748 0048 6A29      		or r22,r10
 1749 004a 7B29      		or r23,r11
 1750               	.LVL168:
 798:quantum/quantum.c ****   uint32_t mask3 = 1UL << layer3;
 1751               		.loc 1 798 0
 1752 004c 00C0      		rjmp 2f
 1753               		1:
 1754 004e 880F      		lsl r24
 1755 0050 991F      		rol r25
 1756 0052 AA1F      		rol r26
 1757 0054 BB1F      		rol r27
 1758               		2:
 1759 0056 0A95      		dec r16
 1760 0058 02F4      		brpl 1b
 1761               	.LVL169:
 799:quantum/quantum.c ****   return (state & mask12) == mask12 ? (state | mask3) : (state & ~mask3);
 1762               		.loc 1 799 0
 1763 005a 8A01      		movw r16,r20
 1764 005c 9B01      		movw r18,r22
 1765               	.LVL170:
 1766 005e 0C21      		and r16,r12
 1767 0060 1D21      		and r17,r13
 1768 0062 2E21      		and r18,r14
 1769 0064 3F21      		and r19,r15
 1770 0066 0417      		cp r16,r20
 1771 0068 1507      		cpc r17,r21
 1772 006a 2607      		cpc r18,r22
 1773 006c 3707      		cpc r19,r23
 1774 006e 01F4      		brne .L170
 1775               		.loc 1 799 0 is_stmt 0 discriminator 1
 1776 0070 BC01      		movw r22,r24
 1777 0072 CD01      		movw r24,r26
 1778               	.LVL171:
 1779 0074 6C29      		or r22,r12
 1780 0076 7D29      		or r23,r13
 1781 0078 8E29      		or r24,r14
 1782 007a 9F29      		or r25,r15
 1783 007c 00C0      		rjmp .L171
 1784               	.L170:
 1785               		.loc 1 799 0 discriminator 2
 1786 007e 8095      		com r24
 1787 0080 9095      		com r25
 1788 0082 A095      		com r26
 1789 0084 B095      		com r27
 1790               	.LVL172:
 1791 0086 BC01      		movw r22,r24
 1792 0088 CD01      		movw r24,r26
 1793 008a 6C21      		and r22,r12
 1794 008c 7D21      		and r23,r13
 1795 008e 8E21      		and r24,r14
 1796 0090 9F21      		and r25,r15
 1797               	.LVL173:
 1798               	.L171:
 1799               	/* epilogue start */
 800:quantum/quantum.c **** }
 1800               		.loc 1 800 0 is_stmt 1 discriminator 4
 1801 0092 1F91      		pop r17
 1802 0094 0F91      		pop r16
 1803 0096 FF90      		pop r15
 1804 0098 EF90      		pop r14
 1805 009a DF90      		pop r13
 1806 009c CF90      		pop r12
 1807               	.LVL174:
 1808 009e BF90      		pop r11
 1809 00a0 AF90      		pop r10
 1810 00a2 9F90      		pop r9
 1811 00a4 8F90      		pop r8
 1812 00a6 0895      		ret
 1813               		.cfi_endproc
 1814               	.LFE46:
 1816               		.section	.text.update_tri_layer,"ax",@progbits
 1817               	.global	update_tri_layer
 1819               	update_tri_layer:
 1820               	.LFB47:
 801:quantum/quantum.c **** 
 802:quantum/quantum.c **** void update_tri_layer(uint8_t layer1, uint8_t layer2, uint8_t layer3) {
 1821               		.loc 1 802 0
 1822               		.cfi_startproc
 1823               	.LVL175:
 1824 0000 0F93      		push r16
 1825               	.LCFI34:
 1826               		.cfi_def_cfa_offset 3
 1827               		.cfi_offset 16, -2
 1828               	/* prologue: function */
 1829               	/* frame size = 0 */
 1830               	/* stack size = 1 */
 1831               	.L__stack_usage = 1
 1832 0002 382F      		mov r19,r24
 1833 0004 262F      		mov r18,r22
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1834               		.loc 1 803 0
 1835 0006 6091 0000 		lds r22,layer_state
 1836 000a 7091 0000 		lds r23,layer_state+1
 1837 000e 8091 0000 		lds r24,layer_state+2
 1838 0012 9091 0000 		lds r25,layer_state+3
 1839               	.LVL176:
 1840 0016 042F      		mov r16,r20
 1841 0018 432F      		mov r20,r19
 1842               	.LVL177:
 1843 001a 0E94 0000 		call update_tri_layer_state
 1844               	.LVL178:
 1845               	/* epilogue start */
 804:quantum/quantum.c **** }
 1846               		.loc 1 804 0
 1847 001e 0F91      		pop r16
 1848               	.LVL179:
 803:quantum/quantum.c ****   layer_state_set(update_tri_layer_state(layer_state, layer1, layer2, layer3));
 1849               		.loc 1 803 0
 1850 0020 0C94 0000 		jmp layer_state_set
 1851               	.LVL180:
 1852               		.cfi_endproc
 1853               	.LFE47:
 1855               		.section	.text.tap_random_base64,"ax",@progbits
 1856               	.global	tap_random_base64
 1858               	tap_random_base64:
 1859               	.LFB48:
 805:quantum/quantum.c **** 
 806:quantum/quantum.c **** void tap_random_base64(void) {
 1860               		.loc 1 806 0
 1861               		.cfi_startproc
 1862 0000 CF93      		push r28
 1863               	.LCFI35:
 1864               		.cfi_def_cfa_offset 3
 1865               		.cfi_offset 28, -2
 1866 0002 DF93      		push r29
 1867               	.LCFI36:
 1868               		.cfi_def_cfa_offset 4
 1869               		.cfi_offset 29, -3
 1870               	/* prologue: function */
 1871               	/* frame size = 0 */
 1872               	/* stack size = 2 */
 1873               	.L__stack_usage = 2
 807:quantum/quantum.c ****   #if defined(__AVR_ATmega32U4__)
 808:quantum/quantum.c ****     uint8_t key = (TCNT0 + TCNT1 + TCNT3 + TCNT4) % 64;
 1874               		.loc 1 808 0
 1875 0004 26B5      		in r18,0x26
 1876 0006 C091 8400 		lds r28,132
 1877 000a D091 8500 		lds r29,132+1
 1878 000e 4091 9400 		lds r20,148
 1879 0012 5091 9500 		lds r21,148+1
 1880 0016 8091 BE00 		lds r24,190
 1881 001a 9091 BF00 		lds r25,190+1
 1882 001e C40F      		add r28,r20
 1883 0020 C20F      		add r28,r18
 1884 0022 8C0F      		add r24,r28
 1885 0024 C82F      		mov r28,r24
 1886 0026 CF73      		andi r28,lo8(63)
 1887               	.LVL181:
 809:quantum/quantum.c ****   #else
 810:quantum/quantum.c ****     uint8_t key = rand() % 64;
 811:quantum/quantum.c ****   #endif
 812:quantum/quantum.c ****   switch (key) {
 1888               		.loc 1 812 0
 1889 0028 CE33      		cpi r28,lo8(62)
 1890 002a 00F4      		brsh .L175
 1891 002c C533      		cpi r28,lo8(53)
 1892 002e 00F4      		brsh .L176
 1893 0030 CA31      		cpi r28,lo8(26)
 1894 0032 00F0      		brlo .L174
 1895 0034 C433      		cpi r28,lo8(52)
 1896 0036 00F4      		brsh .L181
 813:quantum/quantum.c ****     case 0 ... 25:
 814:quantum/quantum.c ****       register_code(KC_LSFT);
 815:quantum/quantum.c ****       register_code(key + KC_A);
 816:quantum/quantum.c ****       unregister_code(key + KC_A);
 817:quantum/quantum.c ****       unregister_code(KC_LSFT);
 818:quantum/quantum.c ****       break;
 819:quantum/quantum.c ****     case 26 ... 51:
 820:quantum/quantum.c ****       register_code(key - 26 + KC_A);
 1897               		.loc 1 820 0
 1898 0038 C651      		subi r28,lo8(-(-22))
 1899               	.LVL182:
 1900 003a 00C0      		rjmp .L184
 1901               	.LVL183:
 1902               	.L175:
 812:quantum/quantum.c ****     case 0 ... 25:
 1903               		.loc 1 812 0
 1904 003c CE33      		cpi r28,lo8(62)
 1905 003e 01F0      		breq .L179
 1906 0040 CF33      		cpi r28,lo8(63)
 1907 0042 01F0      		breq .L180
 1908               	.L174:
 814:quantum/quantum.c ****       register_code(key + KC_A);
 1909               		.loc 1 814 0
 1910 0044 81EE      		ldi r24,lo8(-31)
 1911 0046 0E94 0000 		call register_code
 1912               	.LVL184:
 815:quantum/quantum.c ****       unregister_code(key + KC_A);
 1913               		.loc 1 815 0
 1914 004a CC5F      		subi r28,lo8(-(4))
 1915               	.LVL185:
 1916 004c 8C2F      		mov r24,r28
 1917 004e 0E94 0000 		call register_code
 1918               	.LVL186:
 816:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1919               		.loc 1 816 0
 1920 0052 8C2F      		mov r24,r28
 1921 0054 00C0      		rjmp .L183
 1922               	.LVL187:
 1923               	.L181:
 821:quantum/quantum.c ****       unregister_code(key - 26 + KC_A);
 822:quantum/quantum.c ****       break;
 823:quantum/quantum.c ****     case 52:
 824:quantum/quantum.c ****       register_code(KC_0);
 1924               		.loc 1 824 0
 1925 0056 87E2      		ldi r24,lo8(39)
 1926 0058 0E94 0000 		call register_code
 1927               	.LVL188:
 825:quantum/quantum.c ****       unregister_code(KC_0);
 1928               		.loc 1 825 0
 1929 005c 87E2      		ldi r24,lo8(39)
 1930 005e 00C0      		rjmp .L182
 1931               	.L176:
 826:quantum/quantum.c ****       break;
 827:quantum/quantum.c ****     case 53 ... 61:
 828:quantum/quantum.c ****       register_code(key - 53 + KC_1);
 1932               		.loc 1 828 0
 1933 0060 C751      		subi r28,lo8(-(-23))
 1934               	.LVL189:
 1935               	.L184:
 1936 0062 8C2F      		mov r24,r28
 1937               	.LVL190:
 1938 0064 0E94 0000 		call register_code
 1939               	.LVL191:
 829:quantum/quantum.c ****       unregister_code(key - 53 + KC_1);
 1940               		.loc 1 829 0
 1941 0068 8C2F      		mov r24,r28
 1942 006a 00C0      		rjmp .L182
 1943               	.LVL192:
 1944               	.L179:
 830:quantum/quantum.c ****       break;
 831:quantum/quantum.c ****     case 62:
 832:quantum/quantum.c ****       register_code(KC_LSFT);
 1945               		.loc 1 832 0
 1946 006c 81EE      		ldi r24,lo8(-31)
 1947 006e 0E94 0000 		call register_code
 1948               	.LVL193:
 833:quantum/quantum.c ****       register_code(KC_EQL);
 1949               		.loc 1 833 0
 1950 0072 8EE2      		ldi r24,lo8(46)
 1951 0074 0E94 0000 		call register_code
 1952               	.LVL194:
 834:quantum/quantum.c ****       unregister_code(KC_EQL);
 1953               		.loc 1 834 0
 1954 0078 8EE2      		ldi r24,lo8(46)
 1955               	.LVL195:
 1956               	.L183:
 1957 007a 0E94 0000 		call unregister_code
 1958               	.LVL196:
 835:quantum/quantum.c ****       unregister_code(KC_LSFT);
 1959               		.loc 1 835 0
 1960 007e 81EE      		ldi r24,lo8(-31)
 1961 0080 00C0      		rjmp .L182
 1962               	.LVL197:
 1963               	.L180:
 836:quantum/quantum.c ****       break;
 837:quantum/quantum.c ****     case 63:
 838:quantum/quantum.c ****       register_code(KC_SLSH);
 1964               		.loc 1 838 0
 1965 0082 88E3      		ldi r24,lo8(56)
 1966 0084 0E94 0000 		call register_code
 1967               	.LVL198:
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1968               		.loc 1 839 0
 1969 0088 88E3      		ldi r24,lo8(56)
 1970               	.LVL199:
 1971               	.L182:
 1972               	/* epilogue start */
 840:quantum/quantum.c ****       break;
 841:quantum/quantum.c ****   }
 842:quantum/quantum.c **** }
 1973               		.loc 1 842 0
 1974 008a DF91      		pop r29
 1975 008c CF91      		pop r28
 839:quantum/quantum.c ****       unregister_code(KC_SLSH);
 1976               		.loc 1 839 0
 1977 008e 0C94 0000 		jmp unregister_code
 1978               	.LVL200:
 1979               		.cfi_endproc
 1980               	.LFE48:
 1982               		.section	.text.matrix_init_quantum,"ax",@progbits
 1983               	.global	matrix_init_quantum
 1985               	matrix_init_quantum:
 1986               	.LFB49:
 843:quantum/quantum.c **** 
 844:quantum/quantum.c **** void matrix_init_quantum() {
 1987               		.loc 1 844 0
 1988               		.cfi_startproc
 1989               	/* prologue: function */
 1990               	/* frame size = 0 */
 1991               	/* stack size = 0 */
 1992               	.L__stack_usage = 0
 845:quantum/quantum.c ****   #ifdef BACKLIGHT_ENABLE
 846:quantum/quantum.c ****     backlight_init_ports();
 847:quantum/quantum.c ****   #endif
 848:quantum/quantum.c ****   #ifdef AUDIO_ENABLE
 849:quantum/quantum.c ****     audio_init();
 850:quantum/quantum.c ****   #endif
 851:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 852:quantum/quantum.c ****     rgb_matrix_init_drivers();
 853:quantum/quantum.c ****   #endif
 854:quantum/quantum.c ****   matrix_init_kb();
 1993               		.loc 1 854 0
 1994 0000 0C94 0000 		jmp matrix_init_kb
 1995               	.LVL201:
 1996               		.cfi_endproc
 1997               	.LFE49:
 1999               		.section	.text.matrix_scan_quantum,"ax",@progbits
 2000               	.global	matrix_scan_quantum
 2002               	matrix_scan_quantum:
 2003               	.LFB50:
 855:quantum/quantum.c **** }
 856:quantum/quantum.c **** 
 857:quantum/quantum.c **** uint8_t rgb_matrix_task_counter = 0;
 858:quantum/quantum.c **** 
 859:quantum/quantum.c **** #ifndef RGB_MATRIX_SKIP_FRAMES
 860:quantum/quantum.c ****   #define RGB_MATRIX_SKIP_FRAMES 1
 861:quantum/quantum.c **** #endif
 862:quantum/quantum.c **** 
 863:quantum/quantum.c **** void matrix_scan_quantum() {
 2004               		.loc 1 863 0
 2005               		.cfi_startproc
 2006               	/* prologue: function */
 2007               	/* frame size = 0 */
 2008               	/* stack size = 0 */
 2009               	.L__stack_usage = 0
 864:quantum/quantum.c ****   #if defined(AUDIO_ENABLE)
 865:quantum/quantum.c ****     matrix_scan_music();
 866:quantum/quantum.c ****   #endif
 867:quantum/quantum.c **** 
 868:quantum/quantum.c ****   #ifdef TAP_DANCE_ENABLE
 869:quantum/quantum.c ****     matrix_scan_tap_dance();
 2010               		.loc 1 869 0
 2011 0000 0E94 0000 		call matrix_scan_tap_dance
 2012               	.LVL202:
 870:quantum/quantum.c ****   #endif
 871:quantum/quantum.c **** 
 872:quantum/quantum.c ****   #ifdef COMBO_ENABLE
 873:quantum/quantum.c ****     matrix_scan_combo();
 874:quantum/quantum.c ****   #endif
 875:quantum/quantum.c **** 
 876:quantum/quantum.c ****   #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 877:quantum/quantum.c ****     backlight_task();
 878:quantum/quantum.c ****   #endif
 879:quantum/quantum.c **** 
 880:quantum/quantum.c ****   #ifdef RGB_MATRIX_ENABLE
 881:quantum/quantum.c ****     rgb_matrix_task();
 882:quantum/quantum.c ****     if (rgb_matrix_task_counter == 0) {
 883:quantum/quantum.c ****       rgb_matrix_update_pwm_buffers();
 884:quantum/quantum.c ****     }
 885:quantum/quantum.c ****     rgb_matrix_task_counter = ((rgb_matrix_task_counter + 1) % (RGB_MATRIX_SKIP_FRAMES + 1));
 886:quantum/quantum.c ****   #endif
 887:quantum/quantum.c **** 
 888:quantum/quantum.c ****   matrix_scan_kb();
 2013               		.loc 1 888 0
 2014 0004 0C94 0000 		jmp matrix_scan_kb
 2015               	.LVL203:
 2016               		.cfi_endproc
 2017               	.LFE50:
 2019               		.section	.text.backlight_init_ports,"ax",@progbits
 2020               		.weak	backlight_init_ports
 2022               	backlight_init_ports:
 2023               	.LFB51:
 889:quantum/quantum.c **** }
 890:quantum/quantum.c **** #if defined(BACKLIGHT_ENABLE) && defined(BACKLIGHT_PIN)
 891:quantum/quantum.c **** 
 892:quantum/quantum.c **** static const uint8_t backlight_pin = BACKLIGHT_PIN;
 893:quantum/quantum.c **** 
 894:quantum/quantum.c **** // depending on the pin, we use a different output compare unit
 895:quantum/quantum.c **** #if BACKLIGHT_PIN == B7
 896:quantum/quantum.c **** #  define COM1x1 COM1C1
 897:quantum/quantum.c **** #  define OCR1x  OCR1C
 898:quantum/quantum.c **** #elif BACKLIGHT_PIN == B6
 899:quantum/quantum.c **** #  define COM1x1 COM1B1
 900:quantum/quantum.c **** #  define OCR1x  OCR1B
 901:quantum/quantum.c **** #elif BACKLIGHT_PIN == B5
 902:quantum/quantum.c **** #  define COM1x1 COM1A1
 903:quantum/quantum.c **** #  define OCR1x  OCR1A
 904:quantum/quantum.c **** #else
 905:quantum/quantum.c **** #  define NO_HARDWARE_PWM
 906:quantum/quantum.c **** #endif
 907:quantum/quantum.c **** 
 908:quantum/quantum.c **** #ifndef BACKLIGHT_ON_STATE
 909:quantum/quantum.c **** #define BACKLIGHT_ON_STATE 0
 910:quantum/quantum.c **** #endif
 911:quantum/quantum.c **** 
 912:quantum/quantum.c **** #ifdef NO_HARDWARE_PWM // pwm through software
 913:quantum/quantum.c **** 
 914:quantum/quantum.c **** __attribute__ ((weak))
 915:quantum/quantum.c **** void backlight_init_ports(void)
 916:quantum/quantum.c **** {
 917:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
 918:quantum/quantum.c ****   // DDRx |= n
 919:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
 920:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
 921:quantum/quantum.c ****     // PORTx &= ~n
 922:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 923:quantum/quantum.c ****   #else
 924:quantum/quantum.c ****     // PORTx |= n
 925:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 926:quantum/quantum.c ****   #endif
 927:quantum/quantum.c **** }
 928:quantum/quantum.c **** 
 929:quantum/quantum.c **** __attribute__ ((weak))
 930:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 931:quantum/quantum.c **** 
 932:quantum/quantum.c **** uint8_t backlight_tick = 0;
 933:quantum/quantum.c **** 
 934:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 935:quantum/quantum.c **** void backlight_task(void) {
 936:quantum/quantum.c ****   if ((0xFFFF >> ((BACKLIGHT_LEVELS - get_backlight_level()) * ((BACKLIGHT_LEVELS + 1) / 2))) & (1 
 937:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 938:quantum/quantum.c ****       // PORTx &= ~n
 939:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 940:quantum/quantum.c ****     #else
 941:quantum/quantum.c ****       // PORTx |= n
 942:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 943:quantum/quantum.c ****     #endif
 944:quantum/quantum.c ****   } else {
 945:quantum/quantum.c ****     #if BACKLIGHT_ON_STATE == 0
 946:quantum/quantum.c ****       // PORTx |= n
 947:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
 948:quantum/quantum.c ****     #else
 949:quantum/quantum.c ****       // PORTx &= ~n
 950:quantum/quantum.c ****       _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
 951:quantum/quantum.c ****     #endif
 952:quantum/quantum.c ****   }
 953:quantum/quantum.c ****   backlight_tick = (backlight_tick + 1) % 16;
 954:quantum/quantum.c **** }
 955:quantum/quantum.c **** #endif
 956:quantum/quantum.c **** 
 957:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
 958:quantum/quantum.c ****   #ifndef BACKLIGHT_CUSTOM_DRIVER
 959:quantum/quantum.c ****   #error "Backlight breathing only available with hardware PWM. Please disable."
 960:quantum/quantum.c ****   #endif
 961:quantum/quantum.c **** #endif
 962:quantum/quantum.c **** 
 963:quantum/quantum.c **** #else // pwm through timer
 964:quantum/quantum.c **** 
 965:quantum/quantum.c **** #define TIMER_TOP 0xFFFFU
 966:quantum/quantum.c **** 
 967:quantum/quantum.c **** // See http://jared.geek.nz/2013/feb/linear-led-pwm
 968:quantum/quantum.c **** static uint16_t cie_lightness(uint16_t v) {
 969:quantum/quantum.c ****   if (v <= 5243) // if below 8% of max
 970:quantum/quantum.c ****     return v / 9; // same as dividing by 900%
 971:quantum/quantum.c ****   else {
 972:quantum/quantum.c ****     uint32_t y = (((uint32_t) v + 10486) << 8) / (10486 + 0xFFFFUL); // add 16% of max and compare
 973:quantum/quantum.c ****     // to get a useful result with integer division, we shift left in the expression above
 974:quantum/quantum.c ****     // and revert what we've done again after squaring.
 975:quantum/quantum.c ****     y = y * y * y >> 8;
 976:quantum/quantum.c ****     if (y > 0xFFFFUL) // prevent overflow
 977:quantum/quantum.c ****       return 0xFFFFU;
 978:quantum/quantum.c ****     else
 979:quantum/quantum.c ****       return (uint16_t) y;
 980:quantum/quantum.c ****   }
 981:quantum/quantum.c **** }
 982:quantum/quantum.c **** 
 983:quantum/quantum.c **** // range for val is [0..TIMER_TOP]. PWM pin is high while the timer count is below val.
 984:quantum/quantum.c **** static inline void set_pwm(uint16_t val) {
 985:quantum/quantum.c ****   OCR1x = val;
 986:quantum/quantum.c **** }
 987:quantum/quantum.c **** 
 988:quantum/quantum.c **** #ifndef BACKLIGHT_CUSTOM_DRIVER
 989:quantum/quantum.c **** __attribute__ ((weak))
 990:quantum/quantum.c **** void backlight_set(uint8_t level) {
 991:quantum/quantum.c ****   if (level > BACKLIGHT_LEVELS)
 992:quantum/quantum.c ****     level = BACKLIGHT_LEVELS;
 993:quantum/quantum.c **** 
 994:quantum/quantum.c ****   if (level == 0) {
 995:quantum/quantum.c ****     // Turn off PWM control on backlight pin
 996:quantum/quantum.c ****     TCCR1A &= ~(_BV(COM1x1));
 997:quantum/quantum.c ****   } else {
 998:quantum/quantum.c ****     // Turn on PWM control of backlight pin
 999:quantum/quantum.c ****     TCCR1A |= _BV(COM1x1);
1000:quantum/quantum.c ****   }
1001:quantum/quantum.c ****   // Set the brightness
1002:quantum/quantum.c ****   set_pwm(cie_lightness(TIMER_TOP * (uint32_t)level / BACKLIGHT_LEVELS));
1003:quantum/quantum.c **** }
1004:quantum/quantum.c **** 
1005:quantum/quantum.c **** void backlight_task(void) {}
1006:quantum/quantum.c **** #endif  // BACKLIGHT_CUSTOM_DRIVER
1007:quantum/quantum.c **** 
1008:quantum/quantum.c **** #ifdef BACKLIGHT_BREATHING
1009:quantum/quantum.c **** 
1010:quantum/quantum.c **** #define BREATHING_NO_HALT  0
1011:quantum/quantum.c **** #define BREATHING_HALT_OFF 1
1012:quantum/quantum.c **** #define BREATHING_HALT_ON  2
1013:quantum/quantum.c **** #define BREATHING_STEPS 128
1014:quantum/quantum.c **** 
1015:quantum/quantum.c **** static uint8_t breathing_period = BREATHING_PERIOD;
1016:quantum/quantum.c **** static uint8_t breathing_halt = BREATHING_NO_HALT;
1017:quantum/quantum.c **** static uint16_t breathing_counter = 0;
1018:quantum/quantum.c **** 
1019:quantum/quantum.c **** bool is_breathing(void) {
1020:quantum/quantum.c ****     return !!(TIMSK1 & _BV(TOIE1));
1021:quantum/quantum.c **** }
1022:quantum/quantum.c **** 
1023:quantum/quantum.c **** #define breathing_interrupt_enable() do {TIMSK1 |= _BV(TOIE1);} while (0)
1024:quantum/quantum.c **** #define breathing_interrupt_disable() do {TIMSK1 &= ~_BV(TOIE1);} while (0)
1025:quantum/quantum.c **** #define breathing_min() do {breathing_counter = 0;} while (0)
1026:quantum/quantum.c **** #define breathing_max() do {breathing_counter = breathing_period * 244 / 2;} while (0)
1027:quantum/quantum.c **** 
1028:quantum/quantum.c **** void breathing_enable(void)
1029:quantum/quantum.c **** {
1030:quantum/quantum.c ****   breathing_counter = 0;
1031:quantum/quantum.c ****   breathing_halt = BREATHING_NO_HALT;
1032:quantum/quantum.c ****   breathing_interrupt_enable();
1033:quantum/quantum.c **** }
1034:quantum/quantum.c **** 
1035:quantum/quantum.c **** void breathing_pulse(void)
1036:quantum/quantum.c **** {
1037:quantum/quantum.c ****     if (get_backlight_level() == 0)
1038:quantum/quantum.c ****       breathing_min();
1039:quantum/quantum.c ****     else
1040:quantum/quantum.c ****       breathing_max();
1041:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1042:quantum/quantum.c ****     breathing_interrupt_enable();
1043:quantum/quantum.c **** }
1044:quantum/quantum.c **** 
1045:quantum/quantum.c **** void breathing_disable(void)
1046:quantum/quantum.c **** {
1047:quantum/quantum.c ****     breathing_interrupt_disable();
1048:quantum/quantum.c ****     // Restore backlight level
1049:quantum/quantum.c ****     backlight_set(get_backlight_level());
1050:quantum/quantum.c **** }
1051:quantum/quantum.c **** 
1052:quantum/quantum.c **** void breathing_self_disable(void)
1053:quantum/quantum.c **** {
1054:quantum/quantum.c ****   if (get_backlight_level() == 0)
1055:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_OFF;
1056:quantum/quantum.c ****   else
1057:quantum/quantum.c ****     breathing_halt = BREATHING_HALT_ON;
1058:quantum/quantum.c **** }
1059:quantum/quantum.c **** 
1060:quantum/quantum.c **** void breathing_toggle(void) {
1061:quantum/quantum.c ****   if (is_breathing())
1062:quantum/quantum.c ****     breathing_disable();
1063:quantum/quantum.c ****   else
1064:quantum/quantum.c ****     breathing_enable();
1065:quantum/quantum.c **** }
1066:quantum/quantum.c **** 
1067:quantum/quantum.c **** void breathing_period_set(uint8_t value)
1068:quantum/quantum.c **** {
1069:quantum/quantum.c ****   if (!value)
1070:quantum/quantum.c ****     value = 1;
1071:quantum/quantum.c ****   breathing_period = value;
1072:quantum/quantum.c **** }
1073:quantum/quantum.c **** 
1074:quantum/quantum.c **** void breathing_period_default(void) {
1075:quantum/quantum.c ****   breathing_period_set(BREATHING_PERIOD);
1076:quantum/quantum.c **** }
1077:quantum/quantum.c **** 
1078:quantum/quantum.c **** void breathing_period_inc(void)
1079:quantum/quantum.c **** {
1080:quantum/quantum.c ****   breathing_period_set(breathing_period+1);
1081:quantum/quantum.c **** }
1082:quantum/quantum.c **** 
1083:quantum/quantum.c **** void breathing_period_dec(void)
1084:quantum/quantum.c **** {
1085:quantum/quantum.c ****   breathing_period_set(breathing_period-1);
1086:quantum/quantum.c **** }
1087:quantum/quantum.c **** 
1088:quantum/quantum.c **** /* To generate breathing curve in python:
1089:quantum/quantum.c ****  * from math import sin, pi; [int(sin(x/128.0*pi)**4*255) for x in range(128)]
1090:quantum/quantum.c ****  */
1091:quantum/quantum.c **** static const uint8_t breathing_table[BREATHING_STEPS] PROGMEM = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
1092:quantum/quantum.c **** 
1093:quantum/quantum.c **** // Use this before the cie_lightness function.
1094:quantum/quantum.c **** static inline uint16_t scale_backlight(uint16_t v) {
1095:quantum/quantum.c ****   return v / BACKLIGHT_LEVELS * get_backlight_level();
1096:quantum/quantum.c **** }
1097:quantum/quantum.c **** 
1098:quantum/quantum.c **** /* Assuming a 16MHz CPU clock and a timer that resets at 64k (ICR1), the following interrupt handle
1099:quantum/quantum.c ****  * about 244 times per second.
1100:quantum/quantum.c ****  */
1101:quantum/quantum.c **** ISR(TIMER1_OVF_vect)
1102:quantum/quantum.c **** {
1103:quantum/quantum.c ****   uint16_t interval = (uint16_t) breathing_period * 244 / BREATHING_STEPS;
1104:quantum/quantum.c ****   // resetting after one period to prevent ugly reset at overflow.
1105:quantum/quantum.c ****   breathing_counter = (breathing_counter + 1) % (breathing_period * 244);
1106:quantum/quantum.c ****   uint8_t index = breathing_counter / interval % BREATHING_STEPS;
1107:quantum/quantum.c **** 
1108:quantum/quantum.c ****   if (((breathing_halt == BREATHING_HALT_ON) && (index == BREATHING_STEPS / 2)) ||
1109:quantum/quantum.c ****       ((breathing_halt == BREATHING_HALT_OFF) && (index == BREATHING_STEPS - 1)))
1110:quantum/quantum.c ****   {
1111:quantum/quantum.c ****       breathing_interrupt_disable();
1112:quantum/quantum.c ****   }
1113:quantum/quantum.c **** 
1114:quantum/quantum.c ****   set_pwm(cie_lightness(scale_backlight((uint16_t) pgm_read_byte(&breathing_table[index]) * 0x0101U
1115:quantum/quantum.c **** }
1116:quantum/quantum.c **** 
1117:quantum/quantum.c **** #endif // BACKLIGHT_BREATHING
1118:quantum/quantum.c **** 
1119:quantum/quantum.c **** __attribute__ ((weak))
1120:quantum/quantum.c **** void backlight_init_ports(void)
1121:quantum/quantum.c **** {
1122:quantum/quantum.c ****   // Setup backlight pin as output and output to on state.
1123:quantum/quantum.c ****   // DDRx |= n
1124:quantum/quantum.c ****   _SFR_IO8((backlight_pin >> 4) + 1) |= _BV(backlight_pin & 0xF);
1125:quantum/quantum.c ****   #if BACKLIGHT_ON_STATE == 0
1126:quantum/quantum.c ****     // PORTx &= ~n
1127:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) &= ~_BV(backlight_pin & 0xF);
1128:quantum/quantum.c ****   #else
1129:quantum/quantum.c ****     // PORTx |= n
1130:quantum/quantum.c ****     _SFR_IO8((backlight_pin >> 4) + 2) |= _BV(backlight_pin & 0xF);
1131:quantum/quantum.c ****   #endif
1132:quantum/quantum.c ****   // I could write a wall of text here to explain... but TL;DW
1133:quantum/quantum.c ****   // Go read the ATmega32u4 datasheet.
1134:quantum/quantum.c ****   // And this: http://blog.saikoled.com/post/43165849837/secret-konami-cheat-code-to-high-resolutio
1135:quantum/quantum.c **** 
1136:quantum/quantum.c ****   // Pin PB7 = OCR1C (Timer 1, Channel C)
1137:quantum/quantum.c ****   // Compare Output Mode = Clear on compare match, Channel C = COM1C1=1 COM1C0=0
1138:quantum/quantum.c ****   // (i.e. start high, go low when counter matches.)
1139:quantum/quantum.c ****   // WGM Mode 14 (Fast PWM) = WGM13=1 WGM12=1 WGM11=1 WGM10=0
1140:quantum/quantum.c ****   // Clock Select = clk/1 (no prescaling) = CS12=0 CS11=0 CS10=1
1141:quantum/quantum.c **** 
1142:quantum/quantum.c ****   /*
1143:quantum/quantum.c ****   14.8.3:
1144:quantum/quantum.c ****   "In fast PWM mode, the compare units allow generation of PWM waveforms on the OCnx pins. Setting 
1145:quantum/quantum.c ****   "In fast PWM mode the counter is incremented until the counter value matches either one of the fi
1146:quantum/quantum.c ****   */
1147:quantum/quantum.c **** 
1148:quantum/quantum.c ****   TCCR1A = _BV(COM1x1) | _BV(WGM11); // = 0b00001010;
1149:quantum/quantum.c ****   TCCR1B = _BV(WGM13) | _BV(WGM12) | _BV(CS10); // = 0b00011001;
1150:quantum/quantum.c ****   // Use full 16-bit resolution. Counter counts to ICR1 before reset to 0.
1151:quantum/quantum.c ****   ICR1 = TIMER_TOP;
1152:quantum/quantum.c **** 
1153:quantum/quantum.c ****   backlight_init();
1154:quantum/quantum.c ****   #ifdef BACKLIGHT_BREATHING
1155:quantum/quantum.c ****     breathing_enable();
1156:quantum/quantum.c ****   #endif
1157:quantum/quantum.c **** }
1158:quantum/quantum.c **** 
1159:quantum/quantum.c **** #endif // NO_HARDWARE_PWM
1160:quantum/quantum.c **** 
1161:quantum/quantum.c **** #else // backlight
1162:quantum/quantum.c **** 
1163:quantum/quantum.c **** __attribute__ ((weak))
1164:quantum/quantum.c **** void backlight_init_ports(void) {}
 2024               		.loc 1 1164 0
 2025               		.cfi_startproc
 2026               	/* prologue: function */
 2027               	/* frame size = 0 */
 2028               	/* stack size = 0 */
 2029               	.L__stack_usage = 0
 2030 0000 0895      		ret
 2031               		.cfi_endproc
 2032               	.LFE51:
 2034               		.section	.text.backlight_set,"ax",@progbits
 2035               		.weak	backlight_set
 2037               	backlight_set:
 2038               	.LFB52:
1165:quantum/quantum.c **** 
1166:quantum/quantum.c **** __attribute__ ((weak))
1167:quantum/quantum.c **** void backlight_set(uint8_t level) {}
 2039               		.loc 1 1167 0
 2040               		.cfi_startproc
 2041               	.LVL204:
 2042               	/* prologue: function */
 2043               	/* frame size = 0 */
 2044               	/* stack size = 0 */
 2045               	.L__stack_usage = 0
 2046 0000 0895      		ret
 2047               		.cfi_endproc
 2048               	.LFE52:
 2050               		.section	.text.send_nibble,"ax",@progbits
 2051               	.global	send_nibble
 2053               	send_nibble:
 2054               	.LFB56:
1168:quantum/quantum.c **** 
1169:quantum/quantum.c **** #endif // backlight
1170:quantum/quantum.c **** 
1171:quantum/quantum.c **** 
1172:quantum/quantum.c **** // Functions for spitting out values
1173:quantum/quantum.c **** //
1174:quantum/quantum.c **** 
1175:quantum/quantum.c **** void send_dword(uint32_t number) { // this might not actually work
1176:quantum/quantum.c ****     uint16_t word = (number >> 16);
1177:quantum/quantum.c ****     send_word(word);
1178:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
1179:quantum/quantum.c **** }
1180:quantum/quantum.c **** 
1181:quantum/quantum.c **** void send_word(uint16_t number) {
1182:quantum/quantum.c ****     uint8_t byte = number >> 8;
1183:quantum/quantum.c ****     send_byte(byte);
1184:quantum/quantum.c ****     send_byte(number & 0xFF);
1185:quantum/quantum.c **** }
1186:quantum/quantum.c **** 
1187:quantum/quantum.c **** void send_byte(uint8_t number) {
1188:quantum/quantum.c ****     uint8_t nibble = number >> 4;
1189:quantum/quantum.c ****     send_nibble(nibble);
1190:quantum/quantum.c ****     send_nibble(number & 0xF);
1191:quantum/quantum.c **** }
1192:quantum/quantum.c **** 
1193:quantum/quantum.c **** void send_nibble(uint8_t number) {
 2055               		.loc 1 1193 0
 2056               		.cfi_startproc
 2057               	.LVL205:
 2058               		.loc 1 1193 0
 2059 0000 CF93      		push r28
 2060               	.LCFI37:
 2061               		.cfi_def_cfa_offset 3
 2062               		.cfi_offset 28, -2
 2063               	/* prologue: function */
 2064               	/* frame size = 0 */
 2065               	/* stack size = 1 */
 2066               	.L__stack_usage = 1
1194:quantum/quantum.c ****     switch (number) {
 2067               		.loc 1 1194 0
 2068 0002 8A30      		cpi r24,lo8(10)
 2069 0004 00F4      		brsh .L191
 2070 0006 8130      		cpi r24,lo8(1)
 2071 0008 00F4      		brsh .L199
1195:quantum/quantum.c ****         case 0:
1196:quantum/quantum.c ****             register_code(KC_0);
 2072               		.loc 1 1196 0
 2073 000a 87E2      		ldi r24,lo8(39)
 2074               	.LVL206:
 2075 000c 0E94 0000 		call register_code
 2076               	.LVL207:
1197:quantum/quantum.c ****             unregister_code(KC_0);
 2077               		.loc 1 1197 0
 2078 0010 87E2      		ldi r24,lo8(39)
 2079 0012 00C0      		rjmp .L197
 2080               	.LVL208:
 2081               	.L191:
1194:quantum/quantum.c ****     switch (number) {
 2082               		.loc 1 1194 0
 2083 0014 8031      		cpi r24,lo8(16)
 2084 0016 00F4      		brsh .L200
1198:quantum/quantum.c ****             break;
1199:quantum/quantum.c ****         case 1 ... 9:
1200:quantum/quantum.c ****             register_code(KC_1 + (number - 1));
1201:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
1202:quantum/quantum.c ****             break;
1203:quantum/quantum.c ****         case 0xA ... 0xF:
1204:quantum/quantum.c ****             register_code(KC_A + (number - 0xA));
 2085               		.loc 1 1204 0
 2086 0018 CAEF      		ldi r28,lo8(-6)
 2087 001a 00C0      		rjmp .L198
 2088               	.L199:
1200:quantum/quantum.c ****             unregister_code(KC_1 + (number - 1));
 2089               		.loc 1 1200 0
 2090 001c CDE1      		ldi r28,lo8(29)
 2091               	.L198:
 2092               		.loc 1 1204 0
 2093 001e C80F      		add r28,r24
 2094 0020 8C2F      		mov r24,r28
 2095               	.LVL209:
 2096 0022 0E94 0000 		call register_code
 2097               	.LVL210:
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2098               		.loc 1 1205 0
 2099 0026 8C2F      		mov r24,r28
 2100               	.L197:
 2101               	/* epilogue start */
1206:quantum/quantum.c ****             break;
1207:quantum/quantum.c ****     }
1208:quantum/quantum.c **** }
 2102               		.loc 1 1208 0
 2103 0028 CF91      		pop r28
1205:quantum/quantum.c ****             unregister_code(KC_A + (number - 0xA));
 2104               		.loc 1 1205 0
 2105 002a 0C94 0000 		jmp unregister_code
 2106               	.LVL211:
 2107               	.L200:
 2108               	/* epilogue start */
 2109               		.loc 1 1208 0
 2110 002e CF91      		pop r28
 2111 0030 0895      		ret
 2112               		.cfi_endproc
 2113               	.LFE56:
 2115               		.section	.text.send_byte,"ax",@progbits
 2116               	.global	send_byte
 2118               	send_byte:
 2119               	.LFB55:
1187:quantum/quantum.c ****     uint8_t nibble = number >> 4;
 2120               		.loc 1 1187 0
 2121               		.cfi_startproc
 2122               	.LVL212:
 2123 0000 CF93      		push r28
 2124               	.LCFI38:
 2125               		.cfi_def_cfa_offset 3
 2126               		.cfi_offset 28, -2
 2127               	/* prologue: function */
 2128               	/* frame size = 0 */
 2129               	/* stack size = 1 */
 2130               	.L__stack_usage = 1
 2131 0002 C82F      		mov r28,r24
 2132               	.LVL213:
1189:quantum/quantum.c ****     send_nibble(number & 0xF);
 2133               		.loc 1 1189 0
 2134 0004 8295      		swap r24
 2135               	.LVL214:
 2136 0006 8F70      		andi r24,lo8(15)
 2137 0008 0E94 0000 		call send_nibble
 2138               	.LVL215:
1190:quantum/quantum.c **** }
 2139               		.loc 1 1190 0
 2140 000c 8C2F      		mov r24,r28
 2141 000e 8F70      		andi r24,lo8(15)
 2142               	/* epilogue start */
1191:quantum/quantum.c **** 
 2143               		.loc 1 1191 0
 2144 0010 CF91      		pop r28
 2145               	.LVL216:
1190:quantum/quantum.c **** }
 2146               		.loc 1 1190 0
 2147 0012 0C94 0000 		jmp send_nibble
 2148               	.LVL217:
 2149               		.cfi_endproc
 2150               	.LFE55:
 2152               		.section	.text.send_word,"ax",@progbits
 2153               	.global	send_word
 2155               	send_word:
 2156               	.LFB54:
1181:quantum/quantum.c ****     uint8_t byte = number >> 8;
 2157               		.loc 1 1181 0
 2158               		.cfi_startproc
 2159               	.LVL218:
 2160 0000 CF93      		push r28
 2161               	.LCFI39:
 2162               		.cfi_def_cfa_offset 3
 2163               		.cfi_offset 28, -2
 2164               	/* prologue: function */
 2165               	/* frame size = 0 */
 2166               	/* stack size = 1 */
 2167               	.L__stack_usage = 1
 2168 0002 C82F      		mov r28,r24
 2169               	.LVL219:
1183:quantum/quantum.c ****     send_byte(number & 0xFF);
 2170               		.loc 1 1183 0
 2171 0004 892F      		mov r24,r25
 2172               	.LVL220:
 2173 0006 0E94 0000 		call send_byte
 2174               	.LVL221:
1184:quantum/quantum.c **** }
 2175               		.loc 1 1184 0
 2176 000a 8C2F      		mov r24,r28
 2177               	/* epilogue start */
1185:quantum/quantum.c **** 
 2178               		.loc 1 1185 0
 2179 000c CF91      		pop r28
1184:quantum/quantum.c **** }
 2180               		.loc 1 1184 0
 2181 000e 0C94 0000 		jmp send_byte
 2182               	.LVL222:
 2183               		.cfi_endproc
 2184               	.LFE54:
 2186               		.section	.text.send_dword,"ax",@progbits
 2187               	.global	send_dword
 2189               	send_dword:
 2190               	.LFB53:
1175:quantum/quantum.c ****     uint16_t word = (number >> 16);
 2191               		.loc 1 1175 0
 2192               		.cfi_startproc
 2193               	.LVL223:
 2194 0000 CF92      		push r12
 2195               	.LCFI40:
 2196               		.cfi_def_cfa_offset 3
 2197               		.cfi_offset 12, -2
 2198 0002 DF92      		push r13
 2199               	.LCFI41:
 2200               		.cfi_def_cfa_offset 4
 2201               		.cfi_offset 13, -3
 2202 0004 EF92      		push r14
 2203               	.LCFI42:
 2204               		.cfi_def_cfa_offset 5
 2205               		.cfi_offset 14, -4
 2206 0006 FF92      		push r15
 2207               	.LCFI43:
 2208               		.cfi_def_cfa_offset 6
 2209               		.cfi_offset 15, -5
 2210               	/* prologue: function */
 2211               	/* frame size = 0 */
 2212               	/* stack size = 4 */
 2213               	.L__stack_usage = 4
 2214 0008 6B01      		movw r12,r22
 2215 000a 7C01      		movw r14,r24
 2216               	.LVL224:
1177:quantum/quantum.c ****     send_word(number & 0xFFFFUL);
 2217               		.loc 1 1177 0
 2218 000c C701      		movw r24,r14
 2219 000e 0E94 0000 		call send_word
 2220               	.LVL225:
1178:quantum/quantum.c **** }
 2221               		.loc 1 1178 0
 2222 0012 C601      		movw r24,r12
 2223               	/* epilogue start */
1179:quantum/quantum.c **** 
 2224               		.loc 1 1179 0
 2225 0014 FF90      		pop r15
 2226 0016 EF90      		pop r14
 2227 0018 DF90      		pop r13
 2228 001a CF90      		pop r12
 2229               	.LVL226:
1178:quantum/quantum.c **** }
 2230               		.loc 1 1178 0
 2231 001c 0C94 0000 		jmp send_word
 2232               	.LVL227:
 2233               		.cfi_endproc
 2234               	.LFE53:
 2236               		.section	.text.hex_to_keycode,"ax",@progbits
 2237               		.weak	hex_to_keycode
 2239               	hex_to_keycode:
 2240               	.LFB57:
1209:quantum/quantum.c **** 
1210:quantum/quantum.c **** 
1211:quantum/quantum.c **** __attribute__((weak))
1212:quantum/quantum.c **** uint16_t hex_to_keycode(uint8_t hex)
1213:quantum/quantum.c **** {
 2241               		.loc 1 1213 0
 2242               		.cfi_startproc
 2243               	.LVL228:
 2244               	/* prologue: function */
 2245               	/* frame size = 0 */
 2246               	/* stack size = 0 */
 2247               	.L__stack_usage = 0
1214:quantum/quantum.c ****   hex = hex & 0xF;
 2248               		.loc 1 1214 0
 2249 0000 282F      		mov r18,r24
 2250 0002 2F70      		andi r18,lo8(15)
 2251               	.LVL229:
1215:quantum/quantum.c ****   if (hex == 0x0) {
 2252               		.loc 1 1215 0
 2253 0004 01F0      		breq .L207
 2254 0006 822F      		mov r24,r18
 2255 0008 90E0      		ldi r25,0
1216:quantum/quantum.c ****     return KC_0;
1217:quantum/quantum.c ****   } else if (hex < 0xA) {
 2256               		.loc 1 1217 0
 2257 000a 2A30      		cpi r18,lo8(10)
 2258 000c 00F4      		brsh .L206
1218:quantum/quantum.c ****     return KC_1 + (hex - 0x1);
 2259               		.loc 1 1218 0
 2260 000e 4D96      		adiw r24,29
 2261 0010 0895      		ret
 2262               	.L206:
1219:quantum/quantum.c ****   } else {
1220:quantum/quantum.c ****     return KC_A + (hex - 0xA);
 2263               		.loc 1 1220 0
 2264 0012 0697      		sbiw r24,6
 2265 0014 0895      		ret
 2266               	.L207:
1216:quantum/quantum.c ****   } else if (hex < 0xA) {
 2267               		.loc 1 1216 0
 2268 0016 87E2      		ldi r24,lo8(39)
 2269 0018 90E0      		ldi r25,0
1221:quantum/quantum.c ****   }
1222:quantum/quantum.c **** }
 2270               		.loc 1 1222 0
 2271 001a 0895      		ret
 2272               		.cfi_endproc
 2273               	.LFE57:
 2275               		.section	.text.api_send_unicode,"ax",@progbits
 2276               	.global	api_send_unicode
 2278               	api_send_unicode:
 2279               	.LFB58:
1223:quantum/quantum.c **** 
1224:quantum/quantum.c **** void api_send_unicode(uint32_t unicode) {
 2280               		.loc 1 1224 0
 2281               		.cfi_startproc
 2282               	.LVL230:
 2283               	/* prologue: function */
 2284               	/* frame size = 0 */
 2285               	/* stack size = 0 */
 2286               	.L__stack_usage = 0
 2287 0000 0895      		ret
 2288               		.cfi_endproc
 2289               	.LFE58:
 2291               		.section	.text.led_set_user,"ax",@progbits
 2292               		.weak	led_set_user
 2294               	led_set_user:
 2295               	.LFB59:
1225:quantum/quantum.c **** #ifdef API_ENABLE
1226:quantum/quantum.c ****     uint8_t chunk[4];
1227:quantum/quantum.c ****     dword_to_bytes(unicode, chunk);
1228:quantum/quantum.c ****     MT_SEND_DATA(DT_UNICODE, chunk, 5);
1229:quantum/quantum.c **** #endif
1230:quantum/quantum.c **** }
1231:quantum/quantum.c **** 
1232:quantum/quantum.c **** __attribute__ ((weak))
1233:quantum/quantum.c **** void led_set_user(uint8_t usb_led) {
 2296               		.loc 1 1233 0
 2297               		.cfi_startproc
 2298               	.LVL231:
 2299               	/* prologue: function */
 2300               	/* frame size = 0 */
 2301               	/* stack size = 0 */
 2302               	.L__stack_usage = 0
 2303 0000 0895      		ret
 2304               		.cfi_endproc
 2305               	.LFE59:
 2307               		.section	.text.led_set_kb,"ax",@progbits
 2308               		.weak	led_set_kb
 2310               	led_set_kb:
 2311               	.LFB60:
1234:quantum/quantum.c **** 
1235:quantum/quantum.c **** }
1236:quantum/quantum.c **** 
1237:quantum/quantum.c **** __attribute__ ((weak))
1238:quantum/quantum.c **** void led_set_kb(uint8_t usb_led) {
 2312               		.loc 1 1238 0
 2313               		.cfi_startproc
 2314               	.LVL232:
 2315               	/* prologue: function */
 2316               	/* frame size = 0 */
 2317               	/* stack size = 0 */
 2318               	.L__stack_usage = 0
1239:quantum/quantum.c ****     led_set_user(usb_led);
 2319               		.loc 1 1239 0
 2320 0000 0C94 0000 		jmp led_set_user
 2321               	.LVL233:
 2322               		.cfi_endproc
 2323               	.LFE60:
 2325               		.section	.text.led_init_ports,"ax",@progbits
 2326               		.weak	led_init_ports
 2328               	led_init_ports:
 2329               	.LFB61:
1240:quantum/quantum.c **** }
1241:quantum/quantum.c **** 
1242:quantum/quantum.c **** __attribute__ ((weak))
1243:quantum/quantum.c **** void led_init_ports(void)
1244:quantum/quantum.c **** {
 2330               		.loc 1 1244 0
 2331               		.cfi_startproc
 2332               	/* prologue: function */
 2333               	/* frame size = 0 */
 2334               	/* stack size = 0 */
 2335               	.L__stack_usage = 0
 2336 0000 0895      		ret
 2337               		.cfi_endproc
 2338               	.LFE61:
 2340               		.section	.text.led_set,"ax",@progbits
 2341               		.weak	led_set
 2343               	led_set:
 2344               	.LFB62:
1245:quantum/quantum.c **** 
1246:quantum/quantum.c **** }
1247:quantum/quantum.c **** 
1248:quantum/quantum.c **** __attribute__ ((weak))
1249:quantum/quantum.c **** void led_set(uint8_t usb_led)
1250:quantum/quantum.c **** {
 2345               		.loc 1 1250 0
 2346               		.cfi_startproc
 2347               	.LVL234:
 2348               	/* prologue: function */
 2349               	/* frame size = 0 */
 2350               	/* stack size = 0 */
 2351               	.L__stack_usage = 0
1251:quantum/quantum.c **** 
1252:quantum/quantum.c ****   // Example LED Code
1253:quantum/quantum.c ****   //
1254:quantum/quantum.c ****     // // Using PE6 Caps Lock LED
1255:quantum/quantum.c ****     // if (usb_led & (1<<USB_LED_CAPS_LOCK))
1256:quantum/quantum.c ****     // {
1257:quantum/quantum.c ****     //     // Output high.
1258:quantum/quantum.c ****     //     DDRE |= (1<<6);
1259:quantum/quantum.c ****     //     PORTE |= (1<<6);
1260:quantum/quantum.c ****     // }
1261:quantum/quantum.c ****     // else
1262:quantum/quantum.c ****     // {
1263:quantum/quantum.c ****     //     // Output low.
1264:quantum/quantum.c ****     //     DDRE &= ~(1<<6);
1265:quantum/quantum.c ****     //     PORTE &= ~(1<<6);
1266:quantum/quantum.c ****     // }
1267:quantum/quantum.c **** 
1268:quantum/quantum.c ****   led_set_kb(usb_led);
 2352               		.loc 1 1268 0
 2353 0000 0C94 0000 		jmp led_set_kb
 2354               	.LVL235:
 2355               		.cfi_endproc
 2356               	.LFE62:
 2358               		.section	.text.startup_user,"ax",@progbits
 2359               		.weak	startup_user
 2361               	startup_user:
 2362               	.LFB63:
1269:quantum/quantum.c **** }
1270:quantum/quantum.c **** 
1271:quantum/quantum.c **** 
1272:quantum/quantum.c **** //------------------------------------------------------------------------------
1273:quantum/quantum.c **** // Override these functions in your keymap file to play different tunes on
1274:quantum/quantum.c **** // different events such as startup and bootloader jump
1275:quantum/quantum.c **** 
1276:quantum/quantum.c **** __attribute__ ((weak))
1277:quantum/quantum.c **** void startup_user() {}
 2363               		.loc 1 1277 0
 2364               		.cfi_startproc
 2365               	/* prologue: function */
 2366               	/* frame size = 0 */
 2367               	/* stack size = 0 */
 2368               	.L__stack_usage = 0
 2369 0000 0895      		ret
 2370               		.cfi_endproc
 2371               	.LFE63:
 2373               		.section	.text.shutdown_user,"ax",@progbits
 2374               		.weak	shutdown_user
 2376               	shutdown_user:
 2377               	.LFB64:
1278:quantum/quantum.c **** 
1279:quantum/quantum.c **** __attribute__ ((weak))
1280:quantum/quantum.c **** void shutdown_user() {}
 2378               		.loc 1 1280 0
 2379               		.cfi_startproc
 2380               	/* prologue: function */
 2381               	/* frame size = 0 */
 2382               	/* stack size = 0 */
 2383               	.L__stack_usage = 0
 2384 0000 0895      		ret
 2385               		.cfi_endproc
 2386               	.LFE64:
 2388               		.section	.progmem.data.__c.3295,"a",@progbits
 2391               	__c.3295:
 2392 0000 4445 4255 		.string	"DEBUG: enabled.\n"
 2392      473A 2065 
 2392      6E61 626C 
 2392      6564 2E0A 
 2392      00
 2393               	.global	rgb_matrix_task_counter
 2394               		.section	.bss.rgb_matrix_task_counter,"aw",@nobits
 2397               	rgb_matrix_task_counter:
 2398 0000 00        		.zero	1
 2399               		.weak	ascii_to_keycode_lut
 2400               		.section	.progmem.data.ascii_to_keycode_lut,"a",@progbits
 2403               	ascii_to_keycode_lut:
 2404 0000 00        		.byte	0
 2405 0001 00        		.byte	0
 2406 0002 00        		.byte	0
 2407 0003 00        		.byte	0
 2408 0004 00        		.byte	0
 2409 0005 00        		.byte	0
 2410 0006 00        		.byte	0
 2411 0007 00        		.byte	0
 2412 0008 2A        		.byte	42
 2413 0009 2B        		.byte	43
 2414 000a 28        		.byte	40
 2415 000b 00        		.byte	0
 2416 000c 00        		.byte	0
 2417 000d 00        		.byte	0
 2418 000e 00        		.byte	0
 2419 000f 00        		.byte	0
 2420 0010 00        		.byte	0
 2421 0011 00        		.byte	0
 2422 0012 00        		.byte	0
 2423 0013 00        		.byte	0
 2424 0014 00        		.byte	0
 2425 0015 00        		.byte	0
 2426 0016 00        		.byte	0
 2427 0017 00        		.byte	0
 2428 0018 00        		.byte	0
 2429 0019 00        		.byte	0
 2430 001a 00        		.byte	0
 2431 001b 29        		.byte	41
 2432 001c 00        		.byte	0
 2433 001d 00        		.byte	0
 2434 001e 00        		.byte	0
 2435 001f 00        		.byte	0
 2436 0020 2C        		.byte	44
 2437 0021 1E        		.byte	30
 2438 0022 34        		.byte	52
 2439 0023 20        		.byte	32
 2440 0024 21        		.byte	33
 2441 0025 22        		.byte	34
 2442 0026 24        		.byte	36
 2443 0027 34        		.byte	52
 2444 0028 26        		.byte	38
 2445 0029 27        		.byte	39
 2446 002a 25        		.byte	37
 2447 002b 2E        		.byte	46
 2448 002c 36        		.byte	54
 2449 002d 2D        		.byte	45
 2450 002e 37        		.byte	55
 2451 002f 38        		.byte	56
 2452 0030 27        		.byte	39
 2453 0031 1E        		.byte	30
 2454 0032 1F        		.byte	31
 2455 0033 20        		.byte	32
 2456 0034 21        		.byte	33
 2457 0035 22        		.byte	34
 2458 0036 23        		.byte	35
 2459 0037 24        		.byte	36
 2460 0038 25        		.byte	37
 2461 0039 26        		.byte	38
 2462 003a 33        		.byte	51
 2463 003b 33        		.byte	51
 2464 003c 36        		.byte	54
 2465 003d 2E        		.byte	46
 2466 003e 37        		.byte	55
 2467 003f 38        		.byte	56
 2468 0040 1F        		.byte	31
 2469 0041 04        		.byte	4
 2470 0042 05        		.byte	5
 2471 0043 06        		.byte	6
 2472 0044 07        		.byte	7
 2473 0045 08        		.byte	8
 2474 0046 09        		.byte	9
 2475 0047 0A        		.byte	10
 2476 0048 0B        		.byte	11
 2477 0049 0C        		.byte	12
 2478 004a 0D        		.byte	13
 2479 004b 0E        		.byte	14
 2480 004c 0F        		.byte	15
 2481 004d 10        		.byte	16
 2482 004e 11        		.byte	17
 2483 004f 12        		.byte	18
 2484 0050 13        		.byte	19
 2485 0051 14        		.byte	20
 2486 0052 15        		.byte	21
 2487 0053 16        		.byte	22
 2488 0054 17        		.byte	23
 2489 0055 18        		.byte	24
 2490 0056 19        		.byte	25
 2491 0057 1A        		.byte	26
 2492 0058 1B        		.byte	27
 2493 0059 1C        		.byte	28
 2494 005a 1D        		.byte	29
 2495 005b 2F        		.byte	47
 2496 005c 31        		.byte	49
 2497 005d 30        		.byte	48
 2498 005e 23        		.byte	35
 2499 005f 2D        		.byte	45
 2500 0060 35        		.byte	53
 2501 0061 04        		.byte	4
 2502 0062 05        		.byte	5
 2503 0063 06        		.byte	6
 2504 0064 07        		.byte	7
 2505 0065 08        		.byte	8
 2506 0066 09        		.byte	9
 2507 0067 0A        		.byte	10
 2508 0068 0B        		.byte	11
 2509 0069 0C        		.byte	12
 2510 006a 0D        		.byte	13
 2511 006b 0E        		.byte	14
 2512 006c 0F        		.byte	15
 2513 006d 10        		.byte	16
 2514 006e 11        		.byte	17
 2515 006f 12        		.byte	18
 2516 0070 13        		.byte	19
 2517 0071 14        		.byte	20
 2518 0072 15        		.byte	21
 2519 0073 16        		.byte	22
 2520 0074 17        		.byte	23
 2521 0075 18        		.byte	24
 2522 0076 19        		.byte	25
 2523 0077 1A        		.byte	26
 2524 0078 1B        		.byte	27
 2525 0079 1C        		.byte	28
 2526 007a 1D        		.byte	29
 2527 007b 2F        		.byte	47
 2528 007c 31        		.byte	49
 2529 007d 30        		.byte	48
 2530 007e 35        		.byte	53
 2531 007f 4C        		.byte	76
 2532               		.weak	ascii_to_shift_lut
 2533               		.section	.progmem.data.ascii_to_shift_lut,"a",@progbits
 2536               	ascii_to_shift_lut:
 2537 0000 00        		.byte	0
 2538 0001 00        		.byte	0
 2539 0002 00        		.byte	0
 2540 0003 00        		.byte	0
 2541 0004 00        		.byte	0
 2542 0005 00        		.byte	0
 2543 0006 00        		.byte	0
 2544 0007 00        		.byte	0
 2545 0008 00        		.byte	0
 2546 0009 00        		.byte	0
 2547 000a 00        		.byte	0
 2548 000b 00        		.byte	0
 2549 000c 00        		.byte	0
 2550 000d 00        		.byte	0
 2551 000e 00        		.byte	0
 2552 000f 00        		.byte	0
 2553 0010 00        		.byte	0
 2554 0011 00        		.byte	0
 2555 0012 00        		.byte	0
 2556 0013 00        		.byte	0
 2557 0014 00        		.byte	0
 2558 0015 00        		.byte	0
 2559 0016 00        		.byte	0
 2560 0017 00        		.byte	0
 2561 0018 00        		.byte	0
 2562 0019 00        		.byte	0
 2563 001a 00        		.byte	0
 2564 001b 00        		.byte	0
 2565 001c 00        		.byte	0
 2566 001d 00        		.byte	0
 2567 001e 00        		.byte	0
 2568 001f 00        		.byte	0
 2569 0020 00        		.byte	0
 2570 0021 01        		.byte	1
 2571 0022 01        		.byte	1
 2572 0023 01        		.byte	1
 2573 0024 01        		.byte	1
 2574 0025 01        		.byte	1
 2575 0026 01        		.byte	1
 2576 0027 00        		.byte	0
 2577 0028 01        		.byte	1
 2578 0029 01        		.byte	1
 2579 002a 01        		.byte	1
 2580 002b 01        		.byte	1
 2581 002c 00        		.byte	0
 2582 002d 00        		.byte	0
 2583 002e 00        		.byte	0
 2584 002f 00        		.byte	0
 2585 0030 00        		.byte	0
 2586 0031 00        		.byte	0
 2587 0032 00        		.byte	0
 2588 0033 00        		.byte	0
 2589 0034 00        		.byte	0
 2590 0035 00        		.byte	0
 2591 0036 00        		.byte	0
 2592 0037 00        		.byte	0
 2593 0038 00        		.byte	0
 2594 0039 00        		.byte	0
 2595 003a 01        		.byte	1
 2596 003b 00        		.byte	0
 2597 003c 01        		.byte	1
 2598 003d 00        		.byte	0
 2599 003e 01        		.byte	1
 2600 003f 01        		.byte	1
 2601 0040 01        		.byte	1
 2602 0041 01        		.byte	1
 2603 0042 01        		.byte	1
 2604 0043 01        		.byte	1
 2605 0044 01        		.byte	1
 2606 0045 01        		.byte	1
 2607 0046 01        		.byte	1
 2608 0047 01        		.byte	1
 2609 0048 01        		.byte	1
 2610 0049 01        		.byte	1
 2611 004a 01        		.byte	1
 2612 004b 01        		.byte	1
 2613 004c 01        		.byte	1
 2614 004d 01        		.byte	1
 2615 004e 01        		.byte	1
 2616 004f 01        		.byte	1
 2617 0050 01        		.byte	1
 2618 0051 01        		.byte	1
 2619 0052 01        		.byte	1
 2620 0053 01        		.byte	1
 2621 0054 01        		.byte	1
 2622 0055 01        		.byte	1
 2623 0056 01        		.byte	1
 2624 0057 01        		.byte	1
 2625 0058 01        		.byte	1
 2626 0059 01        		.byte	1
 2627 005a 01        		.byte	1
 2628 005b 00        		.byte	0
 2629 005c 00        		.byte	0
 2630 005d 00        		.byte	0
 2631 005e 01        		.byte	1
 2632 005f 01        		.byte	1
 2633 0060 00        		.byte	0
 2634 0061 00        		.byte	0
 2635 0062 00        		.byte	0
 2636 0063 00        		.byte	0
 2637 0064 00        		.byte	0
 2638 0065 00        		.byte	0
 2639 0066 00        		.byte	0
 2640 0067 00        		.byte	0
 2641 0068 00        		.byte	0
 2642 0069 00        		.byte	0
 2643 006a 00        		.byte	0
 2644 006b 00        		.byte	0
 2645 006c 00        		.byte	0
 2646 006d 00        		.byte	0
 2647 006e 00        		.byte	0
 2648 006f 00        		.byte	0
 2649 0070 00        		.byte	0
 2650 0071 00        		.byte	0
 2651 0072 00        		.byte	0
 2652 0073 00        		.byte	0
 2653 0074 00        		.byte	0
 2654 0075 00        		.byte	0
 2655 0076 00        		.byte	0
 2656 0077 00        		.byte	0
 2657 0078 00        		.byte	0
 2658 0079 00        		.byte	0
 2659 007a 00        		.byte	0
 2660 007b 01        		.byte	1
 2661 007c 01        		.byte	1
 2662 007d 01        		.byte	1
 2663 007e 01        		.byte	1
 2664 007f 00        		.byte	0
 2665               		.section	.bss.grave_esc_was_shifted,"aw",@nobits
 2668               	grave_esc_was_shifted:
 2669 0000 00        		.zero	1
 2670               		.section	.bss.scs_timer,"aw",@nobits
 2673               	scs_timer:
 2674 0000 0000 0000 		.zero	4
 2675               		.section	.bss.shift_interrupted,"aw",@nobits
 2678               	shift_interrupted:
 2679 0000 0000      		.zero	2
 2680               		.text
 2681               	.Letext0:
 2682               		.file 5 "c:\\msys32\\home\\683654\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
 2683               		.file 6 "./tmk_core/common/keyboard.h"
 2684               		.file 7 "./tmk_core/common/action.h"
 2685               		.file 8 "./tmk_core/common/report.h"
 2686               		.file 9 "./tmk_core/common/debug.h"
 2687               		.file 10 "quantum/keycode_config.h"
 2688               		.file 11 "./tmk_core/common/keycode.h"
 2689               		.file 12 "quantum/quantum_keycodes.h"
 2690               		.file 13 "./tmk_core/protocol/lufa/outputselect.h"
 2691               		.file 14 "quantum/quantum.h"
 2692               		.file 15 "./tmk_core/common/bootloader.h"
 2693               		.file 16 "./tmk_core/common/action_layer.h"
 2694               		.file 17 "quantum/keymap.h"
 2695               		.file 18 "./quantum/process_keycode/process_tap_dance.h"
 2696               		.file 19 "./quantum/process_keycode/process_leader.h"
 2697               		.file 20 "./tmk_core/common/avr/xprintf.h"
 2698               		.file 21 "./tmk_core/common/eeconfig.h"
 2699               		.file 22 "./tmk_core/common/timer.h"
DEFINED SYMBOLS
                            *ABS*:00000000 quantum.c
C:\msys32\tmp\cclJ7lNk.s:2      *ABS*:0000003e __SP_H__
C:\msys32\tmp\cclJ7lNk.s:3      *ABS*:0000003d __SP_L__
C:\msys32\tmp\cclJ7lNk.s:4      *ABS*:0000003f __SREG__
C:\msys32\tmp\cclJ7lNk.s:5      *ABS*:00000000 __tmp_reg__
C:\msys32\tmp\cclJ7lNk.s:6      *ABS*:00000001 __zero_reg__
C:\msys32\tmp\cclJ7lNk.s:12     .text.do_code16:00000000 do_code16
C:\msys32\tmp\cclJ7lNk.s:129    .text.qk_register_weak_mods:00000000 qk_register_weak_mods
C:\msys32\tmp\cclJ7lNk.s:159    .text.qk_register_mods:00000000 qk_register_mods
C:\msys32\tmp\cclJ7lNk.s:189    .text.qk_unregister_weak_mods:00000000 qk_unregister_weak_mods
C:\msys32\tmp\cclJ7lNk.s:219    .text.qk_unregister_mods:00000000 qk_unregister_mods
C:\msys32\tmp\cclJ7lNk.s:250    .text.rgblight_toggle:00000000 rgblight_toggle
C:\msys32\tmp\cclJ7lNk.s:266    .text.rgblight_step:00000000 rgblight_step
C:\msys32\tmp\cclJ7lNk.s:281    .text.rgblight_step_reverse:00000000 rgblight_step_reverse
C:\msys32\tmp\cclJ7lNk.s:296    .text.rgblight_increase_hue:00000000 rgblight_increase_hue
C:\msys32\tmp\cclJ7lNk.s:311    .text.rgblight_decrease_hue:00000000 rgblight_decrease_hue
C:\msys32\tmp\cclJ7lNk.s:326    .text.rgblight_increase_sat:00000000 rgblight_increase_sat
C:\msys32\tmp\cclJ7lNk.s:341    .text.rgblight_decrease_sat:00000000 rgblight_decrease_sat
C:\msys32\tmp\cclJ7lNk.s:356    .text.rgblight_increase_val:00000000 rgblight_increase_val
C:\msys32\tmp\cclJ7lNk.s:371    .text.rgblight_decrease_val:00000000 rgblight_decrease_val
C:\msys32\tmp\cclJ7lNk.s:386    .text.rgblight_increase_speed:00000000 rgblight_increase_speed
C:\msys32\tmp\cclJ7lNk.s:401    .text.rgblight_decrease_speed:00000000 rgblight_decrease_speed
C:\msys32\tmp\cclJ7lNk.s:416    .text.register_code16:00000000 register_code16
C:\msys32\tmp\cclJ7lNk.s:473    .text.unregister_code16:00000000 unregister_code16
C:\msys32\tmp\cclJ7lNk.s:528    .text.process_action_kb:00000000 process_action_kb
C:\msys32\tmp\cclJ7lNk.s:547    .text.process_record_user:00000000 process_record_user
C:\msys32\tmp\cclJ7lNk.s:566    .text.process_record_kb:00000000 process_record_kb
C:\msys32\tmp\cclJ7lNk.s:584    .text.reset_keyboard:00000000 reset_keyboard
C:\msys32\tmp\cclJ7lNk.s:624    .text.process_record_quantum:00000000 process_record_quantum
C:\msys32\tmp\cclJ7lNk.s:2668   .bss.grave_esc_was_shifted:00000000 grave_esc_was_shifted
C:\msys32\tmp\cclJ7lNk.s:2391   .progmem.data.__c.3295:00000000 __c.3295
C:\msys32\tmp\cclJ7lNk.s:2678   .bss.shift_interrupted:00000000 shift_interrupted
C:\msys32\tmp\cclJ7lNk.s:2673   .bss.scs_timer:00000000 scs_timer
C:\msys32\tmp\cclJ7lNk.s:1174   .text.send_char:00000000 send_char
C:\msys32\tmp\cclJ7lNk.s:2403   .progmem.data.ascii_to_keycode_lut:00000000 ascii_to_keycode_lut
C:\msys32\tmp\cclJ7lNk.s:2536   .progmem.data.ascii_to_shift_lut:00000000 ascii_to_shift_lut
C:\msys32\tmp\cclJ7lNk.s:1260   .text.send_string_with_delay:00000000 send_string_with_delay
C:\msys32\tmp\cclJ7lNk.s:1404   .text.send_string:00000000 send_string
C:\msys32\tmp\cclJ7lNk.s:1423   .text.send_string_with_delay_P:00000000 send_string_with_delay_P
C:\msys32\tmp\cclJ7lNk.s:1599   .text.send_string_P:00000000 send_string_P
C:\msys32\tmp\cclJ7lNk.s:1618   .text.set_single_persistent_default_layer:00000000 set_single_persistent_default_layer
C:\msys32\tmp\cclJ7lNk.s:1667   .text.update_tri_layer_state:00000000 update_tri_layer_state
C:\msys32\tmp\cclJ7lNk.s:1819   .text.update_tri_layer:00000000 update_tri_layer
C:\msys32\tmp\cclJ7lNk.s:1858   .text.tap_random_base64:00000000 tap_random_base64
C:\msys32\tmp\cclJ7lNk.s:1985   .text.matrix_init_quantum:00000000 matrix_init_quantum
C:\msys32\tmp\cclJ7lNk.s:2002   .text.matrix_scan_quantum:00000000 matrix_scan_quantum
C:\msys32\tmp\cclJ7lNk.s:2022   .text.backlight_init_ports:00000000 backlight_init_ports
C:\msys32\tmp\cclJ7lNk.s:2037   .text.backlight_set:00000000 backlight_set
C:\msys32\tmp\cclJ7lNk.s:2053   .text.send_nibble:00000000 send_nibble
C:\msys32\tmp\cclJ7lNk.s:2118   .text.send_byte:00000000 send_byte
C:\msys32\tmp\cclJ7lNk.s:2155   .text.send_word:00000000 send_word
C:\msys32\tmp\cclJ7lNk.s:2189   .text.send_dword:00000000 send_dword
C:\msys32\tmp\cclJ7lNk.s:2239   .text.hex_to_keycode:00000000 hex_to_keycode
C:\msys32\tmp\cclJ7lNk.s:2278   .text.api_send_unicode:00000000 api_send_unicode
C:\msys32\tmp\cclJ7lNk.s:2294   .text.led_set_user:00000000 led_set_user
C:\msys32\tmp\cclJ7lNk.s:2310   .text.led_set_kb:00000000 led_set_kb
C:\msys32\tmp\cclJ7lNk.s:2328   .text.led_init_ports:00000000 led_init_ports
C:\msys32\tmp\cclJ7lNk.s:2343   .text.led_set:00000000 led_set
C:\msys32\tmp\cclJ7lNk.s:2361   .text.startup_user:00000000 startup_user
C:\msys32\tmp\cclJ7lNk.s:2376   .text.shutdown_user:00000000 shutdown_user
C:\msys32\tmp\cclJ7lNk.s:2397   .bss.rgb_matrix_task_counter:00000000 rgb_matrix_task_counter

UNDEFINED SYMBOLS
add_weak_mods
send_keyboard_report
del_weak_mods
register_code
unregister_code
clear_keyboard
bootloader_jump
layer_switch_get_layer
keymap_key_to_keycode
preprocess_tap_dance
process_tap_dance
process_leader
get_mods
keyboard_report
add_key_to_report
del_key_from_report
debug_config
xputs
eeconfig_is_enabled
eeconfig_init
eeconfig_read_keymap
keymap_config
__tablejump2__
eeconfig_update_keymap
timer_read
register_mods
unregister_mods
timer_elapsed
set_output
eeconfig_update_default_layer
default_layer_set
layer_state
layer_state_set
matrix_init_kb
matrix_scan_tap_dance
matrix_scan_kb
__do_clear_bss
