   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.serial_output,"ax",@progbits
  12               	serial_output:
  13               	.LFB7:
  14               		.file 1 "keyboards/Manuform6x6/serial.c"
   1:keyboards/Manuform6x6/serial.c **** /*
   2:keyboards/Manuform6x6/serial.c ****  * WARNING: be careful changing this code, it is very timing dependent
   3:keyboards/Manuform6x6/serial.c ****  */
   4:keyboards/Manuform6x6/serial.c **** 
   5:keyboards/Manuform6x6/serial.c **** #ifndef F_CPU
   6:keyboards/Manuform6x6/serial.c **** #define F_CPU 16000000
   7:keyboards/Manuform6x6/serial.c **** #endif
   8:keyboards/Manuform6x6/serial.c **** 
   9:keyboards/Manuform6x6/serial.c **** #include <avr/io.h>
  10:keyboards/Manuform6x6/serial.c **** #include <avr/interrupt.h>
  11:keyboards/Manuform6x6/serial.c **** #include <util/delay.h>
  12:keyboards/Manuform6x6/serial.c **** #include <stdbool.h>
  13:keyboards/Manuform6x6/serial.c **** #include "serial.h"
  14:keyboards/Manuform6x6/serial.c **** 
  15:keyboards/Manuform6x6/serial.c **** #ifndef USE_I2C
  16:keyboards/Manuform6x6/serial.c **** 
  17:keyboards/Manuform6x6/serial.c **** // Serial pulse period in microseconds. Its probably a bad idea to lower this
  18:keyboards/Manuform6x6/serial.c **** // value.
  19:keyboards/Manuform6x6/serial.c **** #define SERIAL_DELAY 24
  20:keyboards/Manuform6x6/serial.c **** 
  21:keyboards/Manuform6x6/serial.c **** uint8_t volatile serial_slave_buffer[SERIAL_SLAVE_BUFFER_LENGTH] = {0};
  22:keyboards/Manuform6x6/serial.c **** uint8_t volatile serial_master_buffer[SERIAL_MASTER_BUFFER_LENGTH] = {0};
  23:keyboards/Manuform6x6/serial.c **** 
  24:keyboards/Manuform6x6/serial.c **** #define SLAVE_DATA_CORRUPT (1<<0)
  25:keyboards/Manuform6x6/serial.c **** volatile uint8_t status = 0;
  26:keyboards/Manuform6x6/serial.c **** 
  27:keyboards/Manuform6x6/serial.c **** inline static
  28:keyboards/Manuform6x6/serial.c **** void serial_delay(void) {
  29:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY);
  30:keyboards/Manuform6x6/serial.c **** }
  31:keyboards/Manuform6x6/serial.c **** 
  32:keyboards/Manuform6x6/serial.c **** inline static
  33:keyboards/Manuform6x6/serial.c **** void serial_output(void) {
  15               		.loc 1 33 26 view -0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  34:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_DDR |= SERIAL_PIN_MASK;
  21               		.loc 1 34 3 view .LVU1
  22               		.loc 1 34 18 is_stmt 0 view .LVU2
  23 0000 509A      		sbi 0xa,0
  24               	/* epilogue start */
  35:keyboards/Manuform6x6/serial.c **** }
  25               		.loc 1 35 1 view .LVU3
  26 0002 0895      		ret
  27               		.cfi_endproc
  28               	.LFE7:
  30               		.section	.text.serial_input,"ax",@progbits
  32               	serial_input:
  33               	.LFB8:
  36:keyboards/Manuform6x6/serial.c **** 
  37:keyboards/Manuform6x6/serial.c **** // make the serial pin an input with pull-up resistor
  38:keyboards/Manuform6x6/serial.c **** inline static
  39:keyboards/Manuform6x6/serial.c **** void serial_input(void) {
  34               		.loc 1 39 25 is_stmt 1 view -0
  35               		.cfi_startproc
  36               	/* prologue: function */
  37               	/* frame size = 0 */
  38               	/* stack size = 0 */
  39               	.L__stack_usage = 0
  40:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_DDR  &= ~SERIAL_PIN_MASK;
  40               		.loc 1 40 3 view .LVU5
  41               		.loc 1 40 19 is_stmt 0 view .LVU6
  42 0000 5098      		cbi 0xa,0
  41:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
  43               		.loc 1 41 3 is_stmt 1 view .LVU7
  44               		.loc 1 41 19 is_stmt 0 view .LVU8
  45 0002 589A      		sbi 0xb,0
  46               	/* epilogue start */
  42:keyboards/Manuform6x6/serial.c **** }
  47               		.loc 1 42 1 view .LVU9
  48 0004 0895      		ret
  49               		.cfi_endproc
  50               	.LFE8:
  52               		.section	.text.serial_high,"ax",@progbits
  54               	serial_high:
  55               	.LFB11:
  43:keyboards/Manuform6x6/serial.c **** 
  44:keyboards/Manuform6x6/serial.c **** inline static
  45:keyboards/Manuform6x6/serial.c **** uint8_t serial_read_pin(void) {
  46:keyboards/Manuform6x6/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
  47:keyboards/Manuform6x6/serial.c **** }
  48:keyboards/Manuform6x6/serial.c **** 
  49:keyboards/Manuform6x6/serial.c **** inline static
  50:keyboards/Manuform6x6/serial.c **** void serial_low(void) {
  51:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
  52:keyboards/Manuform6x6/serial.c **** }
  53:keyboards/Manuform6x6/serial.c **** 
  54:keyboards/Manuform6x6/serial.c **** inline static
  55:keyboards/Manuform6x6/serial.c **** void serial_high(void) {
  56               		.loc 1 55 24 is_stmt 1 view -0
  57               		.cfi_startproc
  58               	/* prologue: function */
  59               	/* frame size = 0 */
  60               	/* stack size = 0 */
  61               	.L__stack_usage = 0
  56:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
  62               		.loc 1 56 3 view .LVU11
  63               		.loc 1 56 19 is_stmt 0 view .LVU12
  64 0000 589A      		sbi 0xb,0
  65               	/* epilogue start */
  57:keyboards/Manuform6x6/serial.c **** }
  66               		.loc 1 57 1 view .LVU13
  67 0002 0895      		ret
  68               		.cfi_endproc
  69               	.LFE11:
  71               		.section	.text.sync_recv,"ax",@progbits
  73               	sync_recv:
  74               	.LFB14:
  58:keyboards/Manuform6x6/serial.c **** 
  59:keyboards/Manuform6x6/serial.c **** void serial_master_init(void) {
  60:keyboards/Manuform6x6/serial.c ****   serial_output();
  61:keyboards/Manuform6x6/serial.c ****   serial_high();
  62:keyboards/Manuform6x6/serial.c **** }
  63:keyboards/Manuform6x6/serial.c **** 
  64:keyboards/Manuform6x6/serial.c **** void serial_slave_init(void) {
  65:keyboards/Manuform6x6/serial.c ****   serial_input();
  66:keyboards/Manuform6x6/serial.c **** 
  67:keyboards/Manuform6x6/serial.c ****   // Enable INT0
  68:keyboards/Manuform6x6/serial.c ****   EIMSK |= _BV(INT0);
  69:keyboards/Manuform6x6/serial.c ****   // Trigger on falling edge of INT0
  70:keyboards/Manuform6x6/serial.c ****   EICRA &= ~(_BV(ISC00) | _BV(ISC01));
  71:keyboards/Manuform6x6/serial.c **** }
  72:keyboards/Manuform6x6/serial.c **** 
  73:keyboards/Manuform6x6/serial.c **** // Used by the master to synchronize timing with the slave.
  74:keyboards/Manuform6x6/serial.c **** static
  75:keyboards/Manuform6x6/serial.c **** void sync_recv(void) {
  75               		.loc 1 75 22 is_stmt 1 view -0
  76               		.cfi_startproc
  77               	/* prologue: function */
  78               	/* frame size = 0 */
  79               	/* stack size = 0 */
  80               	.L__stack_usage = 0
  76:keyboards/Manuform6x6/serial.c ****   serial_input();
  81               		.loc 1 76 3 view .LVU15
  82 0000 0E94 0000 		call serial_input
  83               	.LVL0:
  77:keyboards/Manuform6x6/serial.c ****   // This shouldn't hang if the slave disconnects because the
  78:keyboards/Manuform6x6/serial.c ****   // serial line will float to high if the slave does disconnect.
  79:keyboards/Manuform6x6/serial.c ****   while (!serial_read_pin());
  84               		.loc 1 79 3 view .LVU16
  85               	.L5:
  86               		.loc 1 79 29 discriminator 1 view .LVU17
  87               	.LBB49:
  88               	.LBI49:
  45:keyboards/Manuform6x6/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
  89               		.loc 1 45 9 discriminator 1 view .LVU18
  90               	.LBB50:
  46:keyboards/Manuform6x6/serial.c **** }
  91               		.loc 1 46 3 discriminator 1 view .LVU19
  92               	.LBE50:
  93               	.LBE49:
  94               		.loc 1 79 9 is_stmt 0 discriminator 1 view .LVU20
  95 0004 489B      		sbis 0x9,0
  96 0006 00C0      		rjmp .L5
  80:keyboards/Manuform6x6/serial.c ****   serial_delay();
  97               		.loc 1 80 3 is_stmt 1 view .LVU21
  98               	.LBB51:
  99               	.LBI51:
  28:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY);
 100               		.loc 1 28 6 view .LVU22
 101               	.LBE51:
  29:keyboards/Manuform6x6/serial.c **** }
 102               		.loc 1 29 3 view .LVU23
 103               	.LVL1:
 104               	.LBB54:
 105               	.LBB52:
 106               	.LBI52:
 107               		.file 2 "/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** _delay_us(double __us)
 108               		.loc 2 255 1 view .LVU24
 109               	.LBB53:
 256:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	double __tmp ;
 110               		.loc 2 257 2 view .LVU25
 258:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 111               		.loc 2 261 2 view .LVU26
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 112               		.loc 2 262 2 view .LVU27
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 113               		.loc 2 263 2 view .LVU28
 264:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 114               		.loc 2 273 3 view .LVU29
 274:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 115               		.loc 2 276 2 view .LVU30
 116 0008 80E8      		ldi r24,lo8(-128)
 117 000a 8A95      	1:	dec r24
 118 000c 01F4      		brne 1b
 119               	.LVL2:
 120               	/* epilogue start */
 121               		.loc 2 276 2 is_stmt 0 view .LVU31
 122               	.LBE53:
 123               	.LBE52:
 124               	.LBE54:
  81:keyboards/Manuform6x6/serial.c **** }
 125               		.loc 1 81 1 view .LVU32
 126 000e 0895      		ret
 127               		.cfi_endproc
 128               	.LFE14:
 130               		.section	.text.serial_read_byte,"ax",@progbits
 132               	serial_read_byte:
 133               	.LFB16:
  82:keyboards/Manuform6x6/serial.c **** 
  83:keyboards/Manuform6x6/serial.c **** // Used by the slave to send a synchronization signal to the master.
  84:keyboards/Manuform6x6/serial.c **** static
  85:keyboards/Manuform6x6/serial.c **** void sync_send(void) {
  86:keyboards/Manuform6x6/serial.c ****   serial_output();
  87:keyboards/Manuform6x6/serial.c **** 
  88:keyboards/Manuform6x6/serial.c ****   serial_low();
  89:keyboards/Manuform6x6/serial.c ****   serial_delay();
  90:keyboards/Manuform6x6/serial.c **** 
  91:keyboards/Manuform6x6/serial.c ****   serial_high();
  92:keyboards/Manuform6x6/serial.c **** }
  93:keyboards/Manuform6x6/serial.c **** 
  94:keyboards/Manuform6x6/serial.c **** // Reads a byte from the serial line
  95:keyboards/Manuform6x6/serial.c **** static
  96:keyboards/Manuform6x6/serial.c **** uint8_t serial_read_byte(void) {
 134               		.loc 1 96 32 is_stmt 1 view -0
 135               		.cfi_startproc
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
  97:keyboards/Manuform6x6/serial.c ****   uint8_t byte = 0;
 140               		.loc 1 97 3 view .LVU34
 141               	.LVL3:
  98:keyboards/Manuform6x6/serial.c ****   serial_input();
 142               		.loc 1 98 3 view .LVU35
 143 0000 0E94 0000 		call serial_input
 144               	.LVL4:
  99:keyboards/Manuform6x6/serial.c ****   for ( uint8_t i = 0; i < 8; ++i) {
 145               		.loc 1 99 3 view .LVU36
 146               	.LBB63:
 147               		.loc 1 99 9 view .LVU37
 148               		.loc 1 99 9 is_stmt 0 view .LVU38
 149               	.LBE63:
  98:keyboards/Manuform6x6/serial.c ****   serial_input();
 150               		.loc 1 98 3 view .LVU39
 151 0004 98E0      		ldi r25,lo8(8)
  97:keyboards/Manuform6x6/serial.c ****   uint8_t byte = 0;
 152               		.loc 1 97 11 view .LVU40
 153 0006 80E0      		ldi r24,0
 154               	.LVL5:
 155               	.L9:
 156               	.LBB72:
 100:keyboards/Manuform6x6/serial.c ****     byte = (byte << 1) | serial_read_pin();
 157               		.loc 1 100 5 is_stmt 1 discriminator 3 view .LVU41
 158               	.LBB64:
 159               	.LBI64:
  45:keyboards/Manuform6x6/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
 160               		.loc 1 45 9 discriminator 3 view .LVU42
 161               	.LBB65:
  46:keyboards/Manuform6x6/serial.c **** }
 162               		.loc 1 46 3 discriminator 3 view .LVU43
  46:keyboards/Manuform6x6/serial.c **** }
 163               		.loc 1 46 13 is_stmt 0 discriminator 3 view .LVU44
 164 0008 29B1      		in r18,0x9
 165               	.LBE65:
 166               	.LBE64:
 167               		.loc 1 100 18 discriminator 3 view .LVU45
 168 000a 880F      		lsl r24
 169               	.LVL6:
 170               		.loc 1 100 26 discriminator 3 view .LVU46
 171 000c 2170      		andi r18,lo8(1)
 172               		.loc 1 100 24 discriminator 3 view .LVU47
 173 000e 822B      		or r24,r18
 174               	.LVL7:
 101:keyboards/Manuform6x6/serial.c ****     serial_delay();
 175               		.loc 1 101 5 is_stmt 1 discriminator 3 view .LVU48
 176               	.LBB66:
 177               	.LBI66:
  28:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY);
 178               		.loc 1 28 6 discriminator 3 view .LVU49
 179               	.LBE66:
 180               	.LBE72:
  29:keyboards/Manuform6x6/serial.c **** }
 181               		.loc 1 29 3 discriminator 3 view .LVU50
 182               	.LBB73:
 183               	.LBB69:
 184               	.LBB67:
 185               	.LBI67:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 186               		.loc 2 255 1 discriminator 3 view .LVU51
 187               	.LBB68:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 188               		.loc 2 257 2 discriminator 3 view .LVU52
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 189               		.loc 2 261 2 discriminator 3 view .LVU53
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 190               		.loc 2 262 2 discriminator 3 view .LVU54
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 191               		.loc 2 263 2 discriminator 3 view .LVU55
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 192               		.loc 2 273 3 discriminator 3 view .LVU56
 193               		.loc 2 276 2 discriminator 3 view .LVU57
 194 0010 20E8      		ldi r18,lo8(-128)
 195 0012 2A95      	1:	dec r18
 196 0014 01F4      		brne 1b
 197               	.LVL8:
 198               		.loc 2 276 2 is_stmt 0 discriminator 3 view .LVU58
 199               	.LBE68:
 200               	.LBE67:
 201               	.LBE69:
 102:keyboards/Manuform6x6/serial.c ****     _delay_us(1);
 202               		.loc 1 102 5 is_stmt 1 discriminator 3 view .LVU59
 203               	.LBB70:
 204               	.LBI70:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 205               		.loc 2 255 1 discriminator 3 view .LVU60
 206               	.LBB71:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 207               		.loc 2 257 2 discriminator 3 view .LVU61
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 208               		.loc 2 261 2 discriminator 3 view .LVU62
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 209               		.loc 2 262 2 discriminator 3 view .LVU63
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 210               		.loc 2 263 2 discriminator 3 view .LVU64
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 211               		.loc 2 273 3 discriminator 3 view .LVU65
 212               		.loc 2 276 2 discriminator 3 view .LVU66
 213 0016 25E0      		ldi r18,lo8(5)
 214 0018 2A95      	1:	dec r18
 215 001a 01F4      		brne 1b
 216 001c 0000      		nop
 217               	.LVL9:
 218               		.loc 2 276 2 is_stmt 0 discriminator 3 view .LVU67
 219 001e 9150      		subi r25,lo8(-(-1))
 220               	.LVL10:
 221               		.loc 2 276 2 discriminator 3 view .LVU68
 222               	.LBE71:
 223               	.LBE70:
  99:keyboards/Manuform6x6/serial.c ****     byte = (byte << 1) | serial_read_pin();
 224               		.loc 1 99 3 discriminator 3 view .LVU69
 225 0020 01F4      		brne .L9
 226               	/* epilogue start */
 227               	.LBE73:
 103:keyboards/Manuform6x6/serial.c ****   }
 104:keyboards/Manuform6x6/serial.c **** 
 105:keyboards/Manuform6x6/serial.c ****   return byte;
 106:keyboards/Manuform6x6/serial.c **** }
 228               		.loc 1 106 1 view .LVU70
 229 0022 0895      		ret
 230               		.cfi_endproc
 231               	.LFE16:
 233               		.section	.text.serial_write_byte,"ax",@progbits
 235               	serial_write_byte:
 236               	.LVL11:
 237               	.LFB17:
 107:keyboards/Manuform6x6/serial.c **** 
 108:keyboards/Manuform6x6/serial.c **** // Sends a byte with MSB ordering
 109:keyboards/Manuform6x6/serial.c **** static
 110:keyboards/Manuform6x6/serial.c **** void serial_write_byte(uint8_t data) {
 238               		.loc 1 110 38 is_stmt 1 view -0
 239               		.cfi_startproc
 240               		.loc 1 110 38 is_stmt 0 view .LVU72
 241 0000 0F93      		push r16
 242               	.LCFI0:
 243               		.cfi_def_cfa_offset 3
 244               		.cfi_offset 16, -2
 245 0002 1F93      		push r17
 246               	.LCFI1:
 247               		.cfi_def_cfa_offset 4
 248               		.cfi_offset 17, -3
 249 0004 CF93      		push r28
 250               	.LCFI2:
 251               		.cfi_def_cfa_offset 5
 252               		.cfi_offset 28, -4
 253               	/* prologue: function */
 254               	/* frame size = 0 */
 255               	/* stack size = 3 */
 256               	.L__stack_usage = 3
 257 0006 082F      		mov r16,r24
 111:keyboards/Manuform6x6/serial.c ****   uint8_t b = 8;
 258               		.loc 1 111 3 is_stmt 1 view .LVU73
 259               	.LVL12:
 112:keyboards/Manuform6x6/serial.c ****   serial_output();
 260               		.loc 1 112 3 view .LVU74
 261 0008 0E94 0000 		call serial_output
 262               	.LVL13:
 113:keyboards/Manuform6x6/serial.c ****   while( b-- ) {
 263               		.loc 1 113 3 view .LVU75
 111:keyboards/Manuform6x6/serial.c ****   uint8_t b = 8;
 264               		.loc 1 111 11 is_stmt 0 view .LVU76
 265 000c C8E0      		ldi r28,lo8(8)
 114:keyboards/Manuform6x6/serial.c ****     if(data & (1 << b)) {
 266               		.loc 1 114 8 view .LVU77
 267 000e 10E0      		ldi r17,0
 268               	.LVL14:
 269               	.L12:
 113:keyboards/Manuform6x6/serial.c ****   while( b-- ) {
 270               		.loc 1 113 11 view .LVU78
 271               	.LVL15:
 272 0010 C150      		subi r28,1
 273 0012 00F4      		brcc .L15
 274               	/* epilogue start */
 115:keyboards/Manuform6x6/serial.c ****       serial_high();
 116:keyboards/Manuform6x6/serial.c ****     } else {
 117:keyboards/Manuform6x6/serial.c ****       serial_low();
 118:keyboards/Manuform6x6/serial.c ****     }
 119:keyboards/Manuform6x6/serial.c ****     serial_delay();
 120:keyboards/Manuform6x6/serial.c ****   }
 121:keyboards/Manuform6x6/serial.c **** }
 275               		.loc 1 121 1 view .LVU79
 276 0014 CF91      		pop r28
 277               	.LVL16:
 278               		.loc 1 121 1 view .LVU80
 279 0016 1F91      		pop r17
 280 0018 0F91      		pop r16
 281               	.LVL17:
 282               		.loc 1 121 1 view .LVU81
 283 001a 0895      		ret
 284               	.LVL18:
 285               	.L15:
 114:keyboards/Manuform6x6/serial.c ****     if(data & (1 << b)) {
 286               		.loc 1 114 5 is_stmt 1 view .LVU82
 114:keyboards/Manuform6x6/serial.c ****     if(data & (1 << b)) {
 287               		.loc 1 114 8 is_stmt 0 view .LVU83
 288 001c C801      		movw r24,r16
 289 001e 0C2E      		mov r0,r28
 290 0020 00C0      		rjmp 2f
 291               		1:
 292 0022 9595      		asr r25
 293 0024 8795      		ror r24
 294               		2:
 295 0026 0A94      		dec r0
 296 0028 02F4      		brpl 1b
 114:keyboards/Manuform6x6/serial.c ****     if(data & (1 << b)) {
 297               		.loc 1 114 7 view .LVU84
 298 002a 80FF      		sbrs r24,0
 299 002c 00C0      		rjmp .L13
 115:keyboards/Manuform6x6/serial.c ****       serial_high();
 300               		.loc 1 115 7 is_stmt 1 view .LVU85
 301 002e 0E94 0000 		call serial_high
 302               	.LVL19:
 303               	.L14:
 119:keyboards/Manuform6x6/serial.c ****   }
 304               		.loc 1 119 5 view .LVU86
 305               	.LBB79:
 306               	.LBI79:
  28:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY);
 307               		.loc 1 28 6 view .LVU87
 308               	.LBE79:
  29:keyboards/Manuform6x6/serial.c **** }
 309               		.loc 1 29 3 view .LVU88
 310               	.LBB82:
 311               	.LBB80:
 312               	.LBI80:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 313               		.loc 2 255 1 view .LVU89
 314               	.LBB81:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 315               		.loc 2 257 2 view .LVU90
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 316               		.loc 2 261 2 view .LVU91
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 317               		.loc 2 262 2 view .LVU92
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 318               		.loc 2 263 2 view .LVU93
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 319               		.loc 2 273 3 view .LVU94
 320               		.loc 2 276 2 view .LVU95
 321 0032 80E8      		ldi r24,lo8(-128)
 322 0034 8A95      	1:	dec r24
 323 0036 01F4      		brne 1b
 324               	.LVL20:
 325               		.loc 2 276 2 is_stmt 0 view .LVU96
 326 0038 00C0      		rjmp .L12
 327               	.L13:
 328               		.loc 2 276 2 view .LVU97
 329               	.LBE81:
 330               	.LBE80:
 331               	.LBE82:
 117:keyboards/Manuform6x6/serial.c ****     }
 332               		.loc 1 117 7 is_stmt 1 view .LVU98
 333               	.LBB83:
 334               	.LBI83:
  50:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
 335               		.loc 1 50 6 view .LVU99
 336               	.LBB84:
  51:keyboards/Manuform6x6/serial.c **** }
 337               		.loc 1 51 3 view .LVU100
  51:keyboards/Manuform6x6/serial.c **** }
 338               		.loc 1 51 19 is_stmt 0 view .LVU101
 339 003a 5898      		cbi 0xb,0
 340 003c 00C0      		rjmp .L14
 341               	.LBE84:
 342               	.LBE83:
 343               		.cfi_endproc
 344               	.LFE17:
 346               		.section	.text.sync_send,"ax",@progbits
 348               	sync_send:
 349               	.LFB15:
  85:keyboards/Manuform6x6/serial.c ****   serial_output();
 350               		.loc 1 85 22 is_stmt 1 view -0
 351               		.cfi_startproc
 352               	/* prologue: function */
 353               	/* frame size = 0 */
 354               	/* stack size = 0 */
 355               	.L__stack_usage = 0
  86:keyboards/Manuform6x6/serial.c **** 
 356               		.loc 1 86 3 view .LVU103
 357 0000 0E94 0000 		call serial_output
 358               	.LVL21:
  88:keyboards/Manuform6x6/serial.c ****   serial_delay();
 359               		.loc 1 88 3 view .LVU104
 360               	.LBB90:
 361               	.LBI90:
  50:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
 362               		.loc 1 50 6 view .LVU105
 363               	.LBB91:
  51:keyboards/Manuform6x6/serial.c **** }
 364               		.loc 1 51 3 view .LVU106
  51:keyboards/Manuform6x6/serial.c **** }
 365               		.loc 1 51 19 is_stmt 0 view .LVU107
 366 0004 5898      		cbi 0xb,0
 367               	.LBE91:
 368               	.LBE90:
  89:keyboards/Manuform6x6/serial.c **** 
 369               		.loc 1 89 3 is_stmt 1 view .LVU108
 370               	.LBB92:
 371               	.LBI92:
  28:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY);
 372               		.loc 1 28 6 view .LVU109
 373               	.LBE92:
  29:keyboards/Manuform6x6/serial.c **** }
 374               		.loc 1 29 3 view .LVU110
 375               	.LVL22:
 376               	.LBB95:
 377               	.LBB93:
 378               	.LBI93:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 379               		.loc 2 255 1 view .LVU111
 380               	.LBB94:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 381               		.loc 2 257 2 view .LVU112
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 382               		.loc 2 261 2 view .LVU113
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 383               		.loc 2 262 2 view .LVU114
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 384               		.loc 2 263 2 view .LVU115
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 385               		.loc 2 273 3 view .LVU116
 386               		.loc 2 276 2 view .LVU117
 387 0006 80E8      		ldi r24,lo8(-128)
 388 0008 8A95      	1:	dec r24
 389 000a 01F4      		brne 1b
 390               	.LVL23:
 391               		.loc 2 276 2 is_stmt 0 view .LVU118
 392               	.LBE94:
 393               	.LBE93:
 394               	.LBE95:
  91:keyboards/Manuform6x6/serial.c **** }
 395               		.loc 1 91 3 is_stmt 1 view .LVU119
 396 000c 0C94 0000 		jmp serial_high
 397               	.LVL24:
 398               		.cfi_endproc
 399               	.LFE15:
 401               		.section	.text.serial_master_init,"ax",@progbits
 402               	.global	serial_master_init
 404               	serial_master_init:
 405               	.LFB12:
  59:keyboards/Manuform6x6/serial.c ****   serial_output();
 406               		.loc 1 59 31 view -0
 407               		.cfi_startproc
 408               	/* prologue: function */
 409               	/* frame size = 0 */
 410               	/* stack size = 0 */
 411               	.L__stack_usage = 0
  60:keyboards/Manuform6x6/serial.c ****   serial_high();
 412               		.loc 1 60 3 view .LVU121
 413 0000 0E94 0000 		call serial_output
 414               	.LVL25:
  61:keyboards/Manuform6x6/serial.c **** }
 415               		.loc 1 61 3 view .LVU122
 416 0004 0C94 0000 		jmp serial_high
 417               	.LVL26:
 418               		.cfi_endproc
 419               	.LFE12:
 421               		.section	.text.serial_slave_init,"ax",@progbits
 422               	.global	serial_slave_init
 424               	serial_slave_init:
 425               	.LFB13:
  64:keyboards/Manuform6x6/serial.c ****   serial_input();
 426               		.loc 1 64 30 view -0
 427               		.cfi_startproc
 428               	/* prologue: function */
 429               	/* frame size = 0 */
 430               	/* stack size = 0 */
 431               	.L__stack_usage = 0
  65:keyboards/Manuform6x6/serial.c **** 
 432               		.loc 1 65 3 view .LVU124
 433 0000 0E94 0000 		call serial_input
 434               	.LVL27:
  68:keyboards/Manuform6x6/serial.c ****   // Trigger on falling edge of INT0
 435               		.loc 1 68 3 view .LVU125
  68:keyboards/Manuform6x6/serial.c ****   // Trigger on falling edge of INT0
 436               		.loc 1 68 9 is_stmt 0 view .LVU126
 437 0004 E89A      		sbi 0x1d,0
  70:keyboards/Manuform6x6/serial.c **** }
 438               		.loc 1 70 3 is_stmt 1 view .LVU127
  70:keyboards/Manuform6x6/serial.c **** }
 439               		.loc 1 70 9 is_stmt 0 view .LVU128
 440 0006 E9E6      		ldi r30,lo8(105)
 441 0008 F0E0      		ldi r31,0
 442 000a 8081      		ld r24,Z
 443 000c 8C7F      		andi r24,lo8(-4)
 444 000e 8083      		st Z,r24
 445               	/* epilogue start */
  71:keyboards/Manuform6x6/serial.c **** 
 446               		.loc 1 71 1 view .LVU129
 447 0010 0895      		ret
 448               		.cfi_endproc
 449               	.LFE13:
 451               		.section	.text.__vector_1,"ax",@progbits
 452               	.global	__vector_1
 454               	__vector_1:
 455               	.LFB18:
 122:keyboards/Manuform6x6/serial.c **** 
 123:keyboards/Manuform6x6/serial.c **** // interrupt handle to be used by the slave device
 124:keyboards/Manuform6x6/serial.c **** ISR(SERIAL_PIN_INTERRUPT) {
 456               		.loc 1 124 27 is_stmt 1 view -0
 457               		.cfi_startproc
 458 0000 1F92      		push r1
 459               	.LCFI3:
 460               		.cfi_def_cfa_offset 3
 461               		.cfi_offset 1, -2
 462 0002 0F92      		push r0
 463               	.LCFI4:
 464               		.cfi_def_cfa_offset 4
 465               		.cfi_offset 0, -3
 466 0004 0FB6      		in r0,__SREG__
 467 0006 0F92      		push r0
 468 0008 1124      		clr __zero_reg__
 469 000a EF92      		push r14
 470               	.LCFI5:
 471               		.cfi_def_cfa_offset 5
 472               		.cfi_offset 14, -4
 473 000c FF92      		push r15
 474               	.LCFI6:
 475               		.cfi_def_cfa_offset 6
 476               		.cfi_offset 15, -5
 477 000e 1F93      		push r17
 478               	.LCFI7:
 479               		.cfi_def_cfa_offset 7
 480               		.cfi_offset 17, -6
 481 0010 2F93      		push r18
 482               	.LCFI8:
 483               		.cfi_def_cfa_offset 8
 484               		.cfi_offset 18, -7
 485 0012 3F93      		push r19
 486               	.LCFI9:
 487               		.cfi_def_cfa_offset 9
 488               		.cfi_offset 19, -8
 489 0014 4F93      		push r20
 490               	.LCFI10:
 491               		.cfi_def_cfa_offset 10
 492               		.cfi_offset 20, -9
 493 0016 5F93      		push r21
 494               	.LCFI11:
 495               		.cfi_def_cfa_offset 11
 496               		.cfi_offset 21, -10
 497 0018 6F93      		push r22
 498               	.LCFI12:
 499               		.cfi_def_cfa_offset 12
 500               		.cfi_offset 22, -11
 501 001a 7F93      		push r23
 502               	.LCFI13:
 503               		.cfi_def_cfa_offset 13
 504               		.cfi_offset 23, -12
 505 001c 8F93      		push r24
 506               	.LCFI14:
 507               		.cfi_def_cfa_offset 14
 508               		.cfi_offset 24, -13
 509 001e 9F93      		push r25
 510               	.LCFI15:
 511               		.cfi_def_cfa_offset 15
 512               		.cfi_offset 25, -14
 513 0020 AF93      		push r26
 514               	.LCFI16:
 515               		.cfi_def_cfa_offset 16
 516               		.cfi_offset 26, -15
 517 0022 BF93      		push r27
 518               	.LCFI17:
 519               		.cfi_def_cfa_offset 17
 520               		.cfi_offset 27, -16
 521 0024 CF93      		push r28
 522               	.LCFI18:
 523               		.cfi_def_cfa_offset 18
 524               		.cfi_offset 28, -17
 525 0026 DF93      		push r29
 526               	.LCFI19:
 527               		.cfi_def_cfa_offset 19
 528               		.cfi_offset 29, -18
 529 0028 EF93      		push r30
 530               	.LCFI20:
 531               		.cfi_def_cfa_offset 20
 532               		.cfi_offset 30, -19
 533 002a FF93      		push r31
 534               	.LCFI21:
 535               		.cfi_def_cfa_offset 21
 536               		.cfi_offset 31, -20
 537               	/* prologue: Signal */
 538               	/* frame size = 0 */
 539               	/* stack size = 20 */
 540               	.L__stack_usage = 20
 125:keyboards/Manuform6x6/serial.c ****   sync_send();
 541               		.loc 1 125 3 view .LVU131
 542 002c 0E94 0000 		call sync_send
 543               	.LVL28:
 126:keyboards/Manuform6x6/serial.c **** 
 127:keyboards/Manuform6x6/serial.c ****   uint8_t checksum = 0;
 544               		.loc 1 127 3 view .LVU132
 128:keyboards/Manuform6x6/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 545               		.loc 1 128 3 view .LVU133
 546               	.LBB96:
 547               		.loc 1 128 8 view .LVU134
 548               		.loc 1 128 12 is_stmt 0 view .LVU135
 549 0030 D0E0      		ldi r29,0
 550 0032 C0E0      		ldi r28,0
 551               	.LBE96:
 127:keyboards/Manuform6x6/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 552               		.loc 1 127 11 view .LVU136
 553 0034 10E0      		ldi r17,0
 554               	.LVL29:
 555               	.L20:
 556               	.LBB97:
 129:keyboards/Manuform6x6/serial.c ****     serial_write_byte(serial_slave_buffer[i]);
 557               		.loc 1 129 5 is_stmt 1 discriminator 3 view .LVU137
 558 0036 CE01      		movw r24,r28
 559 0038 8050      		subi r24,lo8(-(serial_slave_buffer))
 560 003a 9040      		sbci r25,hi8(-(serial_slave_buffer))
 561 003c 7C01      		movw r14,r24
 562 003e FC01      		movw r30,r24
 563 0040 8081      		ld r24,Z
 564 0042 0E94 0000 		call serial_write_byte
 565               	.LVL30:
 130:keyboards/Manuform6x6/serial.c ****     sync_send();
 566               		.loc 1 130 5 discriminator 3 view .LVU138
 567 0046 0E94 0000 		call sync_send
 568               	.LVL31:
 131:keyboards/Manuform6x6/serial.c ****     checksum += serial_slave_buffer[i];
 569               		.loc 1 131 5 discriminator 3 view .LVU139
 570               		.loc 1 131 36 is_stmt 0 discriminator 3 view .LVU140
 571 004a F701      		movw r30,r14
 572 004c 8081      		ld r24,Z
 573               		.loc 1 131 14 discriminator 3 view .LVU141
 574 004e 180F      		add r17,r24
 575               	.LVL32:
 128:keyboards/Manuform6x6/serial.c ****     serial_write_byte(serial_slave_buffer[i]);
 576               		.loc 1 128 51 discriminator 3 view .LVU142
 577 0050 2196      		adiw r28,1
 578               	.LVL33:
 128:keyboards/Manuform6x6/serial.c ****     serial_write_byte(serial_slave_buffer[i]);
 579               		.loc 1 128 3 discriminator 3 view .LVU143
 580 0052 C730      		cpi r28,7
 581 0054 D105      		cpc r29,__zero_reg__
 582 0056 01F4      		brne .L20
 583               	.LBE97:
 132:keyboards/Manuform6x6/serial.c ****   }
 133:keyboards/Manuform6x6/serial.c ****   serial_write_byte(checksum);
 584               		.loc 1 133 3 is_stmt 1 view .LVU144
 585 0058 812F      		mov r24,r17
 586 005a 0E94 0000 		call serial_write_byte
 587               	.LVL34:
 134:keyboards/Manuform6x6/serial.c ****   sync_send();
 588               		.loc 1 134 3 view .LVU145
 589 005e 0E94 0000 		call sync_send
 590               	.LVL35:
 135:keyboards/Manuform6x6/serial.c **** 
 136:keyboards/Manuform6x6/serial.c ****   // wait for the sync to finish sending
 137:keyboards/Manuform6x6/serial.c ****   serial_delay();
 591               		.loc 1 137 3 view .LVU146
 592               	.LBB98:
 593               	.LBI98:
  28:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY);
 594               		.loc 1 28 6 view .LVU147
 595               	.LBE98:
  29:keyboards/Manuform6x6/serial.c **** }
 596               		.loc 1 29 3 view .LVU148
 597               	.LBB101:
 598               	.LBB99:
 599               	.LBI99:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 600               		.loc 2 255 1 view .LVU149
 601               	.LBB100:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 602               		.loc 2 257 2 view .LVU150
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 603               		.loc 2 261 2 view .LVU151
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 604               		.loc 2 262 2 view .LVU152
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 605               		.loc 2 263 2 view .LVU153
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 606               		.loc 2 273 3 view .LVU154
 607               		.loc 2 276 2 view .LVU155
 608 0062 F0E8      		ldi r31,lo8(-128)
 609 0064 FA95      	1:	dec r31
 610 0066 01F4      		brne 1b
 611               	.LVL36:
 612               		.loc 2 276 2 is_stmt 0 view .LVU156
 613               	.LBE100:
 614               	.LBE99:
 615               	.LBE101:
 138:keyboards/Manuform6x6/serial.c **** 
 139:keyboards/Manuform6x6/serial.c ****   // read the middle of pulses
 140:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY/2);
 616               		.loc 1 140 3 is_stmt 1 view .LVU157
 617               	.LBB102:
 618               	.LBI102:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 619               		.loc 2 255 1 view .LVU158
 620               	.LBB103:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 621               		.loc 2 257 2 view .LVU159
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 622               		.loc 2 261 2 view .LVU160
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 623               		.loc 2 262 2 view .LVU161
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 624               		.loc 2 263 2 view .LVU162
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 625               		.loc 2 273 3 view .LVU163
 626               		.loc 2 276 2 view .LVU164
 627 0068 80E4      		ldi r24,lo8(64)
 628 006a 8A95      	1:	dec r24
 629 006c 01F4      		brne 1b
 630               	.LVL37:
 631               		.loc 2 276 2 is_stmt 0 view .LVU165
 632               	.LBE103:
 633               	.LBE102:
 141:keyboards/Manuform6x6/serial.c **** 
 142:keyboards/Manuform6x6/serial.c ****   uint8_t checksum_computed = 0;
 634               		.loc 1 142 3 is_stmt 1 view .LVU166
 143:keyboards/Manuform6x6/serial.c ****   for (int i = 0; i < SERIAL_MASTER_BUFFER_LENGTH; ++i) {
 635               		.loc 1 143 3 view .LVU167
 636               	.LBB104:
 637               		.loc 1 143 8 view .LVU168
 144:keyboards/Manuform6x6/serial.c ****     serial_master_buffer[i] = serial_read_byte();
 638               		.loc 1 144 5 view .LVU169
 639               		.loc 1 144 31 is_stmt 0 view .LVU170
 640 006e 0E94 0000 		call serial_read_byte
 641               	.LVL38:
 642               		.loc 1 144 29 view .LVU171
 643 0072 8093 0000 		sts serial_master_buffer,r24
 145:keyboards/Manuform6x6/serial.c ****     sync_send();
 644               		.loc 1 145 5 is_stmt 1 view .LVU172
 645 0076 0E94 0000 		call sync_send
 646               	.LVL39:
 146:keyboards/Manuform6x6/serial.c ****     checksum_computed += serial_master_buffer[i];
 647               		.loc 1 146 5 view .LVU173
 648               		.loc 1 146 46 is_stmt 0 view .LVU174
 649 007a D091 0000 		lds r29,serial_master_buffer
 650               	.LVL40:
 651               		.loc 1 146 46 view .LVU175
 652               	.LBE104:
 147:keyboards/Manuform6x6/serial.c ****   }
 148:keyboards/Manuform6x6/serial.c ****   uint8_t checksum_received = serial_read_byte();
 653               		.loc 1 148 3 is_stmt 1 view .LVU176
 654               		.loc 1 148 31 is_stmt 0 view .LVU177
 655 007e 0E94 0000 		call serial_read_byte
 656               	.LVL41:
 657 0082 C82F      		mov r28,r24
 658               	.LVL42:
 149:keyboards/Manuform6x6/serial.c ****   sync_send();
 659               		.loc 1 149 3 is_stmt 1 view .LVU178
 660 0084 0E94 0000 		call sync_send
 661               	.LVL43:
 150:keyboards/Manuform6x6/serial.c **** 
 151:keyboards/Manuform6x6/serial.c ****   serial_input(); // end transaction
 662               		.loc 1 151 3 view .LVU179
 663 0088 0E94 0000 		call serial_input
 664               	.LVL44:
 152:keyboards/Manuform6x6/serial.c **** 
 153:keyboards/Manuform6x6/serial.c ****   if ( checksum_computed != checksum_received ) {
 665               		.loc 1 153 3 view .LVU180
 154:keyboards/Manuform6x6/serial.c ****     status |= SLAVE_DATA_CORRUPT;
 666               		.loc 1 154 12 is_stmt 0 view .LVU181
 667 008c 8091 0000 		lds r24,status
 153:keyboards/Manuform6x6/serial.c ****     status |= SLAVE_DATA_CORRUPT;
 668               		.loc 1 153 6 view .LVU182
 669 0090 DC17      		cp r29,r28
 670 0092 01F0      		breq .L21
 671               		.loc 1 154 5 is_stmt 1 view .LVU183
 672               		.loc 1 154 12 is_stmt 0 view .LVU184
 673 0094 8160      		ori r24,lo8(1)
 674               	.L24:
 155:keyboards/Manuform6x6/serial.c ****   } else {
 156:keyboards/Manuform6x6/serial.c ****     status &= ~SLAVE_DATA_CORRUPT;
 675               		.loc 1 156 12 view .LVU185
 676 0096 8093 0000 		sts status,r24
 677               	/* epilogue start */
 157:keyboards/Manuform6x6/serial.c ****   }
 158:keyboards/Manuform6x6/serial.c **** }
 678               		.loc 1 158 1 view .LVU186
 679 009a FF91      		pop r31
 680 009c EF91      		pop r30
 681 009e DF91      		pop r29
 682               	.LVL45:
 683               		.loc 1 158 1 view .LVU187
 684 00a0 CF91      		pop r28
 685               	.LVL46:
 686               		.loc 1 158 1 view .LVU188
 687 00a2 BF91      		pop r27
 688 00a4 AF91      		pop r26
 689 00a6 9F91      		pop r25
 690 00a8 8F91      		pop r24
 691 00aa 7F91      		pop r23
 692 00ac 6F91      		pop r22
 693 00ae 5F91      		pop r21
 694 00b0 4F91      		pop r20
 695 00b2 3F91      		pop r19
 696 00b4 2F91      		pop r18
 697 00b6 1F91      		pop r17
 698               	.LVL47:
 699               		.loc 1 158 1 view .LVU189
 700 00b8 FF90      		pop r15
 701 00ba EF90      		pop r14
 702               	.LVL48:
 703               		.loc 1 158 1 view .LVU190
 704 00bc 0F90      		pop r0
 705 00be 0FBE      		out __SREG__,r0
 706 00c0 0F90      		pop r0
 707 00c2 1F90      		pop r1
 708 00c4 1895      		reti
 709               	.LVL49:
 710               	.L21:
 156:keyboards/Manuform6x6/serial.c ****   }
 711               		.loc 1 156 5 is_stmt 1 view .LVU191
 156:keyboards/Manuform6x6/serial.c ****   }
 712               		.loc 1 156 12 is_stmt 0 view .LVU192
 713 00c6 8E7F      		andi r24,lo8(-2)
 714 00c8 00C0      		rjmp .L24
 715               		.cfi_endproc
 716               	.LFE18:
 718               		.section	.text.serial_update_buffers,"ax",@progbits
 719               	.global	serial_update_buffers
 721               	serial_update_buffers:
 722               	.LFB20:
 159:keyboards/Manuform6x6/serial.c **** 
 160:keyboards/Manuform6x6/serial.c **** inline
 161:keyboards/Manuform6x6/serial.c **** bool serial_slave_DATA_CORRUPT(void) {
 162:keyboards/Manuform6x6/serial.c ****   return status & SLAVE_DATA_CORRUPT;
 163:keyboards/Manuform6x6/serial.c **** }
 164:keyboards/Manuform6x6/serial.c **** 
 165:keyboards/Manuform6x6/serial.c **** // Copies the serial_slave_buffer to the master and sends the
 166:keyboards/Manuform6x6/serial.c **** // serial_master_buffer to the slave.
 167:keyboards/Manuform6x6/serial.c **** //
 168:keyboards/Manuform6x6/serial.c **** // Returns:
 169:keyboards/Manuform6x6/serial.c **** // 0 => no error
 170:keyboards/Manuform6x6/serial.c **** // 1 => slave did not respond
 171:keyboards/Manuform6x6/serial.c **** int serial_update_buffers(void) {
 723               		.loc 1 171 33 is_stmt 1 view -0
 724               		.cfi_startproc
 725 0000 EF92      		push r14
 726               	.LCFI22:
 727               		.cfi_def_cfa_offset 3
 728               		.cfi_offset 14, -2
 729 0002 FF92      		push r15
 730               	.LCFI23:
 731               		.cfi_def_cfa_offset 4
 732               		.cfi_offset 15, -3
 733 0004 1F93      		push r17
 734               	.LCFI24:
 735               		.cfi_def_cfa_offset 5
 736               		.cfi_offset 17, -4
 737 0006 CF93      		push r28
 738               	.LCFI25:
 739               		.cfi_def_cfa_offset 6
 740               		.cfi_offset 28, -5
 741 0008 DF93      		push r29
 742               	.LCFI26:
 743               		.cfi_def_cfa_offset 7
 744               		.cfi_offset 29, -6
 745               	/* prologue: function */
 746               	/* frame size = 0 */
 747               	/* stack size = 5 */
 748               	.L__stack_usage = 5
 172:keyboards/Manuform6x6/serial.c ****   // this code is very time dependent, so we need to disable interrupts
 173:keyboards/Manuform6x6/serial.c ****   cli();
 749               		.loc 1 173 3 view .LVU194
 750               	/* #APP */
 751               	 ;  173 "keyboards/Manuform6x6/serial.c" 1
 752 000a F894      		cli
 753               	 ;  0 "" 2
 174:keyboards/Manuform6x6/serial.c **** 
 175:keyboards/Manuform6x6/serial.c ****   // signal to the slave that we want to start a transaction
 176:keyboards/Manuform6x6/serial.c ****   serial_output();
 754               		.loc 1 176 3 view .LVU195
 755               	/* #NOAPP */
 756 000c 0E94 0000 		call serial_output
 757               	.LVL50:
 177:keyboards/Manuform6x6/serial.c ****   serial_low();
 758               		.loc 1 177 3 view .LVU196
 759               	.LBB115:
 760               	.LBI115:
  50:keyboards/Manuform6x6/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
 761               		.loc 1 50 6 view .LVU197
 762               	.LBB116:
  51:keyboards/Manuform6x6/serial.c **** }
 763               		.loc 1 51 3 view .LVU198
  51:keyboards/Manuform6x6/serial.c **** }
 764               		.loc 1 51 19 is_stmt 0 view .LVU199
 765 0010 5898      		cbi 0xb,0
 766               	.LBE116:
 767               	.LBE115:
 178:keyboards/Manuform6x6/serial.c ****   _delay_us(1);
 768               		.loc 1 178 3 is_stmt 1 view .LVU200
 769               	.LVL51:
 770               	.LBB117:
 771               	.LBI117:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 772               		.loc 2 255 1 view .LVU201
 773               	.LBB118:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 774               		.loc 2 257 2 view .LVU202
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 775               		.loc 2 261 2 view .LVU203
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 776               		.loc 2 262 2 view .LVU204
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 777               		.loc 2 263 2 view .LVU205
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 778               		.loc 2 273 3 view .LVU206
 779               		.loc 2 276 2 view .LVU207
 780 0012 25E0      		ldi r18,lo8(5)
 781 0014 2A95      	1:	dec r18
 782 0016 01F4      		brne 1b
 783 0018 0000      		nop
 784               	.LVL52:
 785               		.loc 2 276 2 is_stmt 0 view .LVU208
 786               	.LBE118:
 787               	.LBE117:
 179:keyboards/Manuform6x6/serial.c **** 
 180:keyboards/Manuform6x6/serial.c ****   // wait for the slaves response
 181:keyboards/Manuform6x6/serial.c ****   serial_input();
 788               		.loc 1 181 3 is_stmt 1 view .LVU209
 789 001a 0E94 0000 		call serial_input
 790               	.LVL53:
 182:keyboards/Manuform6x6/serial.c ****   serial_high();
 791               		.loc 1 182 3 view .LVU210
 792 001e 0E94 0000 		call serial_high
 793               	.LVL54:
 183:keyboards/Manuform6x6/serial.c ****   _delay_us(SERIAL_DELAY);
 794               		.loc 1 183 3 view .LVU211
 795               	.LBB119:
 796               	.LBI119:
 255:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** {
 797               		.loc 2 255 1 view .LVU212
 798               	.LBB120:
 257:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 799               		.loc 2 257 2 view .LVU213
 261:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 800               		.loc 2 261 2 view .LVU214
 262:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 801               		.loc 2 262 2 view .LVU215
 263:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 
 802               		.loc 2 263 2 view .LVU216
 273:/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/util/delay.h **** 	#endif
 803               		.loc 2 273 3 view .LVU217
 804               		.loc 2 276 2 view .LVU218
 805 0022 30E8      		ldi r19,lo8(-128)
 806 0024 3A95      	1:	dec r19
 807 0026 01F4      		brne 1b
 808               	.LVL55:
 809               		.loc 2 276 2 is_stmt 0 view .LVU219
 810               	.LBE120:
 811               	.LBE119:
 184:keyboards/Manuform6x6/serial.c **** 
 185:keyboards/Manuform6x6/serial.c ****   // check if the slave is present
 186:keyboards/Manuform6x6/serial.c ****   if (serial_read_pin()) {
 812               		.loc 1 186 3 is_stmt 1 view .LVU220
 813               	.LBB121:
 814               	.LBI121:
  45:keyboards/Manuform6x6/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
 815               		.loc 1 45 9 view .LVU221
 816               	.LBB122:
  46:keyboards/Manuform6x6/serial.c **** }
 817               		.loc 1 46 3 view .LVU222
  46:keyboards/Manuform6x6/serial.c **** }
 818               		.loc 1 46 13 is_stmt 0 view .LVU223
 819 0028 89B1      		in r24,0x9
 820               	.LBE122:
 821               	.LBE121:
 822               		.loc 1 186 6 view .LVU224
 823 002a 182F      		mov r17,r24
 824 002c 1170      		andi r17,lo8(1)
 825 002e 80FF      		sbrs r24,0
 826 0030 00C0      		rjmp .L26
 827               	.L31:
 187:keyboards/Manuform6x6/serial.c ****     // slave failed to pull the line low, assume not present
 188:keyboards/Manuform6x6/serial.c ****     sei();
 189:keyboards/Manuform6x6/serial.c ****     return 1;
 190:keyboards/Manuform6x6/serial.c ****   }
 191:keyboards/Manuform6x6/serial.c **** 
 192:keyboards/Manuform6x6/serial.c ****   // if the slave is present syncronize with it
 193:keyboards/Manuform6x6/serial.c ****   sync_recv();
 194:keyboards/Manuform6x6/serial.c **** 
 195:keyboards/Manuform6x6/serial.c ****   uint8_t checksum_computed = 0;
 196:keyboards/Manuform6x6/serial.c ****   // receive data from the slave
 197:keyboards/Manuform6x6/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 198:keyboards/Manuform6x6/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 199:keyboards/Manuform6x6/serial.c ****     sync_recv();
 200:keyboards/Manuform6x6/serial.c ****     checksum_computed += serial_slave_buffer[i];
 201:keyboards/Manuform6x6/serial.c ****   }
 202:keyboards/Manuform6x6/serial.c ****   uint8_t checksum_received = serial_read_byte();
 203:keyboards/Manuform6x6/serial.c ****   sync_recv();
 204:keyboards/Manuform6x6/serial.c **** 
 205:keyboards/Manuform6x6/serial.c ****   if (checksum_computed != checksum_received) {
 206:keyboards/Manuform6x6/serial.c ****     sei();
 828               		.loc 1 206 5 is_stmt 1 view .LVU225
 829               	/* #APP */
 830               	 ;  206 "keyboards/Manuform6x6/serial.c" 1
 831 0032 7894      		sei
 832               	 ;  0 "" 2
 207:keyboards/Manuform6x6/serial.c ****     return 1;
 833               		.loc 1 207 5 view .LVU226
 834               		.loc 1 207 12 is_stmt 0 view .LVU227
 835               	/* #NOAPP */
 836 0034 81E0      		ldi r24,lo8(1)
 837 0036 90E0      		ldi r25,0
 838               	.L25:
 839               	/* epilogue start */
 208:keyboards/Manuform6x6/serial.c ****   }
 209:keyboards/Manuform6x6/serial.c **** 
 210:keyboards/Manuform6x6/serial.c ****   uint8_t checksum = 0;
 211:keyboards/Manuform6x6/serial.c ****   // send data to the slave
 212:keyboards/Manuform6x6/serial.c ****   for (int i = 0; i < SERIAL_MASTER_BUFFER_LENGTH; ++i) {
 213:keyboards/Manuform6x6/serial.c ****     serial_write_byte(serial_master_buffer[i]);
 214:keyboards/Manuform6x6/serial.c ****     sync_recv();
 215:keyboards/Manuform6x6/serial.c ****     checksum += serial_master_buffer[i];
 216:keyboards/Manuform6x6/serial.c ****   }
 217:keyboards/Manuform6x6/serial.c ****   serial_write_byte(checksum);
 218:keyboards/Manuform6x6/serial.c ****   sync_recv();
 219:keyboards/Manuform6x6/serial.c **** 
 220:keyboards/Manuform6x6/serial.c ****   // always, release the line when not in use
 221:keyboards/Manuform6x6/serial.c ****   serial_output();
 222:keyboards/Manuform6x6/serial.c ****   serial_high();
 223:keyboards/Manuform6x6/serial.c **** 
 224:keyboards/Manuform6x6/serial.c ****   sei();
 225:keyboards/Manuform6x6/serial.c ****   return 0;
 226:keyboards/Manuform6x6/serial.c **** }
 840               		.loc 1 226 1 view .LVU228
 841 0038 DF91      		pop r29
 842 003a CF91      		pop r28
 843 003c 1F91      		pop r17
 844 003e FF90      		pop r15
 845 0040 EF90      		pop r14
 846 0042 0895      		ret
 847               	.L26:
 193:keyboards/Manuform6x6/serial.c **** 
 848               		.loc 1 193 3 is_stmt 1 view .LVU229
 849 0044 0E94 0000 		call sync_recv
 850               	.LVL56:
 195:keyboards/Manuform6x6/serial.c ****   // receive data from the slave
 851               		.loc 1 195 3 view .LVU230
 197:keyboards/Manuform6x6/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 852               		.loc 1 197 3 view .LVU231
 853               	.LBB123:
 197:keyboards/Manuform6x6/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 854               		.loc 1 197 8 view .LVU232
 197:keyboards/Manuform6x6/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 855               		.loc 1 197 12 is_stmt 0 view .LVU233
 856 0048 D0E0      		ldi r29,0
 857 004a C0E0      		ldi r28,0
 858               	.LVL57:
 859               	.L28:
 198:keyboards/Manuform6x6/serial.c ****     sync_recv();
 860               		.loc 1 198 5 is_stmt 1 discriminator 3 view .LVU234
 198:keyboards/Manuform6x6/serial.c ****     sync_recv();
 861               		.loc 1 198 30 is_stmt 0 discriminator 3 view .LVU235
 862 004c 0E94 0000 		call serial_read_byte
 863               	.LVL58:
 198:keyboards/Manuform6x6/serial.c ****     sync_recv();
 864               		.loc 1 198 28 discriminator 3 view .LVU236
 865 0050 FE01      		movw r30,r28
 866 0052 E050      		subi r30,lo8(-(serial_slave_buffer))
 867 0054 F040      		sbci r31,hi8(-(serial_slave_buffer))
 868 0056 7F01      		movw r14,r30
 869 0058 8083      		st Z,r24
 199:keyboards/Manuform6x6/serial.c ****     checksum_computed += serial_slave_buffer[i];
 870               		.loc 1 199 5 is_stmt 1 discriminator 3 view .LVU237
 871 005a 0E94 0000 		call sync_recv
 872               	.LVL59:
 200:keyboards/Manuform6x6/serial.c ****   }
 873               		.loc 1 200 5 discriminator 3 view .LVU238
 200:keyboards/Manuform6x6/serial.c ****   }
 874               		.loc 1 200 45 is_stmt 0 discriminator 3 view .LVU239
 875 005e F701      		movw r30,r14
 876 0060 8081      		ld r24,Z
 200:keyboards/Manuform6x6/serial.c ****   }
 877               		.loc 1 200 23 discriminator 3 view .LVU240
 878 0062 180F      		add r17,r24
 879               	.LVL60:
 197:keyboards/Manuform6x6/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 880               		.loc 1 197 51 discriminator 3 view .LVU241
 881 0064 2196      		adiw r28,1
 882               	.LVL61:
 197:keyboards/Manuform6x6/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 883               		.loc 1 197 3 discriminator 3 view .LVU242
 884 0066 C730      		cpi r28,7
 885 0068 D105      		cpc r29,__zero_reg__
 886 006a 01F4      		brne .L28
 887               	.LBE123:
 202:keyboards/Manuform6x6/serial.c ****   sync_recv();
 888               		.loc 1 202 3 is_stmt 1 view .LVU243
 202:keyboards/Manuform6x6/serial.c ****   sync_recv();
 889               		.loc 1 202 31 is_stmt 0 view .LVU244
 890 006c 0E94 0000 		call serial_read_byte
 891               	.LVL62:
 892 0070 C82F      		mov r28,r24
 893               	.LVL63:
 203:keyboards/Manuform6x6/serial.c **** 
 894               		.loc 1 203 3 is_stmt 1 view .LVU245
 895 0072 0E94 0000 		call sync_recv
 896               	.LVL64:
 205:keyboards/Manuform6x6/serial.c ****     sei();
 897               		.loc 1 205 3 view .LVU246
 205:keyboards/Manuform6x6/serial.c ****     sei();
 898               		.loc 1 205 6 is_stmt 0 view .LVU247
 899 0076 1C13      		cpse r17,r28
 900 0078 00C0      		rjmp .L31
 901               	.LVL65:
 902               	.LBB124:
 213:keyboards/Manuform6x6/serial.c ****     sync_recv();
 903               		.loc 1 213 5 is_stmt 1 discriminator 1 view .LVU248
 904 007a 8091 0000 		lds r24,serial_master_buffer
 905 007e 0E94 0000 		call serial_write_byte
 906               	.LVL66:
 214:keyboards/Manuform6x6/serial.c ****     checksum += serial_master_buffer[i];
 907               		.loc 1 214 5 discriminator 1 view .LVU249
 908 0082 0E94 0000 		call sync_recv
 909               	.LVL67:
 215:keyboards/Manuform6x6/serial.c ****   }
 910               		.loc 1 215 5 discriminator 1 view .LVU250
 215:keyboards/Manuform6x6/serial.c ****   }
 911               		.loc 1 215 37 is_stmt 0 discriminator 1 view .LVU251
 912 0086 8091 0000 		lds r24,serial_master_buffer
 913               	.LVL68:
 215:keyboards/Manuform6x6/serial.c ****   }
 914               		.loc 1 215 37 discriminator 1 view .LVU252
 915               	.LBE124:
 217:keyboards/Manuform6x6/serial.c ****   sync_recv();
 916               		.loc 1 217 3 is_stmt 1 discriminator 1 view .LVU253
 917 008a 0E94 0000 		call serial_write_byte
 918               	.LVL69:
 218:keyboards/Manuform6x6/serial.c **** 
 919               		.loc 1 218 3 discriminator 1 view .LVU254
 920 008e 0E94 0000 		call sync_recv
 921               	.LVL70:
 221:keyboards/Manuform6x6/serial.c ****   serial_high();
 922               		.loc 1 221 3 discriminator 1 view .LVU255
 923 0092 0E94 0000 		call serial_output
 924               	.LVL71:
 222:keyboards/Manuform6x6/serial.c **** 
 925               		.loc 1 222 3 discriminator 1 view .LVU256
 926 0096 0E94 0000 		call serial_high
 927               	.LVL72:
 224:keyboards/Manuform6x6/serial.c ****   return 0;
 928               		.loc 1 224 3 discriminator 1 view .LVU257
 929               	/* #APP */
 930               	 ;  224 "keyboards/Manuform6x6/serial.c" 1
 931 009a 7894      		sei
 932               	 ;  0 "" 2
 225:keyboards/Manuform6x6/serial.c **** }
 933               		.loc 1 225 3 discriminator 1 view .LVU258
 225:keyboards/Manuform6x6/serial.c **** }
 934               		.loc 1 225 10 is_stmt 0 discriminator 1 view .LVU259
 935               	/* #NOAPP */
 936 009c 90E0      		ldi r25,0
 937 009e 80E0      		ldi r24,0
 938 00a0 00C0      		rjmp .L25
 939               		.cfi_endproc
 940               	.LFE20:
 942               	.global	status
 943               		.section	.bss.status,"aw",@nobits
 946               	status:
 947 0000 00        		.zero	1
 948               	.global	serial_master_buffer
 949               		.section	.bss.serial_master_buffer,"aw",@nobits
 952               	serial_master_buffer:
 953 0000 00        		.zero	1
 954               	.global	serial_slave_buffer
 955               		.section	.bss.serial_slave_buffer,"aw",@nobits
 958               	serial_slave_buffer:
 959 0000 0000 0000 		.zero	7
 959      0000 00
 960               		.text
 961               	.Letext0:
 962               		.file 3 "/usr/local/Cellar/avr-gcc@8/8.3.0_1/avr/include/stdint.h"
 963               		.file 4 "keyboards/Manuform6x6/serial.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 serial.c
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:4      *ABS*:000000000000003f __SREG__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:12     .text.serial_output:0000000000000000 serial_output
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:32     .text.serial_input:0000000000000000 serial_input
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:54     .text.serial_high:0000000000000000 serial_high
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:73     .text.sync_recv:0000000000000000 sync_recv
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:132    .text.serial_read_byte:0000000000000000 serial_read_byte
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:235    .text.serial_write_byte:0000000000000000 serial_write_byte
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:348    .text.sync_send:0000000000000000 sync_send
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:404    .text.serial_master_init:0000000000000000 serial_master_init
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:424    .text.serial_slave_init:0000000000000000 serial_slave_init
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:454    .text.__vector_1:0000000000000000 __vector_1
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:958    .bss.serial_slave_buffer:0000000000000000 serial_slave_buffer
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:952    .bss.serial_master_buffer:0000000000000000 serial_master_buffer
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:946    .bss.status:0000000000000000 status
/var/folders/3d/n9bt7hnj55x7z_fzmyrbdqym0000gp/T//ccnAHyw2.s:721    .text.serial_update_buffers:0000000000000000 serial_update_buffers

UNDEFINED SYMBOLS
__do_clear_bss
