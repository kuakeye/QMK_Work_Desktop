   1               		.file	"serial.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.serial_output,"ax",@progbits
  12               	serial_output:
  13               	.LFB7:
  14               		.file 1 "keyboards/Manuform56/serial.c"
   1:keyboards/Manuform56/serial.c **** /*
   2:keyboards/Manuform56/serial.c ****  * WARNING: be careful changing this code, it is very timing dependent
   3:keyboards/Manuform56/serial.c ****  */
   4:keyboards/Manuform56/serial.c **** 
   5:keyboards/Manuform56/serial.c **** #ifndef F_CPU
   6:keyboards/Manuform56/serial.c **** #define F_CPU 16000000
   7:keyboards/Manuform56/serial.c **** #endif
   8:keyboards/Manuform56/serial.c **** 
   9:keyboards/Manuform56/serial.c **** #include <avr/io.h>
  10:keyboards/Manuform56/serial.c **** #include <avr/interrupt.h>
  11:keyboards/Manuform56/serial.c **** #include <util/delay.h>
  12:keyboards/Manuform56/serial.c **** #include <stdbool.h>
  13:keyboards/Manuform56/serial.c **** #include "serial.h"
  14:keyboards/Manuform56/serial.c **** 
  15:keyboards/Manuform56/serial.c **** #ifndef USE_I2C
  16:keyboards/Manuform56/serial.c **** 
  17:keyboards/Manuform56/serial.c **** // Serial pulse period in microseconds. Its probably a bad idea to lower this
  18:keyboards/Manuform56/serial.c **** // value.
  19:keyboards/Manuform56/serial.c **** #define SERIAL_DELAY 24
  20:keyboards/Manuform56/serial.c **** 
  21:keyboards/Manuform56/serial.c **** uint8_t volatile serial_slave_buffer[SERIAL_SLAVE_BUFFER_LENGTH] = {0};
  22:keyboards/Manuform56/serial.c **** uint8_t volatile serial_master_buffer[SERIAL_MASTER_BUFFER_LENGTH] = {0};
  23:keyboards/Manuform56/serial.c **** 
  24:keyboards/Manuform56/serial.c **** #define SLAVE_DATA_CORRUPT (1<<0)
  25:keyboards/Manuform56/serial.c **** volatile uint8_t status = 0;
  26:keyboards/Manuform56/serial.c **** 
  27:keyboards/Manuform56/serial.c **** inline static
  28:keyboards/Manuform56/serial.c **** void serial_delay(void) {
  29:keyboards/Manuform56/serial.c ****   _delay_us(SERIAL_DELAY);
  30:keyboards/Manuform56/serial.c **** }
  31:keyboards/Manuform56/serial.c **** 
  32:keyboards/Manuform56/serial.c **** inline static
  33:keyboards/Manuform56/serial.c **** void serial_output(void) {
  15               		.loc 1 33 0
  16               		.cfi_startproc
  17               	/* prologue: function */
  18               	/* frame size = 0 */
  19               	/* stack size = 0 */
  20               	.L__stack_usage = 0
  34:keyboards/Manuform56/serial.c ****   SERIAL_PIN_DDR |= SERIAL_PIN_MASK;
  21               		.loc 1 34 0
  22 0000 509A      		sbi 0xa,0
  23 0002 0895      		ret
  24               		.cfi_endproc
  25               	.LFE7:
  27               		.section	.text.serial_input,"ax",@progbits
  29               	serial_input:
  30               	.LFB8:
  35:keyboards/Manuform56/serial.c **** }
  36:keyboards/Manuform56/serial.c **** 
  37:keyboards/Manuform56/serial.c **** // make the serial pin an input with pull-up resistor
  38:keyboards/Manuform56/serial.c **** inline static
  39:keyboards/Manuform56/serial.c **** void serial_input(void) {
  31               		.loc 1 39 0
  32               		.cfi_startproc
  33               	/* prologue: function */
  34               	/* frame size = 0 */
  35               	/* stack size = 0 */
  36               	.L__stack_usage = 0
  40:keyboards/Manuform56/serial.c ****   SERIAL_PIN_DDR  &= ~SERIAL_PIN_MASK;
  37               		.loc 1 40 0
  38 0000 5098      		cbi 0xa,0
  41:keyboards/Manuform56/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
  39               		.loc 1 41 0
  40 0002 589A      		sbi 0xb,0
  41 0004 0895      		ret
  42               		.cfi_endproc
  43               	.LFE8:
  45               		.section	.text.serial_high,"ax",@progbits
  47               	serial_high:
  48               	.LFB11:
  42:keyboards/Manuform56/serial.c **** }
  43:keyboards/Manuform56/serial.c **** 
  44:keyboards/Manuform56/serial.c **** inline static
  45:keyboards/Manuform56/serial.c **** uint8_t serial_read_pin(void) {
  46:keyboards/Manuform56/serial.c ****   return !!(SERIAL_PIN_INPUT & SERIAL_PIN_MASK);
  47:keyboards/Manuform56/serial.c **** }
  48:keyboards/Manuform56/serial.c **** 
  49:keyboards/Manuform56/serial.c **** inline static
  50:keyboards/Manuform56/serial.c **** void serial_low(void) {
  51:keyboards/Manuform56/serial.c ****   SERIAL_PIN_PORT &= ~SERIAL_PIN_MASK;
  52:keyboards/Manuform56/serial.c **** }
  53:keyboards/Manuform56/serial.c **** 
  54:keyboards/Manuform56/serial.c **** inline static
  55:keyboards/Manuform56/serial.c **** void serial_high(void) {
  49               		.loc 1 55 0
  50               		.cfi_startproc
  51               	/* prologue: function */
  52               	/* frame size = 0 */
  53               	/* stack size = 0 */
  54               	.L__stack_usage = 0
  56:keyboards/Manuform56/serial.c ****   SERIAL_PIN_PORT |= SERIAL_PIN_MASK;
  55               		.loc 1 56 0
  56 0000 589A      		sbi 0xb,0
  57 0002 0895      		ret
  58               		.cfi_endproc
  59               	.LFE11:
  61               		.section	.text.sync_send,"ax",@progbits
  63               	sync_send:
  64               	.LFB15:
  57:keyboards/Manuform56/serial.c **** }
  58:keyboards/Manuform56/serial.c **** 
  59:keyboards/Manuform56/serial.c **** void serial_master_init(void) {
  60:keyboards/Manuform56/serial.c ****   serial_output();
  61:keyboards/Manuform56/serial.c ****   serial_high();
  62:keyboards/Manuform56/serial.c **** }
  63:keyboards/Manuform56/serial.c **** 
  64:keyboards/Manuform56/serial.c **** void serial_slave_init(void) {
  65:keyboards/Manuform56/serial.c ****   serial_input();
  66:keyboards/Manuform56/serial.c **** 
  67:keyboards/Manuform56/serial.c ****   // Enable INT0
  68:keyboards/Manuform56/serial.c ****   EIMSK |= _BV(INT0);
  69:keyboards/Manuform56/serial.c ****   // Trigger on falling edge of INT0
  70:keyboards/Manuform56/serial.c ****   EICRA &= ~(_BV(ISC00) | _BV(ISC01));
  71:keyboards/Manuform56/serial.c **** }
  72:keyboards/Manuform56/serial.c **** 
  73:keyboards/Manuform56/serial.c **** // Used by the master to synchronize timing with the slave.
  74:keyboards/Manuform56/serial.c **** static
  75:keyboards/Manuform56/serial.c **** void sync_recv(void) {
  76:keyboards/Manuform56/serial.c ****   serial_input();
  77:keyboards/Manuform56/serial.c ****   // This shouldn't hang if the slave disconnects because the
  78:keyboards/Manuform56/serial.c ****   // serial line will float to high if the slave does disconnect.
  79:keyboards/Manuform56/serial.c ****   while (!serial_read_pin());
  80:keyboards/Manuform56/serial.c ****   serial_delay();
  81:keyboards/Manuform56/serial.c **** }
  82:keyboards/Manuform56/serial.c **** 
  83:keyboards/Manuform56/serial.c **** // Used by the slave to send a synchronization signal to the master.
  84:keyboards/Manuform56/serial.c **** static
  85:keyboards/Manuform56/serial.c **** void sync_send(void) {
  65               		.loc 1 85 0
  66               		.cfi_startproc
  67               	/* prologue: function */
  68               	/* frame size = 0 */
  69               	/* stack size = 0 */
  70               	.L__stack_usage = 0
  86:keyboards/Manuform56/serial.c ****   serial_output();
  71               		.loc 1 86 0
  72 0000 0E94 0000 		call serial_output
  73               	.LVL0:
  74               	.LBB42:
  75               	.LBB43:
  51:keyboards/Manuform56/serial.c **** }
  76               		.loc 1 51 0
  77 0004 5898      		cbi 0xb,0
  78               	.LVL1:
  79               	.LBE43:
  80               	.LBE42:
  81               	.LBB44:
  82               	.LBB45:
  83               	.LBB46:
  84               		.file 2 "c:\\msys32\\home\\683654\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\util\\delay.h"
   1:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    All rights reserved.
   5:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   6:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Redistribution and use in source and binary forms, with or without
   7:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    modification, are permitted provided that the following conditions are met:
   8:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
   9:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions of source code must retain the above copyright
  10:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer.
  11:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  12:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      notice, this list of conditions and the following disclaimer in
  14:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      the documentation and/or other materials provided with the
  15:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      distribution.
  16:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  17:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    * Neither the name of the copyright holders nor the names of
  18:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      contributors may be used to endorse or promote products derived
  19:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****      from this software without specific prior written permission.
  20:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  21:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  33:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* $Id$ */
  34:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  35:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef _UTIL_DELAY_H_
  36:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #define _UTIL_DELAY_H_ 1
  37:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  38:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __DOXYGEN__
  39:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  endif
  42:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif  /* __DOXYGEN__ */
  43:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  44:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <inttypes.h>
  45:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <util/delay_basic.h>
  46:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #include <math.h>
  47:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  48:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \file */
  49:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \code
  51:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     //#define F_CPU 14.7456E6
  53:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     #include <util/delay.h>
  54:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \endcode
  55:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  56:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note As an alternative method, it is possible to pass the
  57:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     used.
  60:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  61:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions in this header file are wrappers around the basic
  62:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     convenience functions where actual time values can be specified
  64:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     that compile-time constant expressions will be eliminated by
  66:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compiler optimization so floating-point expressions can be used
  67:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     frequency passed by the macro F_CPU.
  69:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  70:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \note In order for these functions to work as intended, compiler
  71:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     <em>must</em> be an expression that is a known constant at
  73:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     delay will be much longer (and basically unpredictable), and
  75:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     applications that otherwise do not use floating-point calculations
  76:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     will experience severe code bloat by the floating-point library
  77:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     routines linked into the application.
  78:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  79:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The functions available allow the specification of microsecond, and
  80:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     millisecond delays directly, using the application-supplied macro
  81:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  83:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** */
  84:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  85:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if !defined(__DOXYGEN__)
  86:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
  89:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  90:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef F_CPU
  91:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /* prevent compiler error by supplying a default */
  92:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /** \ingroup util_delay
  94:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \def F_CPU
  95:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     \brief CPU frequency in Hz
  96:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
  97:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     the delay macros.  This macro is normally supplied by the
  99:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     environment (e.g. from within a project header, or the project's
 100:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     fallback if no such user-provided definition could be found.
 102:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 103:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****     integer value.
 107:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 108:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # define F_CPU 1000000UL
 109:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 110:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 111:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #ifndef __OPTIMIZE__
 112:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 114:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 115:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 118:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #  include <math.h>
 119:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 120:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 121:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 122:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 123:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 124:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 126:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 127:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 129:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 131:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    When the user request delay which exceed the maximum possible one,
 132:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    user will not be informed about decreased resolution.
 136:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 137:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflows results in
 140:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0ms.
 141:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 142:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 146:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 147:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 151:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 152:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 153:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 154:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 155:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 157:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 159:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 160:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 163:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 164:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 165:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 166:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_ms(double __ms)
 167:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 168:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 169:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 172:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 173:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 176:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 179:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 182:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 183:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 184:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 186:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 187:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 189:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #else
 190:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint16_t __ticks;
 191:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	if (__tmp < 1.0)
 193:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = 1;
 194:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else if (__tmp > 65535)
 195:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	{
 196:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		while(__ticks)
 199:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		{
 200:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 			// wait 1/10 ms
 201:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 			__ticks --;
 203:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		}
 204:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		return;
 205:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	}
 206:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	else
 207:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks = (uint16_t)__tmp;
 208:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	_delay_loop_2(__ticks);
 209:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #endif
 210:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** }
 211:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 212:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** /**
 213:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \ingroup util_delay
 214:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 215:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 217:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The macro F_CPU is supposed to be defined to a
 218:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 220:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 222:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    will not be informed about this case.
 225:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 226:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    values greater than the maximal possible delay, overflow results in
 229:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    no delay i.e., 0us.
 230:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 231:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    integer. This ensures that the user gets at least \c __us
 234:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    microseconds of delay.
 235:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 236:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    respectively.
 240:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 241:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \note
 242:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 243:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    The implementation of _delay_ms() based on
 244:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    implementations.  In order to get functionality backward compatible
 246:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    must be defined before including this header file. Also, the
 248:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    backward compatible algorithm will be chosen if the code is
 249:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****    not available to the compiler then.
 252:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 253:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****  */
 254:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** void
 255:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** _delay_us(double __us)
 256:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** {
 257:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	double __tmp ;
 258:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h ****   __STDC_HOSTED__
 261:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	uint32_t __ticks_dc;
 262:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 263:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 264:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 265:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 268:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 271:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#else
 272:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		//round up by default
 273:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 274:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	#endif
 275:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 
 276:c:\msys32\home\683654\qmk_utils\avr8-gnu-toolchain\avr\include\util\delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
  85               		.loc 2 276 0
  86 0006 80E8      		ldi r24,lo8(-128)
  87 0008 8A95      	1:	dec r24
  88 000a 01F4      		brne 1b
  89               	.LBE46:
  90               	.LBE45:
  91               	.LBE44:
  87:keyboards/Manuform56/serial.c **** 
  88:keyboards/Manuform56/serial.c ****   serial_low();
  89:keyboards/Manuform56/serial.c ****   serial_delay();
  90:keyboards/Manuform56/serial.c **** 
  91:keyboards/Manuform56/serial.c ****   serial_high();
  92               		.loc 1 91 0
  93 000c 0C94 0000 		jmp serial_high
  94               	.LVL2:
  95               		.cfi_endproc
  96               	.LFE15:
  98               		.section	.text.sync_recv,"ax",@progbits
 100               	sync_recv:
 101               	.LFB14:
  75:keyboards/Manuform56/serial.c ****   serial_input();
 102               		.loc 1 75 0
 103               		.cfi_startproc
 104               	/* prologue: function */
 105               	/* frame size = 0 */
 106               	/* stack size = 0 */
 107               	.L__stack_usage = 0
  76:keyboards/Manuform56/serial.c ****   // This shouldn't hang if the slave disconnects because the
 108               		.loc 1 76 0
 109 0000 0E94 0000 		call serial_input
 110               	.LVL3:
 111               	.L6:
  79:keyboards/Manuform56/serial.c ****   serial_delay();
 112               		.loc 1 79 0 discriminator 1
 113 0004 489B      		sbis 0x9,0
 114 0006 00C0      		rjmp .L6
 115               	.LVL4:
 116               	.LBB52:
 117               	.LBB53:
 118               	.LBB54:
 119               		.loc 2 276 0
 120 0008 80E8      		ldi r24,lo8(-128)
 121 000a 8A95      	1:	dec r24
 122 000c 01F4      		brne 1b
 123 000e 0895      		ret
 124               	.LBE54:
 125               	.LBE53:
 126               	.LBE52:
 127               		.cfi_endproc
 128               	.LFE14:
 130               		.section	.text.serial_read_byte,"ax",@progbits
 132               	serial_read_byte:
 133               	.LFB16:
  92:keyboards/Manuform56/serial.c **** }
  93:keyboards/Manuform56/serial.c **** 
  94:keyboards/Manuform56/serial.c **** // Reads a byte from the serial line
  95:keyboards/Manuform56/serial.c **** static
  96:keyboards/Manuform56/serial.c **** uint8_t serial_read_byte(void) {
 134               		.loc 1 96 0
 135               		.cfi_startproc
 136               	/* prologue: function */
 137               	/* frame size = 0 */
 138               	/* stack size = 0 */
 139               	.L__stack_usage = 0
 140               	.LVL5:
  97:keyboards/Manuform56/serial.c ****   uint8_t byte = 0;
  98:keyboards/Manuform56/serial.c ****   serial_input();
 141               		.loc 1 98 0
 142 0000 0E94 0000 		call serial_input
 143               	.LVL6:
 144 0004 98E0      		ldi r25,lo8(8)
  97:keyboards/Manuform56/serial.c ****   uint8_t byte = 0;
 145               		.loc 1 97 0
 146 0006 80E0      		ldi r24,0
 147               	.LVL7:
 148               	.L11:
 149               	.LBB63:
 150               	.LBB64:
 151               	.LBB65:
  46:keyboards/Manuform56/serial.c **** }
 152               		.loc 1 46 0 discriminator 3
 153 0008 29B1      		in r18,0x9
 154 000a 2170      		andi r18,lo8(1)
 155               	.LBE65:
 156               	.LBE64:
  99:keyboards/Manuform56/serial.c ****   for ( uint8_t i = 0; i < 8; ++i) {
 100:keyboards/Manuform56/serial.c ****     byte = (byte << 1) | serial_read_pin();
 157               		.loc 1 100 0 discriminator 3
 158 000c 880F      		lsl r24
 159               	.LVL8:
 160 000e 822B      		or r24,r18
 161               	.LVL9:
 162               	.LBB66:
 163               	.LBB67:
 164               	.LBB68:
 165               		.loc 2 276 0 discriminator 3
 166 0010 20E8      		ldi r18,lo8(-128)
 167 0012 2A95      	1:	dec r18
 168 0014 01F4      		brne 1b
 169               	.LVL10:
 170               	.LBE68:
 171               	.LBE67:
 172               	.LBE66:
 173               	.LBB69:
 174               	.LBB70:
 175 0016 25E0      		ldi r18,lo8(5)
 176 0018 2A95      	1:	dec r18
 177 001a 01F4      		brne 1b
 178 001c 0000      		nop
 179               	.LVL11:
 180 001e 9150      		subi r25,lo8(-(-1))
 181               	.LVL12:
 182               	.LBE70:
 183               	.LBE69:
  99:keyboards/Manuform56/serial.c ****   for ( uint8_t i = 0; i < 8; ++i) {
 184               		.loc 1 99 0 discriminator 3
 185 0020 01F4      		brne .L11
 186               	/* epilogue start */
 187               	.LBE63:
 101:keyboards/Manuform56/serial.c ****     serial_delay();
 102:keyboards/Manuform56/serial.c ****     _delay_us(1);
 103:keyboards/Manuform56/serial.c ****   }
 104:keyboards/Manuform56/serial.c **** 
 105:keyboards/Manuform56/serial.c ****   return byte;
 106:keyboards/Manuform56/serial.c **** }
 188               		.loc 1 106 0
 189 0022 0895      		ret
 190               		.cfi_endproc
 191               	.LFE16:
 193               		.section	.text.serial_write_byte,"ax",@progbits
 195               	serial_write_byte:
 196               	.LFB17:
 107:keyboards/Manuform56/serial.c **** 
 108:keyboards/Manuform56/serial.c **** // Sends a byte with MSB ordering
 109:keyboards/Manuform56/serial.c **** static
 110:keyboards/Manuform56/serial.c **** void serial_write_byte(uint8_t data) {
 197               		.loc 1 110 0
 198               		.cfi_startproc
 199               	.LVL13:
 200 0000 0F93      		push r16
 201               	.LCFI0:
 202               		.cfi_def_cfa_offset 3
 203               		.cfi_offset 16, -2
 204 0002 1F93      		push r17
 205               	.LCFI1:
 206               		.cfi_def_cfa_offset 4
 207               		.cfi_offset 17, -3
 208 0004 CF93      		push r28
 209               	.LCFI2:
 210               		.cfi_def_cfa_offset 5
 211               		.cfi_offset 28, -4
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 3 */
 215               	.L__stack_usage = 3
 216 0006 082F      		mov r16,r24
 217               	.LVL14:
 111:keyboards/Manuform56/serial.c ****   uint8_t b = 8;
 112:keyboards/Manuform56/serial.c ****   serial_output();
 218               		.loc 1 112 0
 219 0008 0E94 0000 		call serial_output
 220               	.LVL15:
 111:keyboards/Manuform56/serial.c ****   uint8_t b = 8;
 221               		.loc 1 111 0
 222 000c C8E0      		ldi r28,lo8(8)
 113:keyboards/Manuform56/serial.c ****   while( b-- ) {
 114:keyboards/Manuform56/serial.c ****     if(data & (1 << b)) {
 223               		.loc 1 114 0
 224 000e 10E0      		ldi r17,0
 225               	.LVL16:
 226               	.L14:
 113:keyboards/Manuform56/serial.c ****   while( b-- ) {
 227               		.loc 1 113 0
 228               	.LVL17:
 229 0010 C150      		subi r28,1
 230 0012 00F0      		brcs .L18
 231               		.loc 1 114 0
 232 0014 C801      		movw r24,r16
 233 0016 0C2E      		mov r0,r28
 234 0018 00C0      		rjmp 2f
 235               		1:
 236 001a 9595      		asr r25
 237 001c 8795      		ror r24
 238               		2:
 239 001e 0A94      		dec r0
 240 0020 02F4      		brpl 1b
 241 0022 80FF      		sbrs r24,0
 242 0024 00C0      		rjmp .L15
 115:keyboards/Manuform56/serial.c ****       serial_high();
 243               		.loc 1 115 0
 244 0026 0E94 0000 		call serial_high
 245               	.LVL18:
 246 002a 00C0      		rjmp .L16
 247               	.L15:
 248               	.LBB76:
 249               	.LBB77:
  51:keyboards/Manuform56/serial.c **** }
 250               		.loc 1 51 0
 251 002c 5898      		cbi 0xb,0
 252               	.L16:
 253               	.LVL19:
 254               	.LBE77:
 255               	.LBE76:
 256               	.LBB78:
 257               	.LBB79:
 258               	.LBB80:
 259               		.loc 2 276 0
 260 002e 80E8      		ldi r24,lo8(-128)
 261 0030 8A95      	1:	dec r24
 262 0032 01F4      		brne 1b
 263 0034 00C0      		rjmp .L14
 264               	.LVL20:
 265               	.L18:
 266               	/* epilogue start */
 267               	.LBE80:
 268               	.LBE79:
 269               	.LBE78:
 116:keyboards/Manuform56/serial.c ****     } else {
 117:keyboards/Manuform56/serial.c ****       serial_low();
 118:keyboards/Manuform56/serial.c ****     }
 119:keyboards/Manuform56/serial.c ****     serial_delay();
 120:keyboards/Manuform56/serial.c ****   }
 121:keyboards/Manuform56/serial.c **** }
 270               		.loc 1 121 0
 271 0036 CF91      		pop r28
 272               	.LVL21:
 273 0038 1F91      		pop r17
 274 003a 0F91      		pop r16
 275               	.LVL22:
 276 003c 0895      		ret
 277               		.cfi_endproc
 278               	.LFE17:
 280               		.section	.text.serial_master_init,"ax",@progbits
 281               	.global	serial_master_init
 283               	serial_master_init:
 284               	.LFB12:
  59:keyboards/Manuform56/serial.c ****   serial_output();
 285               		.loc 1 59 0
 286               		.cfi_startproc
 287               	/* prologue: function */
 288               	/* frame size = 0 */
 289               	/* stack size = 0 */
 290               	.L__stack_usage = 0
  60:keyboards/Manuform56/serial.c ****   serial_high();
 291               		.loc 1 60 0
 292 0000 0E94 0000 		call serial_output
 293               	.LVL23:
  61:keyboards/Manuform56/serial.c **** }
 294               		.loc 1 61 0
 295 0004 0C94 0000 		jmp serial_high
 296               	.LVL24:
 297               		.cfi_endproc
 298               	.LFE12:
 300               		.section	.text.serial_slave_init,"ax",@progbits
 301               	.global	serial_slave_init
 303               	serial_slave_init:
 304               	.LFB13:
  64:keyboards/Manuform56/serial.c ****   serial_input();
 305               		.loc 1 64 0
 306               		.cfi_startproc
 307               	/* prologue: function */
 308               	/* frame size = 0 */
 309               	/* stack size = 0 */
 310               	.L__stack_usage = 0
  65:keyboards/Manuform56/serial.c **** 
 311               		.loc 1 65 0
 312 0000 0E94 0000 		call serial_input
 313               	.LVL25:
  68:keyboards/Manuform56/serial.c ****   // Trigger on falling edge of INT0
 314               		.loc 1 68 0
 315 0004 E89A      		sbi 0x1d,0
  70:keyboards/Manuform56/serial.c **** }
 316               		.loc 1 70 0
 317 0006 E9E6      		ldi r30,lo8(105)
 318 0008 F0E0      		ldi r31,0
 319 000a 8081      		ld r24,Z
 320 000c 8C7F      		andi r24,lo8(-4)
 321 000e 8083      		st Z,r24
 322 0010 0895      		ret
 323               		.cfi_endproc
 324               	.LFE13:
 326               		.section	.text.__vector_1,"ax",@progbits
 327               	.global	__vector_1
 329               	__vector_1:
 330               	.LFB18:
 122:keyboards/Manuform56/serial.c **** 
 123:keyboards/Manuform56/serial.c **** // interrupt handle to be used by the slave device
 124:keyboards/Manuform56/serial.c **** ISR(SERIAL_PIN_INTERRUPT) {
 331               		.loc 1 124 0
 332               		.cfi_startproc
 333 0000 1F92      		push r1
 334               	.LCFI3:
 335               		.cfi_def_cfa_offset 3
 336               		.cfi_offset 1, -2
 337 0002 0F92      		push r0
 338               	.LCFI4:
 339               		.cfi_def_cfa_offset 4
 340               		.cfi_offset 0, -3
 341 0004 0FB6      		in r0,__SREG__
 342 0006 0F92      		push r0
 343 0008 1124      		clr __zero_reg__
 344 000a CF92      		push r12
 345               	.LCFI5:
 346               		.cfi_def_cfa_offset 5
 347               		.cfi_offset 12, -4
 348 000c DF92      		push r13
 349               	.LCFI6:
 350               		.cfi_def_cfa_offset 6
 351               		.cfi_offset 13, -5
 352 000e EF92      		push r14
 353               	.LCFI7:
 354               		.cfi_def_cfa_offset 7
 355               		.cfi_offset 14, -6
 356 0010 FF92      		push r15
 357               	.LCFI8:
 358               		.cfi_def_cfa_offset 8
 359               		.cfi_offset 15, -7
 360 0012 1F93      		push r17
 361               	.LCFI9:
 362               		.cfi_def_cfa_offset 9
 363               		.cfi_offset 17, -8
 364 0014 2F93      		push r18
 365               	.LCFI10:
 366               		.cfi_def_cfa_offset 10
 367               		.cfi_offset 18, -9
 368 0016 3F93      		push r19
 369               	.LCFI11:
 370               		.cfi_def_cfa_offset 11
 371               		.cfi_offset 19, -10
 372 0018 4F93      		push r20
 373               	.LCFI12:
 374               		.cfi_def_cfa_offset 12
 375               		.cfi_offset 20, -11
 376 001a 5F93      		push r21
 377               	.LCFI13:
 378               		.cfi_def_cfa_offset 13
 379               		.cfi_offset 21, -12
 380 001c 6F93      		push r22
 381               	.LCFI14:
 382               		.cfi_def_cfa_offset 14
 383               		.cfi_offset 22, -13
 384 001e 7F93      		push r23
 385               	.LCFI15:
 386               		.cfi_def_cfa_offset 15
 387               		.cfi_offset 23, -14
 388 0020 8F93      		push r24
 389               	.LCFI16:
 390               		.cfi_def_cfa_offset 16
 391               		.cfi_offset 24, -15
 392 0022 9F93      		push r25
 393               	.LCFI17:
 394               		.cfi_def_cfa_offset 17
 395               		.cfi_offset 25, -16
 396 0024 AF93      		push r26
 397               	.LCFI18:
 398               		.cfi_def_cfa_offset 18
 399               		.cfi_offset 26, -17
 400 0026 BF93      		push r27
 401               	.LCFI19:
 402               		.cfi_def_cfa_offset 19
 403               		.cfi_offset 27, -18
 404 0028 EF93      		push r30
 405               	.LCFI20:
 406               		.cfi_def_cfa_offset 20
 407               		.cfi_offset 30, -19
 408 002a FF93      		push r31
 409               	.LCFI21:
 410               		.cfi_def_cfa_offset 21
 411               		.cfi_offset 31, -20
 412 002c CF93      		push r28
 413               	.LCFI22:
 414               		.cfi_def_cfa_offset 22
 415               		.cfi_offset 28, -21
 416 002e DF93      		push r29
 417               	.LCFI23:
 418               		.cfi_def_cfa_offset 23
 419               		.cfi_offset 29, -22
 420 0030 1F92      		push __zero_reg__
 421               	.LCFI24:
 422               		.cfi_def_cfa_offset 24
 423 0032 CDB7      		in r28,__SP_L__
 424 0034 DEB7      		in r29,__SP_H__
 425               	.LCFI25:
 426               		.cfi_def_cfa_register 28
 427               	/* prologue: Signal */
 428               	/* frame size = 1 */
 429               	/* stack size = 23 */
 430               	.L__stack_usage = 23
 125:keyboards/Manuform56/serial.c ****   sync_send();
 431               		.loc 1 125 0
 432 0036 0E94 0000 		call sync_send
 433               	.LVL26:
 434               	.LBB81:
 126:keyboards/Manuform56/serial.c **** 
 127:keyboards/Manuform56/serial.c ****   uint8_t checksum = 0;
 128:keyboards/Manuform56/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 435               		.loc 1 128 0
 436 003a C12C      		mov r12,__zero_reg__
 437 003c D12C      		mov r13,__zero_reg__
 438               	.LBE81:
 127:keyboards/Manuform56/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 439               		.loc 1 127 0
 440 003e 10E0      		ldi r17,0
 441               	.LVL27:
 442               	.L22:
 443               	.LBB82:
 129:keyboards/Manuform56/serial.c ****     serial_write_byte(serial_slave_buffer[i]);
 444               		.loc 1 129 0 discriminator 3
 445 0040 C601      		movw r24,r12
 446 0042 8050      		subi r24,lo8(-(serial_slave_buffer))
 447 0044 9040      		sbci r25,hi8(-(serial_slave_buffer))
 448 0046 7C01      		movw r14,r24
 449 0048 FC01      		movw r30,r24
 450 004a 8081      		ld r24,Z
 451 004c 0E94 0000 		call serial_write_byte
 452               	.LVL28:
 130:keyboards/Manuform56/serial.c ****     sync_send();
 453               		.loc 1 130 0 discriminator 3
 454 0050 0E94 0000 		call sync_send
 455               	.LVL29:
 131:keyboards/Manuform56/serial.c ****     checksum += serial_slave_buffer[i];
 456               		.loc 1 131 0 discriminator 3
 457 0054 F701      		movw r30,r14
 458 0056 8081      		ld r24,Z
 459 0058 180F      		add r17,r24
 460               	.LVL30:
 128:keyboards/Manuform56/serial.c ****     serial_write_byte(serial_slave_buffer[i]);
 461               		.loc 1 128 0 discriminator 3
 462 005a FFEF      		ldi r31,-1
 463 005c CF1A      		sub r12,r31
 464 005e DF0A      		sbc r13,r31
 465               	.LVL31:
 466 0060 86E0      		ldi r24,6
 467 0062 C816      		cp r12,r24
 468 0064 D104      		cpc r13,__zero_reg__
 469 0066 01F4      		brne .L22
 470               	.LBE82:
 132:keyboards/Manuform56/serial.c ****   }
 133:keyboards/Manuform56/serial.c ****   serial_write_byte(checksum);
 471               		.loc 1 133 0
 472 0068 812F      		mov r24,r17
 473 006a 0E94 0000 		call serial_write_byte
 474               	.LVL32:
 134:keyboards/Manuform56/serial.c ****   sync_send();
 475               		.loc 1 134 0
 476 006e 0E94 0000 		call sync_send
 477               	.LVL33:
 478               	.LBB83:
 479               	.LBB84:
 480               	.LBB85:
 481               		.loc 2 276 0
 482 0072 90E8      		ldi r25,lo8(-128)
 483 0074 9A95      	1:	dec r25
 484 0076 01F4      		brne 1b
 485               	.LVL34:
 486               	.LBE85:
 487               	.LBE84:
 488               	.LBE83:
 489               	.LBB86:
 490               	.LBB87:
 491 0078 E0E4      		ldi r30,lo8(64)
 492 007a EA95      	1:	dec r30
 493 007c 01F4      		brne 1b
 494               	.LVL35:
 495               	.LBE87:
 496               	.LBE86:
 497               	.LBB88:
 135:keyboards/Manuform56/serial.c **** 
 136:keyboards/Manuform56/serial.c ****   // wait for the sync to finish sending
 137:keyboards/Manuform56/serial.c ****   serial_delay();
 138:keyboards/Manuform56/serial.c **** 
 139:keyboards/Manuform56/serial.c ****   // read the middle of pulses
 140:keyboards/Manuform56/serial.c ****   _delay_us(SERIAL_DELAY/2);
 141:keyboards/Manuform56/serial.c **** 
 142:keyboards/Manuform56/serial.c ****   uint8_t checksum_computed = 0;
 143:keyboards/Manuform56/serial.c ****   for (int i = 0; i < SERIAL_MASTER_BUFFER_LENGTH; ++i) {
 144:keyboards/Manuform56/serial.c ****     serial_master_buffer[i] = serial_read_byte();
 498               		.loc 1 144 0
 499 007e 0E94 0000 		call serial_read_byte
 500               	.LVL36:
 501 0082 8093 0000 		sts serial_master_buffer,r24
 145:keyboards/Manuform56/serial.c ****     sync_send();
 502               		.loc 1 145 0
 503 0086 0E94 0000 		call sync_send
 504               	.LVL37:
 146:keyboards/Manuform56/serial.c ****     checksum_computed += serial_master_buffer[i];
 505               		.loc 1 146 0
 506 008a 1091 0000 		lds r17,serial_master_buffer
 507               	.LVL38:
 508               	.LBE88:
 147:keyboards/Manuform56/serial.c ****   }
 148:keyboards/Manuform56/serial.c ****   uint8_t checksum_received = serial_read_byte();
 509               		.loc 1 148 0
 510 008e 0E94 0000 		call serial_read_byte
 511               	.LVL39:
 149:keyboards/Manuform56/serial.c ****   sync_send();
 512               		.loc 1 149 0
 513 0092 8983      		std Y+1,r24
 514 0094 0E94 0000 		call sync_send
 515               	.LVL40:
 150:keyboards/Manuform56/serial.c **** 
 151:keyboards/Manuform56/serial.c ****   serial_input(); // end transaction
 516               		.loc 1 151 0
 517 0098 0E94 0000 		call serial_input
 518               	.LVL41:
 152:keyboards/Manuform56/serial.c **** 
 153:keyboards/Manuform56/serial.c ****   if ( checksum_computed != checksum_received ) {
 519               		.loc 1 153 0
 520 009c 8981      		ldd r24,Y+1
 521 009e 1817      		cp r17,r24
 522 00a0 01F0      		breq .L23
 154:keyboards/Manuform56/serial.c ****     status |= SLAVE_DATA_CORRUPT;
 523               		.loc 1 154 0
 524 00a2 8091 0000 		lds r24,status
 525 00a6 8160      		ori r24,lo8(1)
 526 00a8 00C0      		rjmp .L26
 527               	.L23:
 155:keyboards/Manuform56/serial.c ****   } else {
 156:keyboards/Manuform56/serial.c ****     status &= ~SLAVE_DATA_CORRUPT;
 528               		.loc 1 156 0
 529 00aa 8091 0000 		lds r24,status
 530 00ae 8E7F      		andi r24,lo8(-2)
 531               	.L26:
 532 00b0 8093 0000 		sts status,r24
 533               	/* epilogue start */
 157:keyboards/Manuform56/serial.c ****   }
 158:keyboards/Manuform56/serial.c **** }
 534               		.loc 1 158 0
 535 00b4 0F90      		pop __tmp_reg__
 536 00b6 DF91      		pop r29
 537 00b8 CF91      		pop r28
 538 00ba FF91      		pop r31
 539 00bc EF91      		pop r30
 540 00be BF91      		pop r27
 541 00c0 AF91      		pop r26
 542 00c2 9F91      		pop r25
 543 00c4 8F91      		pop r24
 544 00c6 7F91      		pop r23
 545 00c8 6F91      		pop r22
 546 00ca 5F91      		pop r21
 547 00cc 4F91      		pop r20
 548 00ce 3F91      		pop r19
 549 00d0 2F91      		pop r18
 550 00d2 1F91      		pop r17
 551               	.LVL42:
 552 00d4 FF90      		pop r15
 553 00d6 EF90      		pop r14
 554 00d8 DF90      		pop r13
 555 00da CF90      		pop r12
 556               	.LVL43:
 557 00dc 0F90      		pop r0
 558 00de 0FBE      		out __SREG__,r0
 559 00e0 0F90      		pop r0
 560 00e2 1F90      		pop r1
 561 00e4 1895      		reti
 562               		.cfi_endproc
 563               	.LFE18:
 565               		.section	.text.serial_update_buffers,"ax",@progbits
 566               	.global	serial_update_buffers
 568               	serial_update_buffers:
 569               	.LFB20:
 159:keyboards/Manuform56/serial.c **** 
 160:keyboards/Manuform56/serial.c **** inline
 161:keyboards/Manuform56/serial.c **** bool serial_slave_DATA_CORRUPT(void) {
 162:keyboards/Manuform56/serial.c ****   return status & SLAVE_DATA_CORRUPT;
 163:keyboards/Manuform56/serial.c **** }
 164:keyboards/Manuform56/serial.c **** 
 165:keyboards/Manuform56/serial.c **** // Copies the serial_slave_buffer to the master and sends the
 166:keyboards/Manuform56/serial.c **** // serial_master_buffer to the slave.
 167:keyboards/Manuform56/serial.c **** //
 168:keyboards/Manuform56/serial.c **** // Returns:
 169:keyboards/Manuform56/serial.c **** // 0 => no error
 170:keyboards/Manuform56/serial.c **** // 1 => slave did not respond
 171:keyboards/Manuform56/serial.c **** int serial_update_buffers(void) {
 570               		.loc 1 171 0
 571               		.cfi_startproc
 572 0000 CF92      		push r12
 573               	.LCFI26:
 574               		.cfi_def_cfa_offset 3
 575               		.cfi_offset 12, -2
 576 0002 DF92      		push r13
 577               	.LCFI27:
 578               		.cfi_def_cfa_offset 4
 579               		.cfi_offset 13, -3
 580 0004 EF92      		push r14
 581               	.LCFI28:
 582               		.cfi_def_cfa_offset 5
 583               		.cfi_offset 14, -4
 584 0006 FF92      		push r15
 585               	.LCFI29:
 586               		.cfi_def_cfa_offset 6
 587               		.cfi_offset 15, -5
 588 0008 1F93      		push r17
 589               	.LCFI30:
 590               		.cfi_def_cfa_offset 7
 591               		.cfi_offset 17, -6
 592 000a CF93      		push r28
 593               	.LCFI31:
 594               		.cfi_def_cfa_offset 8
 595               		.cfi_offset 28, -7
 596 000c DF93      		push r29
 597               	.LCFI32:
 598               		.cfi_def_cfa_offset 9
 599               		.cfi_offset 29, -8
 600 000e 1F92      		push __zero_reg__
 601               	.LCFI33:
 602               		.cfi_def_cfa_offset 10
 603 0010 CDB7      		in r28,__SP_L__
 604 0012 DEB7      		in r29,__SP_H__
 605               	.LCFI34:
 606               		.cfi_def_cfa_register 28
 607               	/* prologue: function */
 608               	/* frame size = 1 */
 609               	/* stack size = 8 */
 610               	.L__stack_usage = 8
 172:keyboards/Manuform56/serial.c ****   // this code is very time dependent, so we need to disable interrupts
 173:keyboards/Manuform56/serial.c ****   cli();
 611               		.loc 1 173 0
 612               	/* #APP */
 613               	 ;  173 "keyboards/Manuform56/serial.c" 1
 614 0014 F894      		cli
 615               	 ;  0 "" 2
 174:keyboards/Manuform56/serial.c **** 
 175:keyboards/Manuform56/serial.c ****   // signal to the slave that we want to start a transaction
 176:keyboards/Manuform56/serial.c ****   serial_output();
 616               		.loc 1 176 0
 617               	/* #NOAPP */
 618 0016 0E94 0000 		call serial_output
 619               	.LVL44:
 620               	.LBB99:
 621               	.LBB100:
  51:keyboards/Manuform56/serial.c **** }
 622               		.loc 1 51 0
 623 001a 5898      		cbi 0xb,0
 624               	.LVL45:
 625               	.LBE100:
 626               	.LBE99:
 627               	.LBB101:
 628               	.LBB102:
 629               		.loc 2 276 0
 630 001c 25E0      		ldi r18,lo8(5)
 631 001e 2A95      	1:	dec r18
 632 0020 01F4      		brne 1b
 633 0022 0000      		nop
 634               	.LBE102:
 635               	.LBE101:
 177:keyboards/Manuform56/serial.c ****   serial_low();
 178:keyboards/Manuform56/serial.c ****   _delay_us(1);
 179:keyboards/Manuform56/serial.c **** 
 180:keyboards/Manuform56/serial.c ****   // wait for the slaves response
 181:keyboards/Manuform56/serial.c ****   serial_input();
 636               		.loc 1 181 0
 637 0024 0E94 0000 		call serial_input
 638               	.LVL46:
 182:keyboards/Manuform56/serial.c ****   serial_high();
 639               		.loc 1 182 0
 640 0028 0E94 0000 		call serial_high
 641               	.LVL47:
 642               	.LBB103:
 643               	.LBB104:
 644               		.loc 2 276 0
 645 002c 30E8      		ldi r19,lo8(-128)
 646 002e 3A95      	1:	dec r19
 647 0030 01F4      		brne 1b
 648               	.LBE104:
 649               	.LBE103:
 183:keyboards/Manuform56/serial.c ****   _delay_us(SERIAL_DELAY);
 184:keyboards/Manuform56/serial.c **** 
 185:keyboards/Manuform56/serial.c ****   // check if the slave is present
 186:keyboards/Manuform56/serial.c ****   if (serial_read_pin()) {
 650               		.loc 1 186 0
 651 0032 4899      		sbic 0x9,0
 652 0034 00C0      		rjmp .L31
 187:keyboards/Manuform56/serial.c ****     // slave failed to pull the line low, assume not present
 188:keyboards/Manuform56/serial.c ****     sei();
 189:keyboards/Manuform56/serial.c ****     return 1;
 190:keyboards/Manuform56/serial.c ****   }
 191:keyboards/Manuform56/serial.c **** 
 192:keyboards/Manuform56/serial.c ****   // if the slave is present syncronize with it
 193:keyboards/Manuform56/serial.c ****   sync_recv();
 653               		.loc 1 193 0
 654 0036 0E94 0000 		call sync_recv
 655               	.LVL48:
 656               	.LBB105:
 194:keyboards/Manuform56/serial.c **** 
 195:keyboards/Manuform56/serial.c ****   uint8_t checksum_computed = 0;
 196:keyboards/Manuform56/serial.c ****   // receive data from the slave
 197:keyboards/Manuform56/serial.c ****   for (int i = 0; i < SERIAL_SLAVE_BUFFER_LENGTH; ++i) {
 657               		.loc 1 197 0
 658 003a C12C      		mov r12,__zero_reg__
 659 003c D12C      		mov r13,__zero_reg__
 660               	.LBE105:
 195:keyboards/Manuform56/serial.c ****   // receive data from the slave
 661               		.loc 1 195 0
 662 003e 10E0      		ldi r17,0
 663               	.LVL49:
 664               	.L30:
 665               	.LBB106:
 198:keyboards/Manuform56/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 666               		.loc 1 198 0 discriminator 3
 667 0040 0E94 0000 		call serial_read_byte
 668               	.LVL50:
 669 0044 F601      		movw r30,r12
 670 0046 E050      		subi r30,lo8(-(serial_slave_buffer))
 671 0048 F040      		sbci r31,hi8(-(serial_slave_buffer))
 672 004a 7F01      		movw r14,r30
 673 004c 8083      		st Z,r24
 199:keyboards/Manuform56/serial.c ****     sync_recv();
 674               		.loc 1 199 0 discriminator 3
 675 004e 0E94 0000 		call sync_recv
 676               	.LVL51:
 200:keyboards/Manuform56/serial.c ****     checksum_computed += serial_slave_buffer[i];
 677               		.loc 1 200 0 discriminator 3
 678 0052 F701      		movw r30,r14
 679 0054 8081      		ld r24,Z
 680 0056 180F      		add r17,r24
 681               	.LVL52:
 197:keyboards/Manuform56/serial.c ****     serial_slave_buffer[i] = serial_read_byte();
 682               		.loc 1 197 0 discriminator 3
 683 0058 FFEF      		ldi r31,-1
 684 005a CF1A      		sub r12,r31
 685 005c DF0A      		sbc r13,r31
 686               	.LVL53:
 687 005e 26E0      		ldi r18,6
 688 0060 C216      		cp r12,r18
 689 0062 D104      		cpc r13,__zero_reg__
 690 0064 01F4      		brne .L30
 691               	.LBE106:
 201:keyboards/Manuform56/serial.c ****   }
 202:keyboards/Manuform56/serial.c ****   uint8_t checksum_received = serial_read_byte();
 692               		.loc 1 202 0
 693 0066 0E94 0000 		call serial_read_byte
 694               	.LVL54:
 203:keyboards/Manuform56/serial.c ****   sync_recv();
 695               		.loc 1 203 0
 696 006a 8983      		std Y+1,r24
 697 006c 0E94 0000 		call sync_recv
 698               	.LVL55:
 204:keyboards/Manuform56/serial.c **** 
 205:keyboards/Manuform56/serial.c ****   if (checksum_computed != checksum_received) {
 699               		.loc 1 205 0
 700 0070 8981      		ldd r24,Y+1
 701 0072 1813      		cpse r17,r24
 702 0074 00C0      		rjmp .L31
 703               	.LVL56:
 704               	.LBB107:
 206:keyboards/Manuform56/serial.c ****     sei();
 207:keyboards/Manuform56/serial.c ****     return 1;
 208:keyboards/Manuform56/serial.c ****   }
 209:keyboards/Manuform56/serial.c **** 
 210:keyboards/Manuform56/serial.c ****   uint8_t checksum = 0;
 211:keyboards/Manuform56/serial.c ****   // send data to the slave
 212:keyboards/Manuform56/serial.c ****   for (int i = 0; i < SERIAL_MASTER_BUFFER_LENGTH; ++i) {
 213:keyboards/Manuform56/serial.c ****     serial_write_byte(serial_master_buffer[i]);
 705               		.loc 1 213 0 discriminator 1
 706 0076 8091 0000 		lds r24,serial_master_buffer
 707 007a 0E94 0000 		call serial_write_byte
 708               	.LVL57:
 214:keyboards/Manuform56/serial.c ****     sync_recv();
 709               		.loc 1 214 0 discriminator 1
 710 007e 0E94 0000 		call sync_recv
 711               	.LVL58:
 215:keyboards/Manuform56/serial.c ****     checksum += serial_master_buffer[i];
 712               		.loc 1 215 0 discriminator 1
 713 0082 8091 0000 		lds r24,serial_master_buffer
 714               	.LVL59:
 715               	.LBE107:
 216:keyboards/Manuform56/serial.c ****   }
 217:keyboards/Manuform56/serial.c ****   serial_write_byte(checksum);
 716               		.loc 1 217 0 discriminator 1
 717 0086 0E94 0000 		call serial_write_byte
 718               	.LVL60:
 218:keyboards/Manuform56/serial.c ****   sync_recv();
 719               		.loc 1 218 0 discriminator 1
 720 008a 0E94 0000 		call sync_recv
 721               	.LVL61:
 219:keyboards/Manuform56/serial.c **** 
 220:keyboards/Manuform56/serial.c ****   // always, release the line when not in use
 221:keyboards/Manuform56/serial.c ****   serial_output();
 722               		.loc 1 221 0 discriminator 1
 723 008e 0E94 0000 		call serial_output
 724               	.LVL62:
 222:keyboards/Manuform56/serial.c ****   serial_high();
 725               		.loc 1 222 0 discriminator 1
 726 0092 0E94 0000 		call serial_high
 727               	.LVL63:
 223:keyboards/Manuform56/serial.c **** 
 224:keyboards/Manuform56/serial.c ****   sei();
 728               		.loc 1 224 0 discriminator 1
 729               	/* #APP */
 730               	 ;  224 "keyboards/Manuform56/serial.c" 1
 731 0096 7894      		sei
 732               	 ;  0 "" 2
 225:keyboards/Manuform56/serial.c ****   return 0;
 733               		.loc 1 225 0 discriminator 1
 734               	/* #NOAPP */
 735 0098 80E0      		ldi r24,0
 736 009a 90E0      		ldi r25,0
 737 009c 00C0      		rjmp .L29
 738               	.LVL64:
 739               	.L31:
 206:keyboards/Manuform56/serial.c ****     return 1;
 740               		.loc 1 206 0
 741               	/* #APP */
 742               	 ;  206 "keyboards/Manuform56/serial.c" 1
 743 009e 7894      		sei
 744               	 ;  0 "" 2
 207:keyboards/Manuform56/serial.c ****   }
 745               		.loc 1 207 0
 746               	/* #NOAPP */
 747 00a0 81E0      		ldi r24,lo8(1)
 748 00a2 90E0      		ldi r25,0
 749               	.L29:
 750               	/* epilogue start */
 226:keyboards/Manuform56/serial.c **** }
 751               		.loc 1 226 0
 752 00a4 0F90      		pop __tmp_reg__
 753 00a6 DF91      		pop r29
 754 00a8 CF91      		pop r28
 755 00aa 1F91      		pop r17
 756 00ac FF90      		pop r15
 757 00ae EF90      		pop r14
 758 00b0 DF90      		pop r13
 759 00b2 CF90      		pop r12
 760 00b4 0895      		ret
 761               		.cfi_endproc
 762               	.LFE20:
 764               	.global	status
 765               		.section	.bss.status,"aw",@nobits
 768               	status:
 769 0000 00        		.zero	1
 770               	.global	serial_master_buffer
 771               		.section	.bss.serial_master_buffer,"aw",@nobits
 774               	serial_master_buffer:
 775 0000 00        		.zero	1
 776               	.global	serial_slave_buffer
 777               		.section	.bss.serial_slave_buffer,"aw",@nobits
 780               	serial_slave_buffer:
 781 0000 0000 0000 		.zero	6
 781      0000 
 782               		.text
 783               	.Letext0:
 784               		.file 3 "c:\\msys32\\home\\683654\\qmk_utils\\avr8-gnu-toolchain\\avr\\include\\stdint.h"
DEFINED SYMBOLS
                            *ABS*:00000000 serial.c
C:\msys32\tmp\ccv55ufb.s:2      *ABS*:0000003e __SP_H__
C:\msys32\tmp\ccv55ufb.s:3      *ABS*:0000003d __SP_L__
C:\msys32\tmp\ccv55ufb.s:4      *ABS*:0000003f __SREG__
C:\msys32\tmp\ccv55ufb.s:5      *ABS*:00000000 __tmp_reg__
C:\msys32\tmp\ccv55ufb.s:6      *ABS*:00000001 __zero_reg__
C:\msys32\tmp\ccv55ufb.s:12     .text.serial_output:00000000 serial_output
C:\msys32\tmp\ccv55ufb.s:29     .text.serial_input:00000000 serial_input
C:\msys32\tmp\ccv55ufb.s:47     .text.serial_high:00000000 serial_high
C:\msys32\tmp\ccv55ufb.s:63     .text.sync_send:00000000 sync_send
C:\msys32\tmp\ccv55ufb.s:100    .text.sync_recv:00000000 sync_recv
C:\msys32\tmp\ccv55ufb.s:132    .text.serial_read_byte:00000000 serial_read_byte
C:\msys32\tmp\ccv55ufb.s:195    .text.serial_write_byte:00000000 serial_write_byte
C:\msys32\tmp\ccv55ufb.s:283    .text.serial_master_init:00000000 serial_master_init
C:\msys32\tmp\ccv55ufb.s:303    .text.serial_slave_init:00000000 serial_slave_init
C:\msys32\tmp\ccv55ufb.s:329    .text.__vector_1:00000000 __vector_1
C:\msys32\tmp\ccv55ufb.s:780    .bss.serial_slave_buffer:00000000 serial_slave_buffer
C:\msys32\tmp\ccv55ufb.s:774    .bss.serial_master_buffer:00000000 serial_master_buffer
C:\msys32\tmp\ccv55ufb.s:768    .bss.status:00000000 status
C:\msys32\tmp\ccv55ufb.s:568    .text.serial_update_buffers:00000000 serial_update_buffers

UNDEFINED SYMBOLS
__do_clear_bss
